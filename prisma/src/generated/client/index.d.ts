
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: number
  firstName: string
  lastName: string
  username: string
  password: string
  phoneNumber: string
  isAdmin: boolean
  createdAt: Date
  updatedAt: Date
  lastLogin: Date | null
  emailAddress: string | null
}

/**
 * Model Action
 * 
 */
export type Action = {
  id: string
  userId: number
  actionType: boolean
  description: string
}

/**
 * Model Transaction
 * 
 */
export type Transaction = {
  id: number
  initiatedBy: number
  createdAt: Date
  totalPaid: Prisma.Decimal | null
  totalPayable: Prisma.Decimal | null
  supplierId: string | null
  errorDescription: string | null
  customerId: string | null
  type: TransactionType
  status: TransactionStatusCodes
}

/**
 * Model Payment
 * 
 */
export type Payment = {
  id: string
  paymentTypeId: string
  currencyId: string
  exchangeRateId: string
  transactionId: number
  paid: Prisma.Decimal
}

/**
 * Model PaymentType
 * 
 */
export type PaymentType = {
  id: string
  paymentTypeName: string
  charges: Prisma.Decimal
  discount: Prisma.Decimal
}

/**
 * Model Tax
 * 
 */
export type Tax = {
  id: string
  taxName: string
  taxRate: string
  startAmount: Prisma.Decimal
  endAmount: Prisma.Decimal
  active: boolean
  startDate: Date
  endDate: Date
}

/**
 * Model Promotions
 * 
 */
export type Promotions = {
  id: string
  productId: string
  productGroupId: string
  startDate: Date
  endDate: Date
  discountRate: Prisma.Decimal
}

/**
 * Model ProductGroup
 * 
 */
export type ProductGroup = {
  id: string
  taxId: string | null
}

/**
 * Model Product
 * 
 */
export type Product = {
  id: string
  barcode: string
  productName: string
  measurementUnit: MeasurementUnit
  expiryDate: Date
  measurementAmount: number
  cost: Prisma.Decimal
  quantity: number
  supplierId: string | null
  productGroupId: string | null
  updatedAt: Date
  createdAt: Date
  depleted: boolean
  disposed: boolean
}

/**
 * Model Prices
 * 
 */
export type Prices = {
  id: string
  barcode: string
  price: Prisma.Decimal
  active: boolean
  exchangeRateId: string
  productId: string | null
}

/**
 * Model invoice
 * 
 */
export type invoice = {
  id: string
  productId: string
  discount: Prisma.Decimal
  price: Prisma.Decimal
  quantity: number
  transactionId: number
  cashierId: number
  customerId: string | null
  createdAt: Date
  updatedAt: Date
  supplierId: string | null
}

/**
 * Model Supplier
 * 
 */
export type Supplier = {
  id: string
  firstName: string | null
  lastName: string | null
  phoneNumber: string | null
  corporateName: string | null
  updatedAt: Date
  createdAt: Date
  emailAddress: string | null
}

/**
 * Model Customer
 * 
 */
export type Customer = {
  id: string
  firstName: string
  lastName: string
  phoneNumber: string | null
  emailAddress: string | null
  updatedAt: Date
  createdAt: Date
}

/**
 * Model Address
 * 
 */
export type Address = {
  id: string
  supplierId: string | null
  customerId: string | null
  street: string
  city: string
  country: string
  zip: string | null
}

/**
 * Model baseCurrency
 * 
 */
export type baseCurrency = {
  id: string
  currencyId: string
  createdAt: Date
  active: boolean
}

/**
 * Model currency
 * 
 */
export type currency = {
  id: string
  currencyName: string
  updatedAt: Date
  createdAt: Date
}

/**
 * Model disposals
 * 
 */
export type disposals = {
  id: string
  productId: string
  priceId: string
  createdAt: Date
}

/**
 * Model exchangeRates
 * 
 */
export type exchangeRates = {
  id: string
  exchangeRate: Prisma.Decimal
  currencyId: string
  createdAt: Date
  baseCurrencyId: string
  active: boolean
}

/**
 * Model Journal
 * 
 */
export type Journal = {
  id: string
  recorderId: number
  supplierId: string | null
  customerId: string | null
  transactionId: number
  narration: string
  amount: Prisma.Decimal
}

/**
 * Model SalesJournal
 * 
 */
export type SalesJournal = {
  id: string
  recorderId: number
  supplierId: string
  transactionId: number
  narration: string
  amount: Prisma.Decimal
}

/**
 * Model PurchasesJournal
 * 
 */
export type PurchasesJournal = {
  id: string
  recorderId: number
  customerId: string | null
  transactionId: number
  narration: string
  amount: Prisma.Decimal
}

/**
 * Model CashDisbursementsJournal
 * 
 */
export type CashDisbursementsJournal = {
  id: string
  recorderId: number
  supplierId: string | null
  customerId: string | null
  transactionId: number
  narration: string
  amount: Prisma.Decimal
}

/**
 * Model CashReceiptsJournal
 * 
 */
export type CashReceiptsJournal = {
  id: string
  recorderId: number
  supplierId: string | null
  customerId: string | null
  transactionId: number
  narration: string
  amount: Prisma.Decimal
}

/**
 * Model ReturnsInwardsJournal
 * 
 */
export type ReturnsInwardsJournal = {
  id: string
  recorderId: number
  customerId: string
  transactionId: number
  narration: string
  amount: Prisma.Decimal
}

/**
 * Model ReturnsOutwardsJournal
 * 
 */
export type ReturnsOutwardsJournal = {
  id: string
  recorderId: number
  supplierId: string
  transactionId: number
  narration: string
  amount: Prisma.Decimal
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const TransactionType: {
  PURCHASE: 'PURCHASE',
  SALES: 'SALES'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const TransactionStatusCodes: {
  PENDING: 'PENDING',
  FAILED: 'FAILED',
  SUCCEEDED: 'SUCCEEDED'
};

export type TransactionStatusCodes = (typeof TransactionStatusCodes)[keyof typeof TransactionStatusCodes]


export const MeasurementUnit: {
  KILOGRAMS: 'KILOGRAMS',
  GRAMS: 'GRAMS',
  LITRES: 'LITRES',
  MILLILITRES: 'MILLILITRES'
};

export type MeasurementUnit = (typeof MeasurementUnit)[keyof typeof MeasurementUnit]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: { maxWait?: number, timeout?: number }): Promise<R>;

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.action`: Exposes CRUD operations for the **Action** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actions
    * const actions = await prisma.action.findMany()
    * ```
    */
  get action(): Prisma.ActionDelegate<GlobalReject>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<GlobalReject>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<GlobalReject>;

  /**
   * `prisma.paymentType`: Exposes CRUD operations for the **PaymentType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentTypes
    * const paymentTypes = await prisma.paymentType.findMany()
    * ```
    */
  get paymentType(): Prisma.PaymentTypeDelegate<GlobalReject>;

  /**
   * `prisma.tax`: Exposes CRUD operations for the **Tax** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Taxes
    * const taxes = await prisma.tax.findMany()
    * ```
    */
  get tax(): Prisma.TaxDelegate<GlobalReject>;

  /**
   * `prisma.promotions`: Exposes CRUD operations for the **Promotions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promotions
    * const promotions = await prisma.promotions.findMany()
    * ```
    */
  get promotions(): Prisma.PromotionsDelegate<GlobalReject>;

  /**
   * `prisma.productGroup`: Exposes CRUD operations for the **ProductGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductGroups
    * const productGroups = await prisma.productGroup.findMany()
    * ```
    */
  get productGroup(): Prisma.ProductGroupDelegate<GlobalReject>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<GlobalReject>;

  /**
   * `prisma.prices`: Exposes CRUD operations for the **Prices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prices
    * const prices = await prisma.prices.findMany()
    * ```
    */
  get prices(): Prisma.PricesDelegate<GlobalReject>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.invoiceDelegate<GlobalReject>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<GlobalReject>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<GlobalReject>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<GlobalReject>;

  /**
   * `prisma.baseCurrency`: Exposes CRUD operations for the **baseCurrency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BaseCurrencies
    * const baseCurrencies = await prisma.baseCurrency.findMany()
    * ```
    */
  get baseCurrency(): Prisma.baseCurrencyDelegate<GlobalReject>;

  /**
   * `prisma.currency`: Exposes CRUD operations for the **currency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Currencies
    * const currencies = await prisma.currency.findMany()
    * ```
    */
  get currency(): Prisma.currencyDelegate<GlobalReject>;

  /**
   * `prisma.disposals`: Exposes CRUD operations for the **disposals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Disposals
    * const disposals = await prisma.disposals.findMany()
    * ```
    */
  get disposals(): Prisma.disposalsDelegate<GlobalReject>;

  /**
   * `prisma.exchangeRates`: Exposes CRUD operations for the **exchangeRates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExchangeRates
    * const exchangeRates = await prisma.exchangeRates.findMany()
    * ```
    */
  get exchangeRates(): Prisma.exchangeRatesDelegate<GlobalReject>;

  /**
   * `prisma.journal`: Exposes CRUD operations for the **Journal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Journals
    * const journals = await prisma.journal.findMany()
    * ```
    */
  get journal(): Prisma.JournalDelegate<GlobalReject>;

  /**
   * `prisma.salesJournal`: Exposes CRUD operations for the **SalesJournal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesJournals
    * const salesJournals = await prisma.salesJournal.findMany()
    * ```
    */
  get salesJournal(): Prisma.SalesJournalDelegate<GlobalReject>;

  /**
   * `prisma.purchasesJournal`: Exposes CRUD operations for the **PurchasesJournal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchasesJournals
    * const purchasesJournals = await prisma.purchasesJournal.findMany()
    * ```
    */
  get purchasesJournal(): Prisma.PurchasesJournalDelegate<GlobalReject>;

  /**
   * `prisma.cashDisbursementsJournal`: Exposes CRUD operations for the **CashDisbursementsJournal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashDisbursementsJournals
    * const cashDisbursementsJournals = await prisma.cashDisbursementsJournal.findMany()
    * ```
    */
  get cashDisbursementsJournal(): Prisma.CashDisbursementsJournalDelegate<GlobalReject>;

  /**
   * `prisma.cashReceiptsJournal`: Exposes CRUD operations for the **CashReceiptsJournal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashReceiptsJournals
    * const cashReceiptsJournals = await prisma.cashReceiptsJournal.findMany()
    * ```
    */
  get cashReceiptsJournal(): Prisma.CashReceiptsJournalDelegate<GlobalReject>;

  /**
   * `prisma.returnsInwardsJournal`: Exposes CRUD operations for the **ReturnsInwardsJournal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReturnsInwardsJournals
    * const returnsInwardsJournals = await prisma.returnsInwardsJournal.findMany()
    * ```
    */
  get returnsInwardsJournal(): Prisma.ReturnsInwardsJournalDelegate<GlobalReject>;

  /**
   * `prisma.returnsOutwardsJournal`: Exposes CRUD operations for the **ReturnsOutwardsJournal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReturnsOutwardsJournals
    * const returnsOutwardsJournals = await prisma.returnsOutwardsJournal.findMany()
    * ```
    */
  get returnsOutwardsJournal(): Prisma.ReturnsOutwardsJournalDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Prisma Client JS version: 4.0.0
   * Query Engine version: da41d2bb3406da22087b849f0e911199ba4fbf11
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    Action: 'Action',
    Transaction: 'Transaction',
    Payment: 'Payment',
    PaymentType: 'PaymentType',
    Tax: 'Tax',
    Promotions: 'Promotions',
    ProductGroup: 'ProductGroup',
    Product: 'Product',
    Prices: 'Prices',
    invoice: 'invoice',
    Supplier: 'Supplier',
    Customer: 'Customer',
    Address: 'Address',
    baseCurrency: 'baseCurrency',
    currency: 'currency',
    disposals: 'disposals',
    exchangeRates: 'exchangeRates',
    Journal: 'Journal',
    SalesJournal: 'SalesJournal',
    PurchasesJournal: 'PurchasesJournal',
    CashDisbursementsJournal: 'CashDisbursementsJournal',
    CashReceiptsJournal: 'CashReceiptsJournal',
    ReturnsInwardsJournal: 'ReturnsInwardsJournal',
    ReturnsOutwardsJournal: 'ReturnsOutwardsJournal'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;


  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    invoice: number
    journal: number
    action: number
    transaction: number
    SalesJournal: number
    PurchasesJournal: number
    CashDisbursementsJournal: number
    CashReceiptsJournal: number
    ReturnsInwardsJournal: number
    ReturnsOutwardsJournal: number
  }

  export type UserCountOutputTypeSelect = {
    invoice?: boolean
    journal?: boolean
    action?: boolean
    transaction?: boolean
    SalesJournal?: boolean
    PurchasesJournal?: boolean
    CashDisbursementsJournal?: boolean
    CashReceiptsJournal?: boolean
    ReturnsInwardsJournal?: boolean
    ReturnsOutwardsJournal?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type TransactionCountOutputType
   */


  export type TransactionCountOutputType = {
    payments: number
    invoice: number
    journal: number
    SalesJournal: number
    PurchasesJournal: number
    CashDisbursementsJournal: number
    CashReceiptsJournal: number
    ReturnsInwardsJournal: number
    ReturnsOutwardsJournal: number
  }

  export type TransactionCountOutputTypeSelect = {
    payments?: boolean
    invoice?: boolean
    journal?: boolean
    SalesJournal?: boolean
    PurchasesJournal?: boolean
    CashDisbursementsJournal?: boolean
    CashReceiptsJournal?: boolean
    ReturnsInwardsJournal?: boolean
    ReturnsOutwardsJournal?: boolean
  }

  export type TransactionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TransactionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TransactionCountOutputType
    : S extends undefined
    ? never
    : S extends TransactionCountOutputTypeArgs
    ?'include' extends U
    ? TransactionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TransactionCountOutputType ? TransactionCountOutputType[P] : never
  } 
    : TransactionCountOutputType
  : TransactionCountOutputType




  // Custom InputTypes

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TransactionCountOutputType
     * 
    **/
    select?: TransactionCountOutputTypeSelect | null
  }



  /**
   * Count Type PaymentTypeCountOutputType
   */


  export type PaymentTypeCountOutputType = {
    payment: number
    tax: number
  }

  export type PaymentTypeCountOutputTypeSelect = {
    payment?: boolean
    tax?: boolean
  }

  export type PaymentTypeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PaymentTypeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PaymentTypeCountOutputType
    : S extends undefined
    ? never
    : S extends PaymentTypeCountOutputTypeArgs
    ?'include' extends U
    ? PaymentTypeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PaymentTypeCountOutputType ? PaymentTypeCountOutputType[P] : never
  } 
    : PaymentTypeCountOutputType
  : PaymentTypeCountOutputType




  // Custom InputTypes

  /**
   * PaymentTypeCountOutputType without action
   */
  export type PaymentTypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PaymentTypeCountOutputType
     * 
    **/
    select?: PaymentTypeCountOutputTypeSelect | null
  }



  /**
   * Count Type TaxCountOutputType
   */


  export type TaxCountOutputType = {
    PaymentType: number
    currency: number
    product: number
    invoice: number
    productGroup: number
  }

  export type TaxCountOutputTypeSelect = {
    PaymentType?: boolean
    currency?: boolean
    product?: boolean
    invoice?: boolean
    productGroup?: boolean
  }

  export type TaxCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TaxCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TaxCountOutputType
    : S extends undefined
    ? never
    : S extends TaxCountOutputTypeArgs
    ?'include' extends U
    ? TaxCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TaxCountOutputType ? TaxCountOutputType[P] : never
  } 
    : TaxCountOutputType
  : TaxCountOutputType




  // Custom InputTypes

  /**
   * TaxCountOutputType without action
   */
  export type TaxCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TaxCountOutputType
     * 
    **/
    select?: TaxCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductGroupCountOutputType
   */


  export type ProductGroupCountOutputType = {
    product: number
    Promotions: number
  }

  export type ProductGroupCountOutputTypeSelect = {
    product?: boolean
    Promotions?: boolean
  }

  export type ProductGroupCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductGroupCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductGroupCountOutputType
    : S extends undefined
    ? never
    : S extends ProductGroupCountOutputTypeArgs
    ?'include' extends U
    ? ProductGroupCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ProductGroupCountOutputType ? ProductGroupCountOutputType[P] : never
  } 
    : ProductGroupCountOutputType
  : ProductGroupCountOutputType




  // Custom InputTypes

  /**
   * ProductGroupCountOutputType without action
   */
  export type ProductGroupCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductGroupCountOutputType
     * 
    **/
    select?: ProductGroupCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductCountOutputType
   */


  export type ProductCountOutputType = {
    tax: number
    disposals: number
    price: number
    promotion: number
    invoice: number
  }

  export type ProductCountOutputTypeSelect = {
    tax?: boolean
    disposals?: boolean
    price?: boolean
    promotion?: boolean
    invoice?: boolean
  }

  export type ProductCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductCountOutputType
    : S extends undefined
    ? never
    : S extends ProductCountOutputTypeArgs
    ?'include' extends U
    ? ProductCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ProductCountOutputType ? ProductCountOutputType[P] : never
  } 
    : ProductCountOutputType
  : ProductCountOutputType




  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     * 
    **/
    select?: ProductCountOutputTypeSelect | null
  }



  /**
   * Count Type PricesCountOutputType
   */


  export type PricesCountOutputType = {
    disposals: number
  }

  export type PricesCountOutputTypeSelect = {
    disposals?: boolean
  }

  export type PricesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PricesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PricesCountOutputType
    : S extends undefined
    ? never
    : S extends PricesCountOutputTypeArgs
    ?'include' extends U
    ? PricesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PricesCountOutputType ? PricesCountOutputType[P] : never
  } 
    : PricesCountOutputType
  : PricesCountOutputType




  // Custom InputTypes

  /**
   * PricesCountOutputType without action
   */
  export type PricesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PricesCountOutputType
     * 
    **/
    select?: PricesCountOutputTypeSelect | null
  }



  /**
   * Count Type InvoiceCountOutputType
   */


  export type InvoiceCountOutputType = {
    tax: number
  }

  export type InvoiceCountOutputTypeSelect = {
    tax?: boolean
  }

  export type InvoiceCountOutputTypeGetPayload<
    S extends boolean | null | undefined | InvoiceCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? InvoiceCountOutputType
    : S extends undefined
    ? never
    : S extends InvoiceCountOutputTypeArgs
    ?'include' extends U
    ? InvoiceCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof InvoiceCountOutputType ? InvoiceCountOutputType[P] : never
  } 
    : InvoiceCountOutputType
  : InvoiceCountOutputType




  // Custom InputTypes

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     * 
    **/
    select?: InvoiceCountOutputTypeSelect | null
  }



  /**
   * Count Type SupplierCountOutputType
   */


  export type SupplierCountOutputType = {
    address: number
    product: number
    invoice: number
    transactions: number
    Journal: number
    SalesJournal: number
    CashDisbursementsJournal: number
    CashReceiptsJournal: number
    ReturnsOutwardsJournal: number
  }

  export type SupplierCountOutputTypeSelect = {
    address?: boolean
    product?: boolean
    invoice?: boolean
    transactions?: boolean
    Journal?: boolean
    SalesJournal?: boolean
    CashDisbursementsJournal?: boolean
    CashReceiptsJournal?: boolean
    ReturnsOutwardsJournal?: boolean
  }

  export type SupplierCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SupplierCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SupplierCountOutputType
    : S extends undefined
    ? never
    : S extends SupplierCountOutputTypeArgs
    ?'include' extends U
    ? SupplierCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SupplierCountOutputType ? SupplierCountOutputType[P] : never
  } 
    : SupplierCountOutputType
  : SupplierCountOutputType




  // Custom InputTypes

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     * 
    **/
    select?: SupplierCountOutputTypeSelect | null
  }



  /**
   * Count Type CustomerCountOutputType
   */


  export type CustomerCountOutputType = {
    address: number
    invoice: number
    transaction: number
    Journal: number
    PurchasesJournal: number
    CashDisbursementsJournal: number
    CashReceiptsJournal: number
    ReturnsInwardsJournal: number
  }

  export type CustomerCountOutputTypeSelect = {
    address?: boolean
    invoice?: boolean
    transaction?: boolean
    Journal?: boolean
    PurchasesJournal?: boolean
    CashDisbursementsJournal?: boolean
    CashReceiptsJournal?: boolean
    ReturnsInwardsJournal?: boolean
  }

  export type CustomerCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CustomerCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CustomerCountOutputType
    : S extends undefined
    ? never
    : S extends CustomerCountOutputTypeArgs
    ?'include' extends U
    ? CustomerCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CustomerCountOutputType ? CustomerCountOutputType[P] : never
  } 
    : CustomerCountOutputType
  : CustomerCountOutputType




  // Custom InputTypes

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     * 
    **/
    select?: CustomerCountOutputTypeSelect | null
  }



  /**
   * Count Type BaseCurrencyCountOutputType
   */


  export type BaseCurrencyCountOutputType = {
    exchangeRates: number
  }

  export type BaseCurrencyCountOutputTypeSelect = {
    exchangeRates?: boolean
  }

  export type BaseCurrencyCountOutputTypeGetPayload<
    S extends boolean | null | undefined | BaseCurrencyCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? BaseCurrencyCountOutputType
    : S extends undefined
    ? never
    : S extends BaseCurrencyCountOutputTypeArgs
    ?'include' extends U
    ? BaseCurrencyCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof BaseCurrencyCountOutputType ? BaseCurrencyCountOutputType[P] : never
  } 
    : BaseCurrencyCountOutputType
  : BaseCurrencyCountOutputType




  // Custom InputTypes

  /**
   * BaseCurrencyCountOutputType without action
   */
  export type BaseCurrencyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BaseCurrencyCountOutputType
     * 
    **/
    select?: BaseCurrencyCountOutputTypeSelect | null
  }



  /**
   * Count Type CurrencyCountOutputType
   */


  export type CurrencyCountOutputType = {
    baseCurrency: number
    exchangeRates: number
    payments: number
    tax: number
  }

  export type CurrencyCountOutputTypeSelect = {
    baseCurrency?: boolean
    exchangeRates?: boolean
    payments?: boolean
    tax?: boolean
  }

  export type CurrencyCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CurrencyCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CurrencyCountOutputType
    : S extends undefined
    ? never
    : S extends CurrencyCountOutputTypeArgs
    ?'include' extends U
    ? CurrencyCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CurrencyCountOutputType ? CurrencyCountOutputType[P] : never
  } 
    : CurrencyCountOutputType
  : CurrencyCountOutputType




  // Custom InputTypes

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CurrencyCountOutputType
     * 
    **/
    select?: CurrencyCountOutputTypeSelect | null
  }



  /**
   * Count Type ExchangeRatesCountOutputType
   */


  export type ExchangeRatesCountOutputType = {
    payments: number
    prices: number
  }

  export type ExchangeRatesCountOutputTypeSelect = {
    payments?: boolean
    prices?: boolean
  }

  export type ExchangeRatesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ExchangeRatesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ExchangeRatesCountOutputType
    : S extends undefined
    ? never
    : S extends ExchangeRatesCountOutputTypeArgs
    ?'include' extends U
    ? ExchangeRatesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ExchangeRatesCountOutputType ? ExchangeRatesCountOutputType[P] : never
  } 
    : ExchangeRatesCountOutputType
  : ExchangeRatesCountOutputType




  // Custom InputTypes

  /**
   * ExchangeRatesCountOutputType without action
   */
  export type ExchangeRatesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ExchangeRatesCountOutputType
     * 
    **/
    select?: ExchangeRatesCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    username: string | null
    password: string | null
    phoneNumber: string | null
    isAdmin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLogin: Date | null
    emailAddress: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    username: string | null
    password: string | null
    phoneNumber: string | null
    isAdmin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLogin: Date | null
    emailAddress: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    username: number
    password: number
    phoneNumber: number
    isAdmin: number
    createdAt: number
    updatedAt: number
    lastLogin: number
    emailAddress: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    username?: true
    password?: true
    phoneNumber?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
    emailAddress?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    username?: true
    password?: true
    phoneNumber?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
    emailAddress?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    username?: true
    password?: true
    phoneNumber?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
    emailAddress?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin: boolean
    createdAt: Date
    updatedAt: Date
    lastLogin: Date | null
    emailAddress: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    password?: boolean
    phoneNumber?: boolean
    isAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
    emailAddress?: boolean
    invoice?: boolean | invoiceFindManyArgs
    journal?: boolean | JournalFindManyArgs
    action?: boolean | ActionFindManyArgs
    transaction?: boolean | TransactionFindManyArgs
    SalesJournal?: boolean | SalesJournalFindManyArgs
    PurchasesJournal?: boolean | PurchasesJournalFindManyArgs
    CashDisbursementsJournal?: boolean | CashDisbursementsJournalFindManyArgs
    CashReceiptsJournal?: boolean | CashReceiptsJournalFindManyArgs
    ReturnsInwardsJournal?: boolean | ReturnsInwardsJournalFindManyArgs
    ReturnsOutwardsJournal?: boolean | ReturnsOutwardsJournalFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    invoice?: boolean | invoiceFindManyArgs
    journal?: boolean | JournalFindManyArgs
    action?: boolean | ActionFindManyArgs
    transaction?: boolean | TransactionFindManyArgs
    SalesJournal?: boolean | SalesJournalFindManyArgs
    PurchasesJournal?: boolean | PurchasesJournalFindManyArgs
    CashDisbursementsJournal?: boolean | CashDisbursementsJournalFindManyArgs
    CashReceiptsJournal?: boolean | CashReceiptsJournalFindManyArgs
    ReturnsInwardsJournal?: boolean | ReturnsInwardsJournalFindManyArgs
    ReturnsOutwardsJournal?: boolean | ReturnsOutwardsJournalFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'invoice' ? Array < invoiceGetPayload<S['include'][P]>>  :
        P extends 'journal' ? Array < JournalGetPayload<S['include'][P]>>  :
        P extends 'action' ? Array < ActionGetPayload<S['include'][P]>>  :
        P extends 'transaction' ? Array < TransactionGetPayload<S['include'][P]>>  :
        P extends 'SalesJournal' ? Array < SalesJournalGetPayload<S['include'][P]>>  :
        P extends 'PurchasesJournal' ? Array < PurchasesJournalGetPayload<S['include'][P]>>  :
        P extends 'CashDisbursementsJournal' ? Array < CashDisbursementsJournalGetPayload<S['include'][P]>>  :
        P extends 'CashReceiptsJournal' ? Array < CashReceiptsJournalGetPayload<S['include'][P]>>  :
        P extends 'ReturnsInwardsJournal' ? Array < ReturnsInwardsJournalGetPayload<S['include'][P]>>  :
        P extends 'ReturnsOutwardsJournal' ? Array < ReturnsOutwardsJournalGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'invoice' ? Array < invoiceGetPayload<S['select'][P]>>  :
        P extends 'journal' ? Array < JournalGetPayload<S['select'][P]>>  :
        P extends 'action' ? Array < ActionGetPayload<S['select'][P]>>  :
        P extends 'transaction' ? Array < TransactionGetPayload<S['select'][P]>>  :
        P extends 'SalesJournal' ? Array < SalesJournalGetPayload<S['select'][P]>>  :
        P extends 'PurchasesJournal' ? Array < PurchasesJournalGetPayload<S['select'][P]>>  :
        P extends 'CashDisbursementsJournal' ? Array < CashDisbursementsJournalGetPayload<S['select'][P]>>  :
        P extends 'CashReceiptsJournal' ? Array < CashReceiptsJournalGetPayload<S['select'][P]>>  :
        P extends 'ReturnsInwardsJournal' ? Array < ReturnsInwardsJournalGetPayload<S['select'][P]>>  :
        P extends 'ReturnsOutwardsJournal' ? Array < ReturnsOutwardsJournalGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find one User that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    invoice<T extends invoiceFindManyArgs = {}>(args?: Subset<T, invoiceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<invoice>>, PrismaPromise<Array<invoiceGetPayload<T>>>>;

    journal<T extends JournalFindManyArgs = {}>(args?: Subset<T, JournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Journal>>, PrismaPromise<Array<JournalGetPayload<T>>>>;

    action<T extends ActionFindManyArgs = {}>(args?: Subset<T, ActionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Action>>, PrismaPromise<Array<ActionGetPayload<T>>>>;

    transaction<T extends TransactionFindManyArgs = {}>(args?: Subset<T, TransactionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Transaction>>, PrismaPromise<Array<TransactionGetPayload<T>>>>;

    SalesJournal<T extends SalesJournalFindManyArgs = {}>(args?: Subset<T, SalesJournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SalesJournal>>, PrismaPromise<Array<SalesJournalGetPayload<T>>>>;

    PurchasesJournal<T extends PurchasesJournalFindManyArgs = {}>(args?: Subset<T, PurchasesJournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PurchasesJournal>>, PrismaPromise<Array<PurchasesJournalGetPayload<T>>>>;

    CashDisbursementsJournal<T extends CashDisbursementsJournalFindManyArgs = {}>(args?: Subset<T, CashDisbursementsJournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CashDisbursementsJournal>>, PrismaPromise<Array<CashDisbursementsJournalGetPayload<T>>>>;

    CashReceiptsJournal<T extends CashReceiptsJournalFindManyArgs = {}>(args?: Subset<T, CashReceiptsJournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CashReceiptsJournal>>, PrismaPromise<Array<CashReceiptsJournalGetPayload<T>>>>;

    ReturnsInwardsJournal<T extends ReturnsInwardsJournalFindManyArgs = {}>(args?: Subset<T, ReturnsInwardsJournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ReturnsInwardsJournal>>, PrismaPromise<Array<ReturnsInwardsJournalGetPayload<T>>>>;

    ReturnsOutwardsJournal<T extends ReturnsOutwardsJournalFindManyArgs = {}>(args?: Subset<T, ReturnsOutwardsJournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ReturnsOutwardsJournal>>, PrismaPromise<Array<ReturnsOutwardsJournalGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User: findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User: findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User: findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = UserFindUniqueArgsBase
      

  /**
   * User: findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = UserFindFirstArgsBase
      

  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model Action
   */


  export type AggregateAction = {
    _count: ActionCountAggregateOutputType | null
    _avg: ActionAvgAggregateOutputType | null
    _sum: ActionSumAggregateOutputType | null
    _min: ActionMinAggregateOutputType | null
    _max: ActionMaxAggregateOutputType | null
  }

  export type ActionAvgAggregateOutputType = {
    userId: number | null
  }

  export type ActionSumAggregateOutputType = {
    userId: number | null
  }

  export type ActionMinAggregateOutputType = {
    id: string | null
    userId: number | null
    actionType: boolean | null
    description: string | null
  }

  export type ActionMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    actionType: boolean | null
    description: string | null
  }

  export type ActionCountAggregateOutputType = {
    id: number
    userId: number
    actionType: number
    description: number
    _all: number
  }


  export type ActionAvgAggregateInputType = {
    userId?: true
  }

  export type ActionSumAggregateInputType = {
    userId?: true
  }

  export type ActionMinAggregateInputType = {
    id?: true
    userId?: true
    actionType?: true
    description?: true
  }

  export type ActionMaxAggregateInputType = {
    id?: true
    userId?: true
    actionType?: true
    description?: true
  }

  export type ActionCountAggregateInputType = {
    id?: true
    userId?: true
    actionType?: true
    description?: true
    _all?: true
  }

  export type ActionAggregateArgs = {
    /**
     * Filter which Action to aggregate.
     * 
    **/
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     * 
    **/
    orderBy?: Enumerable<ActionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Actions
    **/
    _count?: true | ActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionMaxAggregateInputType
  }

  export type GetActionAggregateType<T extends ActionAggregateArgs> = {
        [P in keyof T & keyof AggregateAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAction[P]>
      : GetScalarType<T[P], AggregateAction[P]>
  }




  export type ActionGroupByArgs = {
    where?: ActionWhereInput
    orderBy?: Enumerable<ActionOrderByWithAggregationInput>
    by: Array<ActionScalarFieldEnum>
    having?: ActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionCountAggregateInputType | true
    _avg?: ActionAvgAggregateInputType
    _sum?: ActionSumAggregateInputType
    _min?: ActionMinAggregateInputType
    _max?: ActionMaxAggregateInputType
  }


  export type ActionGroupByOutputType = {
    id: string
    userId: number
    actionType: boolean
    description: string
    _count: ActionCountAggregateOutputType | null
    _avg: ActionAvgAggregateOutputType | null
    _sum: ActionSumAggregateOutputType | null
    _min: ActionMinAggregateOutputType | null
    _max: ActionMaxAggregateOutputType | null
  }

  type GetActionGroupByPayload<T extends ActionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionGroupByOutputType[P]>
            : GetScalarType<T[P], ActionGroupByOutputType[P]>
        }
      >
    >


  export type ActionSelect = {
    id?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    actionType?: boolean
    description?: boolean
  }

  export type ActionInclude = {
    user?: boolean | UserArgs
  }

  export type ActionGetPayload<
    S extends boolean | null | undefined | ActionArgs,
    U = keyof S
      > = S extends true
        ? Action
    : S extends undefined
    ? never
    : S extends ActionArgs | ActionFindManyArgs
    ?'include' extends U
    ? Action  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Action ? Action[P] : never
  } 
    : Action
  : Action


  type ActionCountArgs = Merge<
    Omit<ActionFindManyArgs, 'select' | 'include'> & {
      select?: ActionCountAggregateInputType | true
    }
  >

  export interface ActionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Action that matches the filter.
     * @param {ActionFindUniqueArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ActionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ActionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Action'> extends True ? CheckSelect<T, Prisma__ActionClient<Action>, Prisma__ActionClient<ActionGetPayload<T>>> : CheckSelect<T, Prisma__ActionClient<Action | null >, Prisma__ActionClient<ActionGetPayload<T> | null >>

    /**
     * Find the first Action that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindFirstArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ActionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ActionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Action'> extends True ? CheckSelect<T, Prisma__ActionClient<Action>, Prisma__ActionClient<ActionGetPayload<T>>> : CheckSelect<T, Prisma__ActionClient<Action | null >, Prisma__ActionClient<ActionGetPayload<T> | null >>

    /**
     * Find zero or more Actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actions
     * const actions = await prisma.action.findMany()
     * 
     * // Get first 10 Actions
     * const actions = await prisma.action.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionWithIdOnly = await prisma.action.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ActionFindManyArgs>(
      args?: SelectSubset<T, ActionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Action>>, PrismaPromise<Array<ActionGetPayload<T>>>>

    /**
     * Create a Action.
     * @param {ActionCreateArgs} args - Arguments to create a Action.
     * @example
     * // Create one Action
     * const Action = await prisma.action.create({
     *   data: {
     *     // ... data to create a Action
     *   }
     * })
     * 
    **/
    create<T extends ActionCreateArgs>(
      args: SelectSubset<T, ActionCreateArgs>
    ): CheckSelect<T, Prisma__ActionClient<Action>, Prisma__ActionClient<ActionGetPayload<T>>>

    /**
     * Create many Actions.
     *     @param {ActionCreateManyArgs} args - Arguments to create many Actions.
     *     @example
     *     // Create many Actions
     *     const action = await prisma.action.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ActionCreateManyArgs>(
      args?: SelectSubset<T, ActionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Action.
     * @param {ActionDeleteArgs} args - Arguments to delete one Action.
     * @example
     * // Delete one Action
     * const Action = await prisma.action.delete({
     *   where: {
     *     // ... filter to delete one Action
     *   }
     * })
     * 
    **/
    delete<T extends ActionDeleteArgs>(
      args: SelectSubset<T, ActionDeleteArgs>
    ): CheckSelect<T, Prisma__ActionClient<Action>, Prisma__ActionClient<ActionGetPayload<T>>>

    /**
     * Update one Action.
     * @param {ActionUpdateArgs} args - Arguments to update one Action.
     * @example
     * // Update one Action
     * const action = await prisma.action.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ActionUpdateArgs>(
      args: SelectSubset<T, ActionUpdateArgs>
    ): CheckSelect<T, Prisma__ActionClient<Action>, Prisma__ActionClient<ActionGetPayload<T>>>

    /**
     * Delete zero or more Actions.
     * @param {ActionDeleteManyArgs} args - Arguments to filter Actions to delete.
     * @example
     * // Delete a few Actions
     * const { count } = await prisma.action.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ActionDeleteManyArgs>(
      args?: SelectSubset<T, ActionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actions
     * const action = await prisma.action.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ActionUpdateManyArgs>(
      args: SelectSubset<T, ActionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Action.
     * @param {ActionUpsertArgs} args - Arguments to update or create a Action.
     * @example
     * // Update or create a Action
     * const action = await prisma.action.upsert({
     *   create: {
     *     // ... data to create a Action
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Action we want to update
     *   }
     * })
    **/
    upsert<T extends ActionUpsertArgs>(
      args: SelectSubset<T, ActionUpsertArgs>
    ): CheckSelect<T, Prisma__ActionClient<Action>, Prisma__ActionClient<ActionGetPayload<T>>>

    /**
     * Find one Action that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ActionFindUniqueOrThrowArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ActionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ActionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ActionClient<Action>, Prisma__ActionClient<ActionGetPayload<T>>>

    /**
     * Find the first Action that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindFirstOrThrowArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ActionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ActionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ActionClient<Action>, Prisma__ActionClient<ActionGetPayload<T>>>

    /**
     * Count the number of Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionCountArgs} args - Arguments to filter Actions to count.
     * @example
     * // Count the number of Actions
     * const count = await prisma.action.count({
     *   where: {
     *     // ... the filter for the Actions we want to count
     *   }
     * })
    **/
    count<T extends ActionCountArgs>(
      args?: Subset<T, ActionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionAggregateArgs>(args: Subset<T, ActionAggregateArgs>): PrismaPromise<GetActionAggregateType<T>>

    /**
     * Group by Action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionGroupByArgs['orderBy'] }
        : { orderBy?: ActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Action.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ActionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Action base type for findUnique actions
   */
  export type ActionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Action
     * 
    **/
    select?: ActionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActionInclude | null
    /**
     * Filter, which Action to fetch.
     * 
    **/
    where: ActionWhereUniqueInput
  }

  /**
   * Action: findUnique
   */
  export interface ActionFindUniqueArgs extends ActionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Action base type for findFirst actions
   */
  export type ActionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Action
     * 
    **/
    select?: ActionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActionInclude | null
    /**
     * Filter, which Action to fetch.
     * 
    **/
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     * 
    **/
    orderBy?: Enumerable<ActionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actions.
     * 
    **/
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actions.
     * 
    **/
    distinct?: Enumerable<ActionScalarFieldEnum>
  }

  /**
   * Action: findFirst
   */
  export interface ActionFindFirstArgs extends ActionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Action findMany
   */
  export type ActionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Action
     * 
    **/
    select?: ActionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActionInclude | null
    /**
     * Filter, which Actions to fetch.
     * 
    **/
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     * 
    **/
    orderBy?: Enumerable<ActionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Actions.
     * 
    **/
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ActionScalarFieldEnum>
  }


  /**
   * Action create
   */
  export type ActionCreateArgs = {
    /**
     * Select specific fields to fetch from the Action
     * 
    **/
    select?: ActionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActionInclude | null
    /**
     * The data needed to create a Action.
     * 
    **/
    data: XOR<ActionCreateInput, ActionUncheckedCreateInput>
  }


  /**
   * Action createMany
   */
  export type ActionCreateManyArgs = {
    /**
     * The data used to create many Actions.
     * 
    **/
    data: Enumerable<ActionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Action update
   */
  export type ActionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Action
     * 
    **/
    select?: ActionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActionInclude | null
    /**
     * The data needed to update a Action.
     * 
    **/
    data: XOR<ActionUpdateInput, ActionUncheckedUpdateInput>
    /**
     * Choose, which Action to update.
     * 
    **/
    where: ActionWhereUniqueInput
  }


  /**
   * Action updateMany
   */
  export type ActionUpdateManyArgs = {
    /**
     * The data used to update Actions.
     * 
    **/
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyInput>
    /**
     * Filter which Actions to update
     * 
    **/
    where?: ActionWhereInput
  }


  /**
   * Action upsert
   */
  export type ActionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Action
     * 
    **/
    select?: ActionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActionInclude | null
    /**
     * The filter to search for the Action to update in case it exists.
     * 
    **/
    where: ActionWhereUniqueInput
    /**
     * In case the Action found by the `where` argument doesn't exist, create a new Action with this data.
     * 
    **/
    create: XOR<ActionCreateInput, ActionUncheckedCreateInput>
    /**
     * In case the Action was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ActionUpdateInput, ActionUncheckedUpdateInput>
  }


  /**
   * Action delete
   */
  export type ActionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Action
     * 
    **/
    select?: ActionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActionInclude | null
    /**
     * Filter which Action to delete.
     * 
    **/
    where: ActionWhereUniqueInput
  }


  /**
   * Action deleteMany
   */
  export type ActionDeleteManyArgs = {
    /**
     * Filter which Actions to delete
     * 
    **/
    where?: ActionWhereInput
  }


  /**
   * Action: findUniqueOrThrow
   */
  export type ActionFindUniqueOrThrowArgs = ActionFindUniqueArgsBase
      

  /**
   * Action: findFirstOrThrow
   */
  export type ActionFindFirstOrThrowArgs = ActionFindFirstArgsBase
      

  /**
   * Action without action
   */
  export type ActionArgs = {
    /**
     * Select specific fields to fetch from the Action
     * 
    **/
    select?: ActionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActionInclude | null
  }



  /**
   * Model Transaction
   */


  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    initiatedBy: number | null
    totalPaid: Decimal | null
    totalPayable: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    initiatedBy: number | null
    totalPaid: Decimal | null
    totalPayable: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    initiatedBy: number | null
    createdAt: Date | null
    totalPaid: Decimal | null
    totalPayable: Decimal | null
    supplierId: string | null
    errorDescription: string | null
    customerId: string | null
    type: TransactionType | null
    status: TransactionStatusCodes | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    initiatedBy: number | null
    createdAt: Date | null
    totalPaid: Decimal | null
    totalPayable: Decimal | null
    supplierId: string | null
    errorDescription: string | null
    customerId: string | null
    type: TransactionType | null
    status: TransactionStatusCodes | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    initiatedBy: number
    createdAt: number
    totalPaid: number
    totalPayable: number
    supplierId: number
    errorDescription: number
    customerId: number
    type: number
    status: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    initiatedBy?: true
    totalPaid?: true
    totalPayable?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    initiatedBy?: true
    totalPaid?: true
    totalPayable?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    initiatedBy?: true
    createdAt?: true
    totalPaid?: true
    totalPayable?: true
    supplierId?: true
    errorDescription?: true
    customerId?: true
    type?: true
    status?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    initiatedBy?: true
    createdAt?: true
    totalPaid?: true
    totalPayable?: true
    supplierId?: true
    errorDescription?: true
    customerId?: true
    type?: true
    status?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    initiatedBy?: true
    createdAt?: true
    totalPaid?: true
    totalPayable?: true
    supplierId?: true
    errorDescription?: true
    customerId?: true
    type?: true
    status?: true
    _all?: true
  }

  export type TransactionAggregateArgs = {
    /**
     * Filter which Transaction to aggregate.
     * 
    **/
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<TransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs = {
    where?: TransactionWhereInput
    orderBy?: Enumerable<TransactionOrderByWithAggregationInput>
    by: Array<TransactionScalarFieldEnum>
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }


  export type TransactionGroupByOutputType = {
    id: number
    initiatedBy: number
    createdAt: Date
    totalPaid: Decimal | null
    totalPayable: Decimal | null
    supplierId: string | null
    errorDescription: string | null
    customerId: string | null
    type: TransactionType
    status: TransactionStatusCodes
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect = {
    id?: boolean
    initiatedBy?: boolean
    createdAt?: boolean
    totalPaid?: boolean
    totalPayable?: boolean
    supplierId?: boolean
    errorDescription?: boolean
    customerId?: boolean
    type?: boolean
    status?: boolean
    users?: boolean | UserArgs
    customer?: boolean | CustomerArgs
    supplier?: boolean | SupplierArgs
    payments?: boolean | PaymentFindManyArgs
    invoice?: boolean | invoiceFindManyArgs
    journal?: boolean | JournalFindManyArgs
    SalesJournal?: boolean | SalesJournalFindManyArgs
    PurchasesJournal?: boolean | PurchasesJournalFindManyArgs
    CashDisbursementsJournal?: boolean | CashDisbursementsJournalFindManyArgs
    CashReceiptsJournal?: boolean | CashReceiptsJournalFindManyArgs
    ReturnsInwardsJournal?: boolean | ReturnsInwardsJournalFindManyArgs
    ReturnsOutwardsJournal?: boolean | ReturnsOutwardsJournalFindManyArgs
    _count?: boolean | TransactionCountOutputTypeArgs
  }

  export type TransactionInclude = {
    users?: boolean | UserArgs
    customer?: boolean | CustomerArgs
    supplier?: boolean | SupplierArgs
    payments?: boolean | PaymentFindManyArgs
    invoice?: boolean | invoiceFindManyArgs
    journal?: boolean | JournalFindManyArgs
    SalesJournal?: boolean | SalesJournalFindManyArgs
    PurchasesJournal?: boolean | PurchasesJournalFindManyArgs
    CashDisbursementsJournal?: boolean | CashDisbursementsJournalFindManyArgs
    CashReceiptsJournal?: boolean | CashReceiptsJournalFindManyArgs
    ReturnsInwardsJournal?: boolean | ReturnsInwardsJournalFindManyArgs
    ReturnsOutwardsJournal?: boolean | ReturnsOutwardsJournalFindManyArgs
    _count?: boolean | TransactionCountOutputTypeArgs
  }

  export type TransactionGetPayload<
    S extends boolean | null | undefined | TransactionArgs,
    U = keyof S
      > = S extends true
        ? Transaction
    : S extends undefined
    ? never
    : S extends TransactionArgs | TransactionFindManyArgs
    ?'include' extends U
    ? Transaction  & {
    [P in TrueKeys<S['include']>]:
        P extends 'users' ? UserGetPayload<S['include'][P]> :
        P extends 'customer' ? CustomerGetPayload<S['include'][P]> | null :
        P extends 'supplier' ? SupplierGetPayload<S['include'][P]> | null :
        P extends 'payments' ? Array < PaymentGetPayload<S['include'][P]>>  :
        P extends 'invoice' ? Array < invoiceGetPayload<S['include'][P]>>  :
        P extends 'journal' ? Array < JournalGetPayload<S['include'][P]>>  :
        P extends 'SalesJournal' ? Array < SalesJournalGetPayload<S['include'][P]>>  :
        P extends 'PurchasesJournal' ? Array < PurchasesJournalGetPayload<S['include'][P]>>  :
        P extends 'CashDisbursementsJournal' ? Array < CashDisbursementsJournalGetPayload<S['include'][P]>>  :
        P extends 'CashReceiptsJournal' ? Array < CashReceiptsJournalGetPayload<S['include'][P]>>  :
        P extends 'ReturnsInwardsJournal' ? Array < ReturnsInwardsJournalGetPayload<S['include'][P]>>  :
        P extends 'ReturnsOutwardsJournal' ? Array < ReturnsOutwardsJournalGetPayload<S['include'][P]>>  :
        P extends '_count' ? TransactionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'users' ? UserGetPayload<S['select'][P]> :
        P extends 'customer' ? CustomerGetPayload<S['select'][P]> | null :
        P extends 'supplier' ? SupplierGetPayload<S['select'][P]> | null :
        P extends 'payments' ? Array < PaymentGetPayload<S['select'][P]>>  :
        P extends 'invoice' ? Array < invoiceGetPayload<S['select'][P]>>  :
        P extends 'journal' ? Array < JournalGetPayload<S['select'][P]>>  :
        P extends 'SalesJournal' ? Array < SalesJournalGetPayload<S['select'][P]>>  :
        P extends 'PurchasesJournal' ? Array < PurchasesJournalGetPayload<S['select'][P]>>  :
        P extends 'CashDisbursementsJournal' ? Array < CashDisbursementsJournalGetPayload<S['select'][P]>>  :
        P extends 'CashReceiptsJournal' ? Array < CashReceiptsJournalGetPayload<S['select'][P]>>  :
        P extends 'ReturnsInwardsJournal' ? Array < ReturnsInwardsJournalGetPayload<S['select'][P]>>  :
        P extends 'ReturnsOutwardsJournal' ? Array < ReturnsOutwardsJournalGetPayload<S['select'][P]>>  :
        P extends '_count' ? TransactionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Transaction ? Transaction[P] : never
  } 
    : Transaction
  : Transaction


  type TransactionCountArgs = Merge<
    Omit<TransactionFindManyArgs, 'select' | 'include'> & {
      select?: TransactionCountAggregateInputType | true
    }
  >

  export interface TransactionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TransactionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TransactionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Transaction'> extends True ? CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>> : CheckSelect<T, Prisma__TransactionClient<Transaction | null >, Prisma__TransactionClient<TransactionGetPayload<T> | null >>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TransactionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TransactionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Transaction'> extends True ? CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>> : CheckSelect<T, Prisma__TransactionClient<Transaction | null >, Prisma__TransactionClient<TransactionGetPayload<T> | null >>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TransactionFindManyArgs>(
      args?: SelectSubset<T, TransactionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Transaction>>, PrismaPromise<Array<TransactionGetPayload<T>>>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
    **/
    create<T extends TransactionCreateArgs>(
      args: SelectSubset<T, TransactionCreateArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Create many Transactions.
     *     @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     *     @example
     *     // Create many Transactions
     *     const transaction = await prisma.transaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TransactionCreateManyArgs>(
      args?: SelectSubset<T, TransactionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
    **/
    delete<T extends TransactionDeleteArgs>(
      args: SelectSubset<T, TransactionDeleteArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TransactionUpdateArgs>(
      args: SelectSubset<T, TransactionUpdateArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TransactionDeleteManyArgs>(
      args?: SelectSubset<T, TransactionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TransactionUpdateManyArgs>(
      args: SelectSubset<T, TransactionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
    **/
    upsert<T extends TransactionUpsertArgs>(
      args: SelectSubset<T, TransactionUpsertArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Find one Transaction that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TransactionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Find the first Transaction that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TransactionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TransactionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    customer<T extends CustomerArgs = {}>(args?: Subset<T, CustomerArgs>): CheckSelect<T, Prisma__CustomerClient<Customer | null >, Prisma__CustomerClient<CustomerGetPayload<T> | null >>;

    supplier<T extends SupplierArgs = {}>(args?: Subset<T, SupplierArgs>): CheckSelect<T, Prisma__SupplierClient<Supplier | null >, Prisma__SupplierClient<SupplierGetPayload<T> | null >>;

    payments<T extends PaymentFindManyArgs = {}>(args?: Subset<T, PaymentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Payment>>, PrismaPromise<Array<PaymentGetPayload<T>>>>;

    invoice<T extends invoiceFindManyArgs = {}>(args?: Subset<T, invoiceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<invoice>>, PrismaPromise<Array<invoiceGetPayload<T>>>>;

    journal<T extends JournalFindManyArgs = {}>(args?: Subset<T, JournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Journal>>, PrismaPromise<Array<JournalGetPayload<T>>>>;

    SalesJournal<T extends SalesJournalFindManyArgs = {}>(args?: Subset<T, SalesJournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SalesJournal>>, PrismaPromise<Array<SalesJournalGetPayload<T>>>>;

    PurchasesJournal<T extends PurchasesJournalFindManyArgs = {}>(args?: Subset<T, PurchasesJournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PurchasesJournal>>, PrismaPromise<Array<PurchasesJournalGetPayload<T>>>>;

    CashDisbursementsJournal<T extends CashDisbursementsJournalFindManyArgs = {}>(args?: Subset<T, CashDisbursementsJournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CashDisbursementsJournal>>, PrismaPromise<Array<CashDisbursementsJournalGetPayload<T>>>>;

    CashReceiptsJournal<T extends CashReceiptsJournalFindManyArgs = {}>(args?: Subset<T, CashReceiptsJournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CashReceiptsJournal>>, PrismaPromise<Array<CashReceiptsJournalGetPayload<T>>>>;

    ReturnsInwardsJournal<T extends ReturnsInwardsJournalFindManyArgs = {}>(args?: Subset<T, ReturnsInwardsJournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ReturnsInwardsJournal>>, PrismaPromise<Array<ReturnsInwardsJournalGetPayload<T>>>>;

    ReturnsOutwardsJournal<T extends ReturnsOutwardsJournalFindManyArgs = {}>(args?: Subset<T, ReturnsOutwardsJournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ReturnsOutwardsJournal>>, PrismaPromise<Array<ReturnsOutwardsJournalGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Transaction base type for findUnique actions
   */
  export type TransactionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * Filter, which Transaction to fetch.
     * 
    **/
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction: findUnique
   */
  export interface TransactionFindUniqueArgs extends TransactionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Transaction base type for findFirst actions
   */
  export type TransactionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * Filter, which Transaction to fetch.
     * 
    **/
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<TransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     * 
    **/
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     * 
    **/
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }

  /**
   * Transaction: findFirst
   */
  export interface TransactionFindFirstArgs extends TransactionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * Filter, which Transactions to fetch.
     * 
    **/
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<TransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     * 
    **/
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * Transaction create
   */
  export type TransactionCreateArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * The data needed to create a Transaction.
     * 
    **/
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }


  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs = {
    /**
     * The data used to create many Transactions.
     * 
    **/
    data: Enumerable<TransactionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Transaction update
   */
  export type TransactionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * The data needed to update a Transaction.
     * 
    **/
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     * 
    **/
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs = {
    /**
     * The data used to update Transactions.
     * 
    **/
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     * 
    **/
    where?: TransactionWhereInput
  }


  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     * 
    **/
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     * 
    **/
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }


  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * Filter which Transaction to delete.
     * 
    **/
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs = {
    /**
     * Filter which Transactions to delete
     * 
    **/
    where?: TransactionWhereInput
  }


  /**
   * Transaction: findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs = TransactionFindUniqueArgsBase
      

  /**
   * Transaction: findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs = TransactionFindFirstArgsBase
      

  /**
   * Transaction without action
   */
  export type TransactionArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
  }



  /**
   * Model Payment
   */


  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    transactionId: number | null
    paid: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    transactionId: number | null
    paid: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    paymentTypeId: string | null
    currencyId: string | null
    exchangeRateId: string | null
    transactionId: number | null
    paid: Decimal | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    paymentTypeId: string | null
    currencyId: string | null
    exchangeRateId: string | null
    transactionId: number | null
    paid: Decimal | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    paymentTypeId: number
    currencyId: number
    exchangeRateId: number
    transactionId: number
    paid: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    transactionId?: true
    paid?: true
  }

  export type PaymentSumAggregateInputType = {
    transactionId?: true
    paid?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    paymentTypeId?: true
    currencyId?: true
    exchangeRateId?: true
    transactionId?: true
    paid?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    paymentTypeId?: true
    currencyId?: true
    exchangeRateId?: true
    transactionId?: true
    paid?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    paymentTypeId?: true
    currencyId?: true
    exchangeRateId?: true
    transactionId?: true
    paid?: true
    _all?: true
  }

  export type PaymentAggregateArgs = {
    /**
     * Filter which Payment to aggregate.
     * 
    **/
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs = {
    where?: PaymentWhereInput
    orderBy?: Enumerable<PaymentOrderByWithAggregationInput>
    by: Array<PaymentScalarFieldEnum>
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }


  export type PaymentGroupByOutputType = {
    id: string
    paymentTypeId: string
    currencyId: string
    exchangeRateId: string
    transactionId: number
    paid: Decimal
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect = {
    id?: boolean
    paymentType?: boolean | PaymentTypeArgs
    paymentTypeId?: boolean
    currencyId?: boolean
    exchangeRateId?: boolean
    transactionId?: boolean
    paid?: boolean
    currency?: boolean | currencyArgs
    exchangeRates?: boolean | exchangeRatesArgs
    transaction?: boolean | TransactionArgs
  }

  export type PaymentInclude = {
    paymentType?: boolean | PaymentTypeArgs
    currency?: boolean | currencyArgs
    exchangeRates?: boolean | exchangeRatesArgs
    transaction?: boolean | TransactionArgs
  }

  export type PaymentGetPayload<
    S extends boolean | null | undefined | PaymentArgs,
    U = keyof S
      > = S extends true
        ? Payment
    : S extends undefined
    ? never
    : S extends PaymentArgs | PaymentFindManyArgs
    ?'include' extends U
    ? Payment  & {
    [P in TrueKeys<S['include']>]:
        P extends 'paymentType' ? PaymentTypeGetPayload<S['include'][P]> :
        P extends 'currency' ? currencyGetPayload<S['include'][P]> :
        P extends 'exchangeRates' ? exchangeRatesGetPayload<S['include'][P]> :
        P extends 'transaction' ? TransactionGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'paymentType' ? PaymentTypeGetPayload<S['select'][P]> :
        P extends 'currency' ? currencyGetPayload<S['select'][P]> :
        P extends 'exchangeRates' ? exchangeRatesGetPayload<S['select'][P]> :
        P extends 'transaction' ? TransactionGetPayload<S['select'][P]> :  P extends keyof Payment ? Payment[P] : never
  } 
    : Payment
  : Payment


  type PaymentCountArgs = Merge<
    Omit<PaymentFindManyArgs, 'select' | 'include'> & {
      select?: PaymentCountAggregateInputType | true
    }
  >

  export interface PaymentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PaymentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Payment'> extends True ? CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>> : CheckSelect<T, Prisma__PaymentClient<Payment | null >, Prisma__PaymentClient<PaymentGetPayload<T> | null >>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PaymentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Payment'> extends True ? CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>> : CheckSelect<T, Prisma__PaymentClient<Payment | null >, Prisma__PaymentClient<PaymentGetPayload<T> | null >>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentFindManyArgs>(
      args?: SelectSubset<T, PaymentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Payment>>, PrismaPromise<Array<PaymentGetPayload<T>>>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
    **/
    create<T extends PaymentCreateArgs>(
      args: SelectSubset<T, PaymentCreateArgs>
    ): CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>>

    /**
     * Create many Payments.
     *     @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     *     @example
     *     // Create many Payments
     *     const payment = await prisma.payment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentCreateManyArgs>(
      args?: SelectSubset<T, PaymentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
    **/
    delete<T extends PaymentDeleteArgs>(
      args: SelectSubset<T, PaymentDeleteArgs>
    ): CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentUpdateArgs>(
      args: SelectSubset<T, PaymentUpdateArgs>
    ): CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentDeleteManyArgs>(
      args?: SelectSubset<T, PaymentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentUpdateManyArgs>(
      args: SelectSubset<T, PaymentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentUpsertArgs>(
      args: SelectSubset<T, PaymentUpsertArgs>
    ): CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>>

    /**
     * Find one Payment that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PaymentFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>>

    /**
     * Find the first Payment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PaymentFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>>

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PaymentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    paymentType<T extends PaymentTypeArgs = {}>(args?: Subset<T, PaymentTypeArgs>): CheckSelect<T, Prisma__PaymentTypeClient<PaymentType | null >, Prisma__PaymentTypeClient<PaymentTypeGetPayload<T> | null >>;

    currency<T extends currencyArgs = {}>(args?: Subset<T, currencyArgs>): CheckSelect<T, Prisma__currencyClient<currency | null >, Prisma__currencyClient<currencyGetPayload<T> | null >>;

    exchangeRates<T extends exchangeRatesArgs = {}>(args?: Subset<T, exchangeRatesArgs>): CheckSelect<T, Prisma__exchangeRatesClient<exchangeRates | null >, Prisma__exchangeRatesClient<exchangeRatesGetPayload<T> | null >>;

    transaction<T extends TransactionArgs = {}>(args?: Subset<T, TransactionArgs>): CheckSelect<T, Prisma__TransactionClient<Transaction | null >, Prisma__TransactionClient<TransactionGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Payment base type for findUnique actions
   */
  export type PaymentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentInclude | null
    /**
     * Filter, which Payment to fetch.
     * 
    **/
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment: findUnique
   */
  export interface PaymentFindUniqueArgs extends PaymentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Payment base type for findFirst actions
   */
  export type PaymentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentInclude | null
    /**
     * Filter, which Payment to fetch.
     * 
    **/
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     * 
    **/
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     * 
    **/
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }

  /**
   * Payment: findFirst
   */
  export interface PaymentFindFirstArgs extends PaymentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentInclude | null
    /**
     * Filter, which Payments to fetch.
     * 
    **/
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     * 
    **/
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * Payment create
   */
  export type PaymentCreateArgs = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentInclude | null
    /**
     * The data needed to create a Payment.
     * 
    **/
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }


  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs = {
    /**
     * The data used to create many Payments.
     * 
    **/
    data: Enumerable<PaymentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Payment update
   */
  export type PaymentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentInclude | null
    /**
     * The data needed to update a Payment.
     * 
    **/
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     * 
    **/
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs = {
    /**
     * The data used to update Payments.
     * 
    **/
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     * 
    **/
    where?: PaymentWhereInput
  }


  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentInclude | null
    /**
     * The filter to search for the Payment to update in case it exists.
     * 
    **/
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     * 
    **/
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }


  /**
   * Payment delete
   */
  export type PaymentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentInclude | null
    /**
     * Filter which Payment to delete.
     * 
    **/
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs = {
    /**
     * Filter which Payments to delete
     * 
    **/
    where?: PaymentWhereInput
  }


  /**
   * Payment: findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs = PaymentFindUniqueArgsBase
      

  /**
   * Payment: findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs = PaymentFindFirstArgsBase
      

  /**
   * Payment without action
   */
  export type PaymentArgs = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentInclude | null
  }



  /**
   * Model PaymentType
   */


  export type AggregatePaymentType = {
    _count: PaymentTypeCountAggregateOutputType | null
    _avg: PaymentTypeAvgAggregateOutputType | null
    _sum: PaymentTypeSumAggregateOutputType | null
    _min: PaymentTypeMinAggregateOutputType | null
    _max: PaymentTypeMaxAggregateOutputType | null
  }

  export type PaymentTypeAvgAggregateOutputType = {
    charges: Decimal | null
    discount: Decimal | null
  }

  export type PaymentTypeSumAggregateOutputType = {
    charges: Decimal | null
    discount: Decimal | null
  }

  export type PaymentTypeMinAggregateOutputType = {
    id: string | null
    paymentTypeName: string | null
    charges: Decimal | null
    discount: Decimal | null
  }

  export type PaymentTypeMaxAggregateOutputType = {
    id: string | null
    paymentTypeName: string | null
    charges: Decimal | null
    discount: Decimal | null
  }

  export type PaymentTypeCountAggregateOutputType = {
    id: number
    paymentTypeName: number
    charges: number
    discount: number
    _all: number
  }


  export type PaymentTypeAvgAggregateInputType = {
    charges?: true
    discount?: true
  }

  export type PaymentTypeSumAggregateInputType = {
    charges?: true
    discount?: true
  }

  export type PaymentTypeMinAggregateInputType = {
    id?: true
    paymentTypeName?: true
    charges?: true
    discount?: true
  }

  export type PaymentTypeMaxAggregateInputType = {
    id?: true
    paymentTypeName?: true
    charges?: true
    discount?: true
  }

  export type PaymentTypeCountAggregateInputType = {
    id?: true
    paymentTypeName?: true
    charges?: true
    discount?: true
    _all?: true
  }

  export type PaymentTypeAggregateArgs = {
    /**
     * Filter which PaymentType to aggregate.
     * 
    **/
    where?: PaymentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PaymentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentTypes
    **/
    _count?: true | PaymentTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentTypeMaxAggregateInputType
  }

  export type GetPaymentTypeAggregateType<T extends PaymentTypeAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentType[P]>
      : GetScalarType<T[P], AggregatePaymentType[P]>
  }




  export type PaymentTypeGroupByArgs = {
    where?: PaymentTypeWhereInput
    orderBy?: Enumerable<PaymentTypeOrderByWithAggregationInput>
    by: Array<PaymentTypeScalarFieldEnum>
    having?: PaymentTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentTypeCountAggregateInputType | true
    _avg?: PaymentTypeAvgAggregateInputType
    _sum?: PaymentTypeSumAggregateInputType
    _min?: PaymentTypeMinAggregateInputType
    _max?: PaymentTypeMaxAggregateInputType
  }


  export type PaymentTypeGroupByOutputType = {
    id: string
    paymentTypeName: string
    charges: Decimal
    discount: Decimal
    _count: PaymentTypeCountAggregateOutputType | null
    _avg: PaymentTypeAvgAggregateOutputType | null
    _sum: PaymentTypeSumAggregateOutputType | null
    _min: PaymentTypeMinAggregateOutputType | null
    _max: PaymentTypeMaxAggregateOutputType | null
  }

  type GetPaymentTypeGroupByPayload<T extends PaymentTypeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PaymentTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentTypeGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentTypeGroupByOutputType[P]>
        }
      >
    >


  export type PaymentTypeSelect = {
    id?: boolean
    paymentTypeName?: boolean
    payment?: boolean | PaymentFindManyArgs
    charges?: boolean
    tax?: boolean | TaxFindManyArgs
    discount?: boolean
    _count?: boolean | PaymentTypeCountOutputTypeArgs
  }

  export type PaymentTypeInclude = {
    payment?: boolean | PaymentFindManyArgs
    tax?: boolean | TaxFindManyArgs
    _count?: boolean | PaymentTypeCountOutputTypeArgs
  }

  export type PaymentTypeGetPayload<
    S extends boolean | null | undefined | PaymentTypeArgs,
    U = keyof S
      > = S extends true
        ? PaymentType
    : S extends undefined
    ? never
    : S extends PaymentTypeArgs | PaymentTypeFindManyArgs
    ?'include' extends U
    ? PaymentType  & {
    [P in TrueKeys<S['include']>]:
        P extends 'payment' ? Array < PaymentGetPayload<S['include'][P]>>  :
        P extends 'tax' ? Array < TaxGetPayload<S['include'][P]>>  :
        P extends '_count' ? PaymentTypeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'payment' ? Array < PaymentGetPayload<S['select'][P]>>  :
        P extends 'tax' ? Array < TaxGetPayload<S['select'][P]>>  :
        P extends '_count' ? PaymentTypeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PaymentType ? PaymentType[P] : never
  } 
    : PaymentType
  : PaymentType


  type PaymentTypeCountArgs = Merge<
    Omit<PaymentTypeFindManyArgs, 'select' | 'include'> & {
      select?: PaymentTypeCountAggregateInputType | true
    }
  >

  export interface PaymentTypeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PaymentType that matches the filter.
     * @param {PaymentTypeFindUniqueArgs} args - Arguments to find a PaymentType
     * @example
     * // Get one PaymentType
     * const paymentType = await prisma.paymentType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PaymentTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PaymentType'> extends True ? CheckSelect<T, Prisma__PaymentTypeClient<PaymentType>, Prisma__PaymentTypeClient<PaymentTypeGetPayload<T>>> : CheckSelect<T, Prisma__PaymentTypeClient<PaymentType | null >, Prisma__PaymentTypeClient<PaymentTypeGetPayload<T> | null >>

    /**
     * Find the first PaymentType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeFindFirstArgs} args - Arguments to find a PaymentType
     * @example
     * // Get one PaymentType
     * const paymentType = await prisma.paymentType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PaymentTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PaymentType'> extends True ? CheckSelect<T, Prisma__PaymentTypeClient<PaymentType>, Prisma__PaymentTypeClient<PaymentTypeGetPayload<T>>> : CheckSelect<T, Prisma__PaymentTypeClient<PaymentType | null >, Prisma__PaymentTypeClient<PaymentTypeGetPayload<T> | null >>

    /**
     * Find zero or more PaymentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentTypes
     * const paymentTypes = await prisma.paymentType.findMany()
     * 
     * // Get first 10 PaymentTypes
     * const paymentTypes = await prisma.paymentType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentTypeWithIdOnly = await prisma.paymentType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentTypeFindManyArgs>(
      args?: SelectSubset<T, PaymentTypeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PaymentType>>, PrismaPromise<Array<PaymentTypeGetPayload<T>>>>

    /**
     * Create a PaymentType.
     * @param {PaymentTypeCreateArgs} args - Arguments to create a PaymentType.
     * @example
     * // Create one PaymentType
     * const PaymentType = await prisma.paymentType.create({
     *   data: {
     *     // ... data to create a PaymentType
     *   }
     * })
     * 
    **/
    create<T extends PaymentTypeCreateArgs>(
      args: SelectSubset<T, PaymentTypeCreateArgs>
    ): CheckSelect<T, Prisma__PaymentTypeClient<PaymentType>, Prisma__PaymentTypeClient<PaymentTypeGetPayload<T>>>

    /**
     * Create many PaymentTypes.
     *     @param {PaymentTypeCreateManyArgs} args - Arguments to create many PaymentTypes.
     *     @example
     *     // Create many PaymentTypes
     *     const paymentType = await prisma.paymentType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentTypeCreateManyArgs>(
      args?: SelectSubset<T, PaymentTypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PaymentType.
     * @param {PaymentTypeDeleteArgs} args - Arguments to delete one PaymentType.
     * @example
     * // Delete one PaymentType
     * const PaymentType = await prisma.paymentType.delete({
     *   where: {
     *     // ... filter to delete one PaymentType
     *   }
     * })
     * 
    **/
    delete<T extends PaymentTypeDeleteArgs>(
      args: SelectSubset<T, PaymentTypeDeleteArgs>
    ): CheckSelect<T, Prisma__PaymentTypeClient<PaymentType>, Prisma__PaymentTypeClient<PaymentTypeGetPayload<T>>>

    /**
     * Update one PaymentType.
     * @param {PaymentTypeUpdateArgs} args - Arguments to update one PaymentType.
     * @example
     * // Update one PaymentType
     * const paymentType = await prisma.paymentType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentTypeUpdateArgs>(
      args: SelectSubset<T, PaymentTypeUpdateArgs>
    ): CheckSelect<T, Prisma__PaymentTypeClient<PaymentType>, Prisma__PaymentTypeClient<PaymentTypeGetPayload<T>>>

    /**
     * Delete zero or more PaymentTypes.
     * @param {PaymentTypeDeleteManyArgs} args - Arguments to filter PaymentTypes to delete.
     * @example
     * // Delete a few PaymentTypes
     * const { count } = await prisma.paymentType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentTypeDeleteManyArgs>(
      args?: SelectSubset<T, PaymentTypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentTypes
     * const paymentType = await prisma.paymentType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentTypeUpdateManyArgs>(
      args: SelectSubset<T, PaymentTypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentType.
     * @param {PaymentTypeUpsertArgs} args - Arguments to update or create a PaymentType.
     * @example
     * // Update or create a PaymentType
     * const paymentType = await prisma.paymentType.upsert({
     *   create: {
     *     // ... data to create a PaymentType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentType we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentTypeUpsertArgs>(
      args: SelectSubset<T, PaymentTypeUpsertArgs>
    ): CheckSelect<T, Prisma__PaymentTypeClient<PaymentType>, Prisma__PaymentTypeClient<PaymentTypeGetPayload<T>>>

    /**
     * Find one PaymentType that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PaymentTypeFindUniqueOrThrowArgs} args - Arguments to find a PaymentType
     * @example
     * // Get one PaymentType
     * const paymentType = await prisma.paymentType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PaymentTypeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PaymentTypeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PaymentTypeClient<PaymentType>, Prisma__PaymentTypeClient<PaymentTypeGetPayload<T>>>

    /**
     * Find the first PaymentType that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeFindFirstOrThrowArgs} args - Arguments to find a PaymentType
     * @example
     * // Get one PaymentType
     * const paymentType = await prisma.paymentType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PaymentTypeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PaymentTypeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PaymentTypeClient<PaymentType>, Prisma__PaymentTypeClient<PaymentTypeGetPayload<T>>>

    /**
     * Count the number of PaymentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeCountArgs} args - Arguments to filter PaymentTypes to count.
     * @example
     * // Count the number of PaymentTypes
     * const count = await prisma.paymentType.count({
     *   where: {
     *     // ... the filter for the PaymentTypes we want to count
     *   }
     * })
    **/
    count<T extends PaymentTypeCountArgs>(
      args?: Subset<T, PaymentTypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentTypeAggregateArgs>(args: Subset<T, PaymentTypeAggregateArgs>): PrismaPromise<GetPaymentTypeAggregateType<T>>

    /**
     * Group by PaymentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentTypeGroupByArgs['orderBy'] }
        : { orderBy?: PaymentTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentTypeGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PaymentTypeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    payment<T extends PaymentFindManyArgs = {}>(args?: Subset<T, PaymentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Payment>>, PrismaPromise<Array<PaymentGetPayload<T>>>>;

    tax<T extends TaxFindManyArgs = {}>(args?: Subset<T, TaxFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Tax>>, PrismaPromise<Array<TaxGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PaymentType base type for findUnique actions
   */
  export type PaymentTypeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PaymentType
     * 
    **/
    select?: PaymentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentTypeInclude | null
    /**
     * Filter, which PaymentType to fetch.
     * 
    **/
    where: PaymentTypeWhereUniqueInput
  }

  /**
   * PaymentType: findUnique
   */
  export interface PaymentTypeFindUniqueArgs extends PaymentTypeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PaymentType base type for findFirst actions
   */
  export type PaymentTypeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PaymentType
     * 
    **/
    select?: PaymentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentTypeInclude | null
    /**
     * Filter, which PaymentType to fetch.
     * 
    **/
    where?: PaymentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTypes.
     * 
    **/
    cursor?: PaymentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTypes.
     * 
    **/
    distinct?: Enumerable<PaymentTypeScalarFieldEnum>
  }

  /**
   * PaymentType: findFirst
   */
  export interface PaymentTypeFindFirstArgs extends PaymentTypeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PaymentType findMany
   */
  export type PaymentTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the PaymentType
     * 
    **/
    select?: PaymentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentTypeInclude | null
    /**
     * Filter, which PaymentTypes to fetch.
     * 
    **/
    where?: PaymentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentTypes.
     * 
    **/
    cursor?: PaymentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PaymentTypeScalarFieldEnum>
  }


  /**
   * PaymentType create
   */
  export type PaymentTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the PaymentType
     * 
    **/
    select?: PaymentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentTypeInclude | null
    /**
     * The data needed to create a PaymentType.
     * 
    **/
    data: XOR<PaymentTypeCreateInput, PaymentTypeUncheckedCreateInput>
  }


  /**
   * PaymentType createMany
   */
  export type PaymentTypeCreateManyArgs = {
    /**
     * The data used to create many PaymentTypes.
     * 
    **/
    data: Enumerable<PaymentTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PaymentType update
   */
  export type PaymentTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the PaymentType
     * 
    **/
    select?: PaymentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentTypeInclude | null
    /**
     * The data needed to update a PaymentType.
     * 
    **/
    data: XOR<PaymentTypeUpdateInput, PaymentTypeUncheckedUpdateInput>
    /**
     * Choose, which PaymentType to update.
     * 
    **/
    where: PaymentTypeWhereUniqueInput
  }


  /**
   * PaymentType updateMany
   */
  export type PaymentTypeUpdateManyArgs = {
    /**
     * The data used to update PaymentTypes.
     * 
    **/
    data: XOR<PaymentTypeUpdateManyMutationInput, PaymentTypeUncheckedUpdateManyInput>
    /**
     * Filter which PaymentTypes to update
     * 
    **/
    where?: PaymentTypeWhereInput
  }


  /**
   * PaymentType upsert
   */
  export type PaymentTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the PaymentType
     * 
    **/
    select?: PaymentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentTypeInclude | null
    /**
     * The filter to search for the PaymentType to update in case it exists.
     * 
    **/
    where: PaymentTypeWhereUniqueInput
    /**
     * In case the PaymentType found by the `where` argument doesn't exist, create a new PaymentType with this data.
     * 
    **/
    create: XOR<PaymentTypeCreateInput, PaymentTypeUncheckedCreateInput>
    /**
     * In case the PaymentType was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PaymentTypeUpdateInput, PaymentTypeUncheckedUpdateInput>
  }


  /**
   * PaymentType delete
   */
  export type PaymentTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the PaymentType
     * 
    **/
    select?: PaymentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentTypeInclude | null
    /**
     * Filter which PaymentType to delete.
     * 
    **/
    where: PaymentTypeWhereUniqueInput
  }


  /**
   * PaymentType deleteMany
   */
  export type PaymentTypeDeleteManyArgs = {
    /**
     * Filter which PaymentTypes to delete
     * 
    **/
    where?: PaymentTypeWhereInput
  }


  /**
   * PaymentType: findUniqueOrThrow
   */
  export type PaymentTypeFindUniqueOrThrowArgs = PaymentTypeFindUniqueArgsBase
      

  /**
   * PaymentType: findFirstOrThrow
   */
  export type PaymentTypeFindFirstOrThrowArgs = PaymentTypeFindFirstArgsBase
      

  /**
   * PaymentType without action
   */
  export type PaymentTypeArgs = {
    /**
     * Select specific fields to fetch from the PaymentType
     * 
    **/
    select?: PaymentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentTypeInclude | null
  }



  /**
   * Model Tax
   */


  export type AggregateTax = {
    _count: TaxCountAggregateOutputType | null
    _avg: TaxAvgAggregateOutputType | null
    _sum: TaxSumAggregateOutputType | null
    _min: TaxMinAggregateOutputType | null
    _max: TaxMaxAggregateOutputType | null
  }

  export type TaxAvgAggregateOutputType = {
    startAmount: Decimal | null
    endAmount: Decimal | null
  }

  export type TaxSumAggregateOutputType = {
    startAmount: Decimal | null
    endAmount: Decimal | null
  }

  export type TaxMinAggregateOutputType = {
    id: string | null
    taxName: string | null
    taxRate: string | null
    startAmount: Decimal | null
    endAmount: Decimal | null
    active: boolean | null
    startDate: Date | null
    endDate: Date | null
  }

  export type TaxMaxAggregateOutputType = {
    id: string | null
    taxName: string | null
    taxRate: string | null
    startAmount: Decimal | null
    endAmount: Decimal | null
    active: boolean | null
    startDate: Date | null
    endDate: Date | null
  }

  export type TaxCountAggregateOutputType = {
    id: number
    taxName: number
    taxRate: number
    startAmount: number
    endAmount: number
    active: number
    startDate: number
    endDate: number
    _all: number
  }


  export type TaxAvgAggregateInputType = {
    startAmount?: true
    endAmount?: true
  }

  export type TaxSumAggregateInputType = {
    startAmount?: true
    endAmount?: true
  }

  export type TaxMinAggregateInputType = {
    id?: true
    taxName?: true
    taxRate?: true
    startAmount?: true
    endAmount?: true
    active?: true
    startDate?: true
    endDate?: true
  }

  export type TaxMaxAggregateInputType = {
    id?: true
    taxName?: true
    taxRate?: true
    startAmount?: true
    endAmount?: true
    active?: true
    startDate?: true
    endDate?: true
  }

  export type TaxCountAggregateInputType = {
    id?: true
    taxName?: true
    taxRate?: true
    startAmount?: true
    endAmount?: true
    active?: true
    startDate?: true
    endDate?: true
    _all?: true
  }

  export type TaxAggregateArgs = {
    /**
     * Filter which Tax to aggregate.
     * 
    **/
    where?: TaxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Taxes to fetch.
     * 
    **/
    orderBy?: Enumerable<TaxOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TaxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Taxes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Taxes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Taxes
    **/
    _count?: true | TaxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxMaxAggregateInputType
  }

  export type GetTaxAggregateType<T extends TaxAggregateArgs> = {
        [P in keyof T & keyof AggregateTax]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTax[P]>
      : GetScalarType<T[P], AggregateTax[P]>
  }




  export type TaxGroupByArgs = {
    where?: TaxWhereInput
    orderBy?: Enumerable<TaxOrderByWithAggregationInput>
    by: Array<TaxScalarFieldEnum>
    having?: TaxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxCountAggregateInputType | true
    _avg?: TaxAvgAggregateInputType
    _sum?: TaxSumAggregateInputType
    _min?: TaxMinAggregateInputType
    _max?: TaxMaxAggregateInputType
  }


  export type TaxGroupByOutputType = {
    id: string
    taxName: string
    taxRate: string
    startAmount: Decimal
    endAmount: Decimal
    active: boolean
    startDate: Date
    endDate: Date
    _count: TaxCountAggregateOutputType | null
    _avg: TaxAvgAggregateOutputType | null
    _sum: TaxSumAggregateOutputType | null
    _min: TaxMinAggregateOutputType | null
    _max: TaxMaxAggregateOutputType | null
  }

  type GetTaxGroupByPayload<T extends TaxGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TaxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxGroupByOutputType[P]>
            : GetScalarType<T[P], TaxGroupByOutputType[P]>
        }
      >
    >


  export type TaxSelect = {
    id?: boolean
    taxName?: boolean
    taxRate?: boolean
    startAmount?: boolean
    endAmount?: boolean
    active?: boolean
    startDate?: boolean
    endDate?: boolean
    PaymentType?: boolean | PaymentTypeFindManyArgs
    currency?: boolean | currencyFindManyArgs
    product?: boolean | ProductFindManyArgs
    invoice?: boolean | invoiceFindManyArgs
    productGroup?: boolean | ProductGroupFindManyArgs
    _count?: boolean | TaxCountOutputTypeArgs
  }

  export type TaxInclude = {
    PaymentType?: boolean | PaymentTypeFindManyArgs
    currency?: boolean | currencyFindManyArgs
    product?: boolean | ProductFindManyArgs
    invoice?: boolean | invoiceFindManyArgs
    productGroup?: boolean | ProductGroupFindManyArgs
    _count?: boolean | TaxCountOutputTypeArgs
  }

  export type TaxGetPayload<
    S extends boolean | null | undefined | TaxArgs,
    U = keyof S
      > = S extends true
        ? Tax
    : S extends undefined
    ? never
    : S extends TaxArgs | TaxFindManyArgs
    ?'include' extends U
    ? Tax  & {
    [P in TrueKeys<S['include']>]:
        P extends 'PaymentType' ? Array < PaymentTypeGetPayload<S['include'][P]>>  :
        P extends 'currency' ? Array < currencyGetPayload<S['include'][P]>>  :
        P extends 'product' ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends 'invoice' ? Array < invoiceGetPayload<S['include'][P]>>  :
        P extends 'productGroup' ? Array < ProductGroupGetPayload<S['include'][P]>>  :
        P extends '_count' ? TaxCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'PaymentType' ? Array < PaymentTypeGetPayload<S['select'][P]>>  :
        P extends 'currency' ? Array < currencyGetPayload<S['select'][P]>>  :
        P extends 'product' ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends 'invoice' ? Array < invoiceGetPayload<S['select'][P]>>  :
        P extends 'productGroup' ? Array < ProductGroupGetPayload<S['select'][P]>>  :
        P extends '_count' ? TaxCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Tax ? Tax[P] : never
  } 
    : Tax
  : Tax


  type TaxCountArgs = Merge<
    Omit<TaxFindManyArgs, 'select' | 'include'> & {
      select?: TaxCountAggregateInputType | true
    }
  >

  export interface TaxDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Tax that matches the filter.
     * @param {TaxFindUniqueArgs} args - Arguments to find a Tax
     * @example
     * // Get one Tax
     * const tax = await prisma.tax.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TaxFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TaxFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tax'> extends True ? CheckSelect<T, Prisma__TaxClient<Tax>, Prisma__TaxClient<TaxGetPayload<T>>> : CheckSelect<T, Prisma__TaxClient<Tax | null >, Prisma__TaxClient<TaxGetPayload<T> | null >>

    /**
     * Find the first Tax that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxFindFirstArgs} args - Arguments to find a Tax
     * @example
     * // Get one Tax
     * const tax = await prisma.tax.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TaxFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TaxFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tax'> extends True ? CheckSelect<T, Prisma__TaxClient<Tax>, Prisma__TaxClient<TaxGetPayload<T>>> : CheckSelect<T, Prisma__TaxClient<Tax | null >, Prisma__TaxClient<TaxGetPayload<T> | null >>

    /**
     * Find zero or more Taxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Taxes
     * const taxes = await prisma.tax.findMany()
     * 
     * // Get first 10 Taxes
     * const taxes = await prisma.tax.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxWithIdOnly = await prisma.tax.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TaxFindManyArgs>(
      args?: SelectSubset<T, TaxFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Tax>>, PrismaPromise<Array<TaxGetPayload<T>>>>

    /**
     * Create a Tax.
     * @param {TaxCreateArgs} args - Arguments to create a Tax.
     * @example
     * // Create one Tax
     * const Tax = await prisma.tax.create({
     *   data: {
     *     // ... data to create a Tax
     *   }
     * })
     * 
    **/
    create<T extends TaxCreateArgs>(
      args: SelectSubset<T, TaxCreateArgs>
    ): CheckSelect<T, Prisma__TaxClient<Tax>, Prisma__TaxClient<TaxGetPayload<T>>>

    /**
     * Create many Taxes.
     *     @param {TaxCreateManyArgs} args - Arguments to create many Taxes.
     *     @example
     *     // Create many Taxes
     *     const tax = await prisma.tax.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TaxCreateManyArgs>(
      args?: SelectSubset<T, TaxCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Tax.
     * @param {TaxDeleteArgs} args - Arguments to delete one Tax.
     * @example
     * // Delete one Tax
     * const Tax = await prisma.tax.delete({
     *   where: {
     *     // ... filter to delete one Tax
     *   }
     * })
     * 
    **/
    delete<T extends TaxDeleteArgs>(
      args: SelectSubset<T, TaxDeleteArgs>
    ): CheckSelect<T, Prisma__TaxClient<Tax>, Prisma__TaxClient<TaxGetPayload<T>>>

    /**
     * Update one Tax.
     * @param {TaxUpdateArgs} args - Arguments to update one Tax.
     * @example
     * // Update one Tax
     * const tax = await prisma.tax.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TaxUpdateArgs>(
      args: SelectSubset<T, TaxUpdateArgs>
    ): CheckSelect<T, Prisma__TaxClient<Tax>, Prisma__TaxClient<TaxGetPayload<T>>>

    /**
     * Delete zero or more Taxes.
     * @param {TaxDeleteManyArgs} args - Arguments to filter Taxes to delete.
     * @example
     * // Delete a few Taxes
     * const { count } = await prisma.tax.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TaxDeleteManyArgs>(
      args?: SelectSubset<T, TaxDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Taxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Taxes
     * const tax = await prisma.tax.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TaxUpdateManyArgs>(
      args: SelectSubset<T, TaxUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Tax.
     * @param {TaxUpsertArgs} args - Arguments to update or create a Tax.
     * @example
     * // Update or create a Tax
     * const tax = await prisma.tax.upsert({
     *   create: {
     *     // ... data to create a Tax
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tax we want to update
     *   }
     * })
    **/
    upsert<T extends TaxUpsertArgs>(
      args: SelectSubset<T, TaxUpsertArgs>
    ): CheckSelect<T, Prisma__TaxClient<Tax>, Prisma__TaxClient<TaxGetPayload<T>>>

    /**
     * Find one Tax that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TaxFindUniqueOrThrowArgs} args - Arguments to find a Tax
     * @example
     * // Get one Tax
     * const tax = await prisma.tax.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TaxFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TaxFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TaxClient<Tax>, Prisma__TaxClient<TaxGetPayload<T>>>

    /**
     * Find the first Tax that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxFindFirstOrThrowArgs} args - Arguments to find a Tax
     * @example
     * // Get one Tax
     * const tax = await prisma.tax.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TaxFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TaxFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TaxClient<Tax>, Prisma__TaxClient<TaxGetPayload<T>>>

    /**
     * Count the number of Taxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCountArgs} args - Arguments to filter Taxes to count.
     * @example
     * // Count the number of Taxes
     * const count = await prisma.tax.count({
     *   where: {
     *     // ... the filter for the Taxes we want to count
     *   }
     * })
    **/
    count<T extends TaxCountArgs>(
      args?: Subset<T, TaxCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tax.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxAggregateArgs>(args: Subset<T, TaxAggregateArgs>): PrismaPromise<GetTaxAggregateType<T>>

    /**
     * Group by Tax.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxGroupByArgs['orderBy'] }
        : { orderBy?: TaxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tax.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TaxClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    PaymentType<T extends PaymentTypeFindManyArgs = {}>(args?: Subset<T, PaymentTypeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PaymentType>>, PrismaPromise<Array<PaymentTypeGetPayload<T>>>>;

    currency<T extends currencyFindManyArgs = {}>(args?: Subset<T, currencyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<currency>>, PrismaPromise<Array<currencyGetPayload<T>>>>;

    product<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    invoice<T extends invoiceFindManyArgs = {}>(args?: Subset<T, invoiceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<invoice>>, PrismaPromise<Array<invoiceGetPayload<T>>>>;

    productGroup<T extends ProductGroupFindManyArgs = {}>(args?: Subset<T, ProductGroupFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProductGroup>>, PrismaPromise<Array<ProductGroupGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Tax base type for findUnique actions
   */
  export type TaxFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Tax
     * 
    **/
    select?: TaxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaxInclude | null
    /**
     * Filter, which Tax to fetch.
     * 
    **/
    where: TaxWhereUniqueInput
  }

  /**
   * Tax: findUnique
   */
  export interface TaxFindUniqueArgs extends TaxFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tax base type for findFirst actions
   */
  export type TaxFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Tax
     * 
    **/
    select?: TaxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaxInclude | null
    /**
     * Filter, which Tax to fetch.
     * 
    **/
    where?: TaxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Taxes to fetch.
     * 
    **/
    orderBy?: Enumerable<TaxOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Taxes.
     * 
    **/
    cursor?: TaxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Taxes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Taxes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Taxes.
     * 
    **/
    distinct?: Enumerable<TaxScalarFieldEnum>
  }

  /**
   * Tax: findFirst
   */
  export interface TaxFindFirstArgs extends TaxFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tax findMany
   */
  export type TaxFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tax
     * 
    **/
    select?: TaxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaxInclude | null
    /**
     * Filter, which Taxes to fetch.
     * 
    **/
    where?: TaxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Taxes to fetch.
     * 
    **/
    orderBy?: Enumerable<TaxOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Taxes.
     * 
    **/
    cursor?: TaxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Taxes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Taxes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TaxScalarFieldEnum>
  }


  /**
   * Tax create
   */
  export type TaxCreateArgs = {
    /**
     * Select specific fields to fetch from the Tax
     * 
    **/
    select?: TaxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaxInclude | null
    /**
     * The data needed to create a Tax.
     * 
    **/
    data: XOR<TaxCreateInput, TaxUncheckedCreateInput>
  }


  /**
   * Tax createMany
   */
  export type TaxCreateManyArgs = {
    /**
     * The data used to create many Taxes.
     * 
    **/
    data: Enumerable<TaxCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Tax update
   */
  export type TaxUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tax
     * 
    **/
    select?: TaxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaxInclude | null
    /**
     * The data needed to update a Tax.
     * 
    **/
    data: XOR<TaxUpdateInput, TaxUncheckedUpdateInput>
    /**
     * Choose, which Tax to update.
     * 
    **/
    where: TaxWhereUniqueInput
  }


  /**
   * Tax updateMany
   */
  export type TaxUpdateManyArgs = {
    /**
     * The data used to update Taxes.
     * 
    **/
    data: XOR<TaxUpdateManyMutationInput, TaxUncheckedUpdateManyInput>
    /**
     * Filter which Taxes to update
     * 
    **/
    where?: TaxWhereInput
  }


  /**
   * Tax upsert
   */
  export type TaxUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tax
     * 
    **/
    select?: TaxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaxInclude | null
    /**
     * The filter to search for the Tax to update in case it exists.
     * 
    **/
    where: TaxWhereUniqueInput
    /**
     * In case the Tax found by the `where` argument doesn't exist, create a new Tax with this data.
     * 
    **/
    create: XOR<TaxCreateInput, TaxUncheckedCreateInput>
    /**
     * In case the Tax was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TaxUpdateInput, TaxUncheckedUpdateInput>
  }


  /**
   * Tax delete
   */
  export type TaxDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tax
     * 
    **/
    select?: TaxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaxInclude | null
    /**
     * Filter which Tax to delete.
     * 
    **/
    where: TaxWhereUniqueInput
  }


  /**
   * Tax deleteMany
   */
  export type TaxDeleteManyArgs = {
    /**
     * Filter which Taxes to delete
     * 
    **/
    where?: TaxWhereInput
  }


  /**
   * Tax: findUniqueOrThrow
   */
  export type TaxFindUniqueOrThrowArgs = TaxFindUniqueArgsBase
      

  /**
   * Tax: findFirstOrThrow
   */
  export type TaxFindFirstOrThrowArgs = TaxFindFirstArgsBase
      

  /**
   * Tax without action
   */
  export type TaxArgs = {
    /**
     * Select specific fields to fetch from the Tax
     * 
    **/
    select?: TaxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaxInclude | null
  }



  /**
   * Model Promotions
   */


  export type AggregatePromotions = {
    _count: PromotionsCountAggregateOutputType | null
    _avg: PromotionsAvgAggregateOutputType | null
    _sum: PromotionsSumAggregateOutputType | null
    _min: PromotionsMinAggregateOutputType | null
    _max: PromotionsMaxAggregateOutputType | null
  }

  export type PromotionsAvgAggregateOutputType = {
    discountRate: Decimal | null
  }

  export type PromotionsSumAggregateOutputType = {
    discountRate: Decimal | null
  }

  export type PromotionsMinAggregateOutputType = {
    id: string | null
    productId: string | null
    productGroupId: string | null
    startDate: Date | null
    endDate: Date | null
    discountRate: Decimal | null
  }

  export type PromotionsMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    productGroupId: string | null
    startDate: Date | null
    endDate: Date | null
    discountRate: Decimal | null
  }

  export type PromotionsCountAggregateOutputType = {
    id: number
    productId: number
    productGroupId: number
    startDate: number
    endDate: number
    discountRate: number
    _all: number
  }


  export type PromotionsAvgAggregateInputType = {
    discountRate?: true
  }

  export type PromotionsSumAggregateInputType = {
    discountRate?: true
  }

  export type PromotionsMinAggregateInputType = {
    id?: true
    productId?: true
    productGroupId?: true
    startDate?: true
    endDate?: true
    discountRate?: true
  }

  export type PromotionsMaxAggregateInputType = {
    id?: true
    productId?: true
    productGroupId?: true
    startDate?: true
    endDate?: true
    discountRate?: true
  }

  export type PromotionsCountAggregateInputType = {
    id?: true
    productId?: true
    productGroupId?: true
    startDate?: true
    endDate?: true
    discountRate?: true
    _all?: true
  }

  export type PromotionsAggregateArgs = {
    /**
     * Filter which Promotions to aggregate.
     * 
    **/
    where?: PromotionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     * 
    **/
    orderBy?: Enumerable<PromotionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PromotionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Promotions
    **/
    _count?: true | PromotionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionsMaxAggregateInputType
  }

  export type GetPromotionsAggregateType<T extends PromotionsAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotions[P]>
      : GetScalarType<T[P], AggregatePromotions[P]>
  }




  export type PromotionsGroupByArgs = {
    where?: PromotionsWhereInput
    orderBy?: Enumerable<PromotionsOrderByWithAggregationInput>
    by: Array<PromotionsScalarFieldEnum>
    having?: PromotionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionsCountAggregateInputType | true
    _avg?: PromotionsAvgAggregateInputType
    _sum?: PromotionsSumAggregateInputType
    _min?: PromotionsMinAggregateInputType
    _max?: PromotionsMaxAggregateInputType
  }


  export type PromotionsGroupByOutputType = {
    id: string
    productId: string
    productGroupId: string
    startDate: Date
    endDate: Date
    discountRate: Decimal
    _count: PromotionsCountAggregateOutputType | null
    _avg: PromotionsAvgAggregateOutputType | null
    _sum: PromotionsSumAggregateOutputType | null
    _min: PromotionsMinAggregateOutputType | null
    _max: PromotionsMaxAggregateOutputType | null
  }

  type GetPromotionsGroupByPayload<T extends PromotionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PromotionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionsGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionsGroupByOutputType[P]>
        }
      >
    >


  export type PromotionsSelect = {
    id?: boolean
    product?: boolean | ProductArgs
    productId?: boolean
    productGroup?: boolean | ProductGroupArgs
    productGroupId?: boolean
    startDate?: boolean
    endDate?: boolean
    discountRate?: boolean
  }

  export type PromotionsInclude = {
    product?: boolean | ProductArgs
    productGroup?: boolean | ProductGroupArgs
  }

  export type PromotionsGetPayload<
    S extends boolean | null | undefined | PromotionsArgs,
    U = keyof S
      > = S extends true
        ? Promotions
    : S extends undefined
    ? never
    : S extends PromotionsArgs | PromotionsFindManyArgs
    ?'include' extends U
    ? Promotions  & {
    [P in TrueKeys<S['include']>]:
        P extends 'product' ? ProductGetPayload<S['include'][P]> :
        P extends 'productGroup' ? ProductGroupGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'product' ? ProductGetPayload<S['select'][P]> :
        P extends 'productGroup' ? ProductGroupGetPayload<S['select'][P]> :  P extends keyof Promotions ? Promotions[P] : never
  } 
    : Promotions
  : Promotions


  type PromotionsCountArgs = Merge<
    Omit<PromotionsFindManyArgs, 'select' | 'include'> & {
      select?: PromotionsCountAggregateInputType | true
    }
  >

  export interface PromotionsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Promotions that matches the filter.
     * @param {PromotionsFindUniqueArgs} args - Arguments to find a Promotions
     * @example
     * // Get one Promotions
     * const promotions = await prisma.promotions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PromotionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PromotionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Promotions'> extends True ? CheckSelect<T, Prisma__PromotionsClient<Promotions>, Prisma__PromotionsClient<PromotionsGetPayload<T>>> : CheckSelect<T, Prisma__PromotionsClient<Promotions | null >, Prisma__PromotionsClient<PromotionsGetPayload<T> | null >>

    /**
     * Find the first Promotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionsFindFirstArgs} args - Arguments to find a Promotions
     * @example
     * // Get one Promotions
     * const promotions = await prisma.promotions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PromotionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PromotionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Promotions'> extends True ? CheckSelect<T, Prisma__PromotionsClient<Promotions>, Prisma__PromotionsClient<PromotionsGetPayload<T>>> : CheckSelect<T, Prisma__PromotionsClient<Promotions | null >, Prisma__PromotionsClient<PromotionsGetPayload<T> | null >>

    /**
     * Find zero or more Promotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promotions
     * const promotions = await prisma.promotions.findMany()
     * 
     * // Get first 10 Promotions
     * const promotions = await prisma.promotions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionsWithIdOnly = await prisma.promotions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PromotionsFindManyArgs>(
      args?: SelectSubset<T, PromotionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Promotions>>, PrismaPromise<Array<PromotionsGetPayload<T>>>>

    /**
     * Create a Promotions.
     * @param {PromotionsCreateArgs} args - Arguments to create a Promotions.
     * @example
     * // Create one Promotions
     * const Promotions = await prisma.promotions.create({
     *   data: {
     *     // ... data to create a Promotions
     *   }
     * })
     * 
    **/
    create<T extends PromotionsCreateArgs>(
      args: SelectSubset<T, PromotionsCreateArgs>
    ): CheckSelect<T, Prisma__PromotionsClient<Promotions>, Prisma__PromotionsClient<PromotionsGetPayload<T>>>

    /**
     * Create many Promotions.
     *     @param {PromotionsCreateManyArgs} args - Arguments to create many Promotions.
     *     @example
     *     // Create many Promotions
     *     const promotions = await prisma.promotions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PromotionsCreateManyArgs>(
      args?: SelectSubset<T, PromotionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Promotions.
     * @param {PromotionsDeleteArgs} args - Arguments to delete one Promotions.
     * @example
     * // Delete one Promotions
     * const Promotions = await prisma.promotions.delete({
     *   where: {
     *     // ... filter to delete one Promotions
     *   }
     * })
     * 
    **/
    delete<T extends PromotionsDeleteArgs>(
      args: SelectSubset<T, PromotionsDeleteArgs>
    ): CheckSelect<T, Prisma__PromotionsClient<Promotions>, Prisma__PromotionsClient<PromotionsGetPayload<T>>>

    /**
     * Update one Promotions.
     * @param {PromotionsUpdateArgs} args - Arguments to update one Promotions.
     * @example
     * // Update one Promotions
     * const promotions = await prisma.promotions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PromotionsUpdateArgs>(
      args: SelectSubset<T, PromotionsUpdateArgs>
    ): CheckSelect<T, Prisma__PromotionsClient<Promotions>, Prisma__PromotionsClient<PromotionsGetPayload<T>>>

    /**
     * Delete zero or more Promotions.
     * @param {PromotionsDeleteManyArgs} args - Arguments to filter Promotions to delete.
     * @example
     * // Delete a few Promotions
     * const { count } = await prisma.promotions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PromotionsDeleteManyArgs>(
      args?: SelectSubset<T, PromotionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promotions
     * const promotions = await prisma.promotions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PromotionsUpdateManyArgs>(
      args: SelectSubset<T, PromotionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Promotions.
     * @param {PromotionsUpsertArgs} args - Arguments to update or create a Promotions.
     * @example
     * // Update or create a Promotions
     * const promotions = await prisma.promotions.upsert({
     *   create: {
     *     // ... data to create a Promotions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promotions we want to update
     *   }
     * })
    **/
    upsert<T extends PromotionsUpsertArgs>(
      args: SelectSubset<T, PromotionsUpsertArgs>
    ): CheckSelect<T, Prisma__PromotionsClient<Promotions>, Prisma__PromotionsClient<PromotionsGetPayload<T>>>

    /**
     * Find one Promotions that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PromotionsFindUniqueOrThrowArgs} args - Arguments to find a Promotions
     * @example
     * // Get one Promotions
     * const promotions = await prisma.promotions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PromotionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PromotionsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PromotionsClient<Promotions>, Prisma__PromotionsClient<PromotionsGetPayload<T>>>

    /**
     * Find the first Promotions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionsFindFirstOrThrowArgs} args - Arguments to find a Promotions
     * @example
     * // Get one Promotions
     * const promotions = await prisma.promotions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PromotionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PromotionsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PromotionsClient<Promotions>, Prisma__PromotionsClient<PromotionsGetPayload<T>>>

    /**
     * Count the number of Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionsCountArgs} args - Arguments to filter Promotions to count.
     * @example
     * // Count the number of Promotions
     * const count = await prisma.promotions.count({
     *   where: {
     *     // ... the filter for the Promotions we want to count
     *   }
     * })
    **/
    count<T extends PromotionsCountArgs>(
      args?: Subset<T, PromotionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionsAggregateArgs>(args: Subset<T, PromotionsAggregateArgs>): PrismaPromise<GetPromotionsAggregateType<T>>

    /**
     * Group by Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionsGroupByArgs['orderBy'] }
        : { orderBy?: PromotionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Promotions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PromotionsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    productGroup<T extends ProductGroupArgs = {}>(args?: Subset<T, ProductGroupArgs>): CheckSelect<T, Prisma__ProductGroupClient<ProductGroup | null >, Prisma__ProductGroupClient<ProductGroupGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Promotions base type for findUnique actions
   */
  export type PromotionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Promotions
     * 
    **/
    select?: PromotionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PromotionsInclude | null
    /**
     * Filter, which Promotions to fetch.
     * 
    **/
    where: PromotionsWhereUniqueInput
  }

  /**
   * Promotions: findUnique
   */
  export interface PromotionsFindUniqueArgs extends PromotionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Promotions base type for findFirst actions
   */
  export type PromotionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Promotions
     * 
    **/
    select?: PromotionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PromotionsInclude | null
    /**
     * Filter, which Promotions to fetch.
     * 
    **/
    where?: PromotionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     * 
    **/
    orderBy?: Enumerable<PromotionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     * 
    **/
    cursor?: PromotionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     * 
    **/
    distinct?: Enumerable<PromotionsScalarFieldEnum>
  }

  /**
   * Promotions: findFirst
   */
  export interface PromotionsFindFirstArgs extends PromotionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Promotions findMany
   */
  export type PromotionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Promotions
     * 
    **/
    select?: PromotionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PromotionsInclude | null
    /**
     * Filter, which Promotions to fetch.
     * 
    **/
    where?: PromotionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     * 
    **/
    orderBy?: Enumerable<PromotionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Promotions.
     * 
    **/
    cursor?: PromotionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PromotionsScalarFieldEnum>
  }


  /**
   * Promotions create
   */
  export type PromotionsCreateArgs = {
    /**
     * Select specific fields to fetch from the Promotions
     * 
    **/
    select?: PromotionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PromotionsInclude | null
    /**
     * The data needed to create a Promotions.
     * 
    **/
    data: XOR<PromotionsCreateInput, PromotionsUncheckedCreateInput>
  }


  /**
   * Promotions createMany
   */
  export type PromotionsCreateManyArgs = {
    /**
     * The data used to create many Promotions.
     * 
    **/
    data: Enumerable<PromotionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Promotions update
   */
  export type PromotionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Promotions
     * 
    **/
    select?: PromotionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PromotionsInclude | null
    /**
     * The data needed to update a Promotions.
     * 
    **/
    data: XOR<PromotionsUpdateInput, PromotionsUncheckedUpdateInput>
    /**
     * Choose, which Promotions to update.
     * 
    **/
    where: PromotionsWhereUniqueInput
  }


  /**
   * Promotions updateMany
   */
  export type PromotionsUpdateManyArgs = {
    /**
     * The data used to update Promotions.
     * 
    **/
    data: XOR<PromotionsUpdateManyMutationInput, PromotionsUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     * 
    **/
    where?: PromotionsWhereInput
  }


  /**
   * Promotions upsert
   */
  export type PromotionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Promotions
     * 
    **/
    select?: PromotionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PromotionsInclude | null
    /**
     * The filter to search for the Promotions to update in case it exists.
     * 
    **/
    where: PromotionsWhereUniqueInput
    /**
     * In case the Promotions found by the `where` argument doesn't exist, create a new Promotions with this data.
     * 
    **/
    create: XOR<PromotionsCreateInput, PromotionsUncheckedCreateInput>
    /**
     * In case the Promotions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PromotionsUpdateInput, PromotionsUncheckedUpdateInput>
  }


  /**
   * Promotions delete
   */
  export type PromotionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Promotions
     * 
    **/
    select?: PromotionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PromotionsInclude | null
    /**
     * Filter which Promotions to delete.
     * 
    **/
    where: PromotionsWhereUniqueInput
  }


  /**
   * Promotions deleteMany
   */
  export type PromotionsDeleteManyArgs = {
    /**
     * Filter which Promotions to delete
     * 
    **/
    where?: PromotionsWhereInput
  }


  /**
   * Promotions: findUniqueOrThrow
   */
  export type PromotionsFindUniqueOrThrowArgs = PromotionsFindUniqueArgsBase
      

  /**
   * Promotions: findFirstOrThrow
   */
  export type PromotionsFindFirstOrThrowArgs = PromotionsFindFirstArgsBase
      

  /**
   * Promotions without action
   */
  export type PromotionsArgs = {
    /**
     * Select specific fields to fetch from the Promotions
     * 
    **/
    select?: PromotionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PromotionsInclude | null
  }



  /**
   * Model ProductGroup
   */


  export type AggregateProductGroup = {
    _count: ProductGroupCountAggregateOutputType | null
    _min: ProductGroupMinAggregateOutputType | null
    _max: ProductGroupMaxAggregateOutputType | null
  }

  export type ProductGroupMinAggregateOutputType = {
    id: string | null
    taxId: string | null
  }

  export type ProductGroupMaxAggregateOutputType = {
    id: string | null
    taxId: string | null
  }

  export type ProductGroupCountAggregateOutputType = {
    id: number
    taxId: number
    _all: number
  }


  export type ProductGroupMinAggregateInputType = {
    id?: true
    taxId?: true
  }

  export type ProductGroupMaxAggregateInputType = {
    id?: true
    taxId?: true
  }

  export type ProductGroupCountAggregateInputType = {
    id?: true
    taxId?: true
    _all?: true
  }

  export type ProductGroupAggregateArgs = {
    /**
     * Filter which ProductGroup to aggregate.
     * 
    **/
    where?: ProductGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductGroups
    **/
    _count?: true | ProductGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductGroupMaxAggregateInputType
  }

  export type GetProductGroupAggregateType<T extends ProductGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateProductGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductGroup[P]>
      : GetScalarType<T[P], AggregateProductGroup[P]>
  }




  export type ProductGroupGroupByArgs = {
    where?: ProductGroupWhereInput
    orderBy?: Enumerable<ProductGroupOrderByWithAggregationInput>
    by: Array<ProductGroupScalarFieldEnum>
    having?: ProductGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductGroupCountAggregateInputType | true
    _min?: ProductGroupMinAggregateInputType
    _max?: ProductGroupMaxAggregateInputType
  }


  export type ProductGroupGroupByOutputType = {
    id: string
    taxId: string | null
    _count: ProductGroupCountAggregateOutputType | null
    _min: ProductGroupMinAggregateOutputType | null
    _max: ProductGroupMaxAggregateOutputType | null
  }

  type GetProductGroupGroupByPayload<T extends ProductGroupGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupGroupByOutputType[P]>
        }
      >
    >


  export type ProductGroupSelect = {
    id?: boolean
    product?: boolean | ProductFindManyArgs
    Tax?: boolean | TaxArgs
    taxId?: boolean
    Promotions?: boolean | PromotionsFindManyArgs
    _count?: boolean | ProductGroupCountOutputTypeArgs
  }

  export type ProductGroupInclude = {
    product?: boolean | ProductFindManyArgs
    Tax?: boolean | TaxArgs
    Promotions?: boolean | PromotionsFindManyArgs
    _count?: boolean | ProductGroupCountOutputTypeArgs
  }

  export type ProductGroupGetPayload<
    S extends boolean | null | undefined | ProductGroupArgs,
    U = keyof S
      > = S extends true
        ? ProductGroup
    : S extends undefined
    ? never
    : S extends ProductGroupArgs | ProductGroupFindManyArgs
    ?'include' extends U
    ? ProductGroup  & {
    [P in TrueKeys<S['include']>]:
        P extends 'product' ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends 'Tax' ? TaxGetPayload<S['include'][P]> | null :
        P extends 'Promotions' ? Array < PromotionsGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProductGroupCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'product' ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends 'Tax' ? TaxGetPayload<S['select'][P]> | null :
        P extends 'Promotions' ? Array < PromotionsGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProductGroupCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ProductGroup ? ProductGroup[P] : never
  } 
    : ProductGroup
  : ProductGroup


  type ProductGroupCountArgs = Merge<
    Omit<ProductGroupFindManyArgs, 'select' | 'include'> & {
      select?: ProductGroupCountAggregateInputType | true
    }
  >

  export interface ProductGroupDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProductGroup that matches the filter.
     * @param {ProductGroupFindUniqueArgs} args - Arguments to find a ProductGroup
     * @example
     * // Get one ProductGroup
     * const productGroup = await prisma.productGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductGroupFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductGroupFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductGroup'> extends True ? CheckSelect<T, Prisma__ProductGroupClient<ProductGroup>, Prisma__ProductGroupClient<ProductGroupGetPayload<T>>> : CheckSelect<T, Prisma__ProductGroupClient<ProductGroup | null >, Prisma__ProductGroupClient<ProductGroupGetPayload<T> | null >>

    /**
     * Find the first ProductGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupFindFirstArgs} args - Arguments to find a ProductGroup
     * @example
     * // Get one ProductGroup
     * const productGroup = await prisma.productGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductGroupFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductGroupFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductGroup'> extends True ? CheckSelect<T, Prisma__ProductGroupClient<ProductGroup>, Prisma__ProductGroupClient<ProductGroupGetPayload<T>>> : CheckSelect<T, Prisma__ProductGroupClient<ProductGroup | null >, Prisma__ProductGroupClient<ProductGroupGetPayload<T> | null >>

    /**
     * Find zero or more ProductGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductGroups
     * const productGroups = await prisma.productGroup.findMany()
     * 
     * // Get first 10 ProductGroups
     * const productGroups = await prisma.productGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productGroupWithIdOnly = await prisma.productGroup.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductGroupFindManyArgs>(
      args?: SelectSubset<T, ProductGroupFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProductGroup>>, PrismaPromise<Array<ProductGroupGetPayload<T>>>>

    /**
     * Create a ProductGroup.
     * @param {ProductGroupCreateArgs} args - Arguments to create a ProductGroup.
     * @example
     * // Create one ProductGroup
     * const ProductGroup = await prisma.productGroup.create({
     *   data: {
     *     // ... data to create a ProductGroup
     *   }
     * })
     * 
    **/
    create<T extends ProductGroupCreateArgs>(
      args: SelectSubset<T, ProductGroupCreateArgs>
    ): CheckSelect<T, Prisma__ProductGroupClient<ProductGroup>, Prisma__ProductGroupClient<ProductGroupGetPayload<T>>>

    /**
     * Create many ProductGroups.
     *     @param {ProductGroupCreateManyArgs} args - Arguments to create many ProductGroups.
     *     @example
     *     // Create many ProductGroups
     *     const productGroup = await prisma.productGroup.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductGroupCreateManyArgs>(
      args?: SelectSubset<T, ProductGroupCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductGroup.
     * @param {ProductGroupDeleteArgs} args - Arguments to delete one ProductGroup.
     * @example
     * // Delete one ProductGroup
     * const ProductGroup = await prisma.productGroup.delete({
     *   where: {
     *     // ... filter to delete one ProductGroup
     *   }
     * })
     * 
    **/
    delete<T extends ProductGroupDeleteArgs>(
      args: SelectSubset<T, ProductGroupDeleteArgs>
    ): CheckSelect<T, Prisma__ProductGroupClient<ProductGroup>, Prisma__ProductGroupClient<ProductGroupGetPayload<T>>>

    /**
     * Update one ProductGroup.
     * @param {ProductGroupUpdateArgs} args - Arguments to update one ProductGroup.
     * @example
     * // Update one ProductGroup
     * const productGroup = await prisma.productGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductGroupUpdateArgs>(
      args: SelectSubset<T, ProductGroupUpdateArgs>
    ): CheckSelect<T, Prisma__ProductGroupClient<ProductGroup>, Prisma__ProductGroupClient<ProductGroupGetPayload<T>>>

    /**
     * Delete zero or more ProductGroups.
     * @param {ProductGroupDeleteManyArgs} args - Arguments to filter ProductGroups to delete.
     * @example
     * // Delete a few ProductGroups
     * const { count } = await prisma.productGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductGroupDeleteManyArgs>(
      args?: SelectSubset<T, ProductGroupDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductGroups
     * const productGroup = await prisma.productGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductGroupUpdateManyArgs>(
      args: SelectSubset<T, ProductGroupUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductGroup.
     * @param {ProductGroupUpsertArgs} args - Arguments to update or create a ProductGroup.
     * @example
     * // Update or create a ProductGroup
     * const productGroup = await prisma.productGroup.upsert({
     *   create: {
     *     // ... data to create a ProductGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductGroup we want to update
     *   }
     * })
    **/
    upsert<T extends ProductGroupUpsertArgs>(
      args: SelectSubset<T, ProductGroupUpsertArgs>
    ): CheckSelect<T, Prisma__ProductGroupClient<ProductGroup>, Prisma__ProductGroupClient<ProductGroupGetPayload<T>>>

    /**
     * Find one ProductGroup that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ProductGroupFindUniqueOrThrowArgs} args - Arguments to find a ProductGroup
     * @example
     * // Get one ProductGroup
     * const productGroup = await prisma.productGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductGroupFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductGroupFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ProductGroupClient<ProductGroup>, Prisma__ProductGroupClient<ProductGroupGetPayload<T>>>

    /**
     * Find the first ProductGroup that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupFindFirstOrThrowArgs} args - Arguments to find a ProductGroup
     * @example
     * // Get one ProductGroup
     * const productGroup = await prisma.productGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductGroupFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductGroupFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ProductGroupClient<ProductGroup>, Prisma__ProductGroupClient<ProductGroupGetPayload<T>>>

    /**
     * Count the number of ProductGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupCountArgs} args - Arguments to filter ProductGroups to count.
     * @example
     * // Count the number of ProductGroups
     * const count = await prisma.productGroup.count({
     *   where: {
     *     // ... the filter for the ProductGroups we want to count
     *   }
     * })
    **/
    count<T extends ProductGroupCountArgs>(
      args?: Subset<T, ProductGroupCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductGroupAggregateArgs>(args: Subset<T, ProductGroupAggregateArgs>): PrismaPromise<GetProductGroupAggregateType<T>>

    /**
     * Group by ProductGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductGroupClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    Tax<T extends TaxArgs = {}>(args?: Subset<T, TaxArgs>): CheckSelect<T, Prisma__TaxClient<Tax | null >, Prisma__TaxClient<TaxGetPayload<T> | null >>;

    Promotions<T extends PromotionsFindManyArgs = {}>(args?: Subset<T, PromotionsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Promotions>>, PrismaPromise<Array<PromotionsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProductGroup base type for findUnique actions
   */
  export type ProductGroupFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProductGroup
     * 
    **/
    select?: ProductGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductGroupInclude | null
    /**
     * Filter, which ProductGroup to fetch.
     * 
    **/
    where: ProductGroupWhereUniqueInput
  }

  /**
   * ProductGroup: findUnique
   */
  export interface ProductGroupFindUniqueArgs extends ProductGroupFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductGroup base type for findFirst actions
   */
  export type ProductGroupFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProductGroup
     * 
    **/
    select?: ProductGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductGroupInclude | null
    /**
     * Filter, which ProductGroup to fetch.
     * 
    **/
    where?: ProductGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductGroups.
     * 
    **/
    cursor?: ProductGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductGroups.
     * 
    **/
    distinct?: Enumerable<ProductGroupScalarFieldEnum>
  }

  /**
   * ProductGroup: findFirst
   */
  export interface ProductGroupFindFirstArgs extends ProductGroupFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductGroup findMany
   */
  export type ProductGroupFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductGroup
     * 
    **/
    select?: ProductGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductGroupInclude | null
    /**
     * Filter, which ProductGroups to fetch.
     * 
    **/
    where?: ProductGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductGroups.
     * 
    **/
    cursor?: ProductGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductGroups.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductGroupScalarFieldEnum>
  }


  /**
   * ProductGroup create
   */
  export type ProductGroupCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductGroup
     * 
    **/
    select?: ProductGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductGroupInclude | null
    /**
     * The data needed to create a ProductGroup.
     * 
    **/
    data: XOR<ProductGroupCreateInput, ProductGroupUncheckedCreateInput>
  }


  /**
   * ProductGroup createMany
   */
  export type ProductGroupCreateManyArgs = {
    /**
     * The data used to create many ProductGroups.
     * 
    **/
    data: Enumerable<ProductGroupCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductGroup update
   */
  export type ProductGroupUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductGroup
     * 
    **/
    select?: ProductGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductGroupInclude | null
    /**
     * The data needed to update a ProductGroup.
     * 
    **/
    data: XOR<ProductGroupUpdateInput, ProductGroupUncheckedUpdateInput>
    /**
     * Choose, which ProductGroup to update.
     * 
    **/
    where: ProductGroupWhereUniqueInput
  }


  /**
   * ProductGroup updateMany
   */
  export type ProductGroupUpdateManyArgs = {
    /**
     * The data used to update ProductGroups.
     * 
    **/
    data: XOR<ProductGroupUpdateManyMutationInput, ProductGroupUncheckedUpdateManyInput>
    /**
     * Filter which ProductGroups to update
     * 
    **/
    where?: ProductGroupWhereInput
  }


  /**
   * ProductGroup upsert
   */
  export type ProductGroupUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductGroup
     * 
    **/
    select?: ProductGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductGroupInclude | null
    /**
     * The filter to search for the ProductGroup to update in case it exists.
     * 
    **/
    where: ProductGroupWhereUniqueInput
    /**
     * In case the ProductGroup found by the `where` argument doesn't exist, create a new ProductGroup with this data.
     * 
    **/
    create: XOR<ProductGroupCreateInput, ProductGroupUncheckedCreateInput>
    /**
     * In case the ProductGroup was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductGroupUpdateInput, ProductGroupUncheckedUpdateInput>
  }


  /**
   * ProductGroup delete
   */
  export type ProductGroupDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductGroup
     * 
    **/
    select?: ProductGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductGroupInclude | null
    /**
     * Filter which ProductGroup to delete.
     * 
    **/
    where: ProductGroupWhereUniqueInput
  }


  /**
   * ProductGroup deleteMany
   */
  export type ProductGroupDeleteManyArgs = {
    /**
     * Filter which ProductGroups to delete
     * 
    **/
    where?: ProductGroupWhereInput
  }


  /**
   * ProductGroup: findUniqueOrThrow
   */
  export type ProductGroupFindUniqueOrThrowArgs = ProductGroupFindUniqueArgsBase
      

  /**
   * ProductGroup: findFirstOrThrow
   */
  export type ProductGroupFindFirstOrThrowArgs = ProductGroupFindFirstArgsBase
      

  /**
   * ProductGroup without action
   */
  export type ProductGroupArgs = {
    /**
     * Select specific fields to fetch from the ProductGroup
     * 
    **/
    select?: ProductGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductGroupInclude | null
  }



  /**
   * Model Product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    measurementAmount: number | null
    cost: Decimal | null
    quantity: number | null
  }

  export type ProductSumAggregateOutputType = {
    measurementAmount: number | null
    cost: Decimal | null
    quantity: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    barcode: string | null
    productName: string | null
    measurementUnit: MeasurementUnit | null
    expiryDate: Date | null
    measurementAmount: number | null
    cost: Decimal | null
    quantity: number | null
    supplierId: string | null
    productGroupId: string | null
    updatedAt: Date | null
    createdAt: Date | null
    depleted: boolean | null
    disposed: boolean | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    barcode: string | null
    productName: string | null
    measurementUnit: MeasurementUnit | null
    expiryDate: Date | null
    measurementAmount: number | null
    cost: Decimal | null
    quantity: number | null
    supplierId: string | null
    productGroupId: string | null
    updatedAt: Date | null
    createdAt: Date | null
    depleted: boolean | null
    disposed: boolean | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    barcode: number
    productName: number
    measurementUnit: number
    expiryDate: number
    measurementAmount: number
    cost: number
    quantity: number
    supplierId: number
    productGroupId: number
    updatedAt: number
    createdAt: number
    depleted: number
    disposed: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    measurementAmount?: true
    cost?: true
    quantity?: true
  }

  export type ProductSumAggregateInputType = {
    measurementAmount?: true
    cost?: true
    quantity?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    barcode?: true
    productName?: true
    measurementUnit?: true
    expiryDate?: true
    measurementAmount?: true
    cost?: true
    quantity?: true
    supplierId?: true
    productGroupId?: true
    updatedAt?: true
    createdAt?: true
    depleted?: true
    disposed?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    barcode?: true
    productName?: true
    measurementUnit?: true
    expiryDate?: true
    measurementAmount?: true
    cost?: true
    quantity?: true
    supplierId?: true
    productGroupId?: true
    updatedAt?: true
    createdAt?: true
    depleted?: true
    disposed?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    barcode?: true
    productName?: true
    measurementUnit?: true
    expiryDate?: true
    measurementAmount?: true
    cost?: true
    quantity?: true
    supplierId?: true
    productGroupId?: true
    updatedAt?: true
    createdAt?: true
    depleted?: true
    disposed?: true
    _all?: true
  }

  export type ProductAggregateArgs = {
    /**
     * Filter which Product to aggregate.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs = {
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithAggregationInput>
    by: Array<ProductScalarFieldEnum>
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: string
    barcode: string
    productName: string
    measurementUnit: MeasurementUnit
    expiryDate: Date
    measurementAmount: number
    cost: Decimal
    quantity: number
    supplierId: string | null
    productGroupId: string | null
    updatedAt: Date
    createdAt: Date
    depleted: boolean
    disposed: boolean
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect = {
    id?: boolean
    barcode?: boolean
    productName?: boolean
    measurementUnit?: boolean
    expiryDate?: boolean
    measurementAmount?: boolean
    cost?: boolean
    quantity?: boolean
    supplierId?: boolean
    tax?: boolean | TaxFindManyArgs
    productGroup?: boolean | ProductGroupArgs
    productGroupId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    depleted?: boolean
    disposed?: boolean
    supplier?: boolean | SupplierArgs
    disposals?: boolean | disposalsFindManyArgs
    price?: boolean | PricesFindManyArgs
    promotion?: boolean | PromotionsFindManyArgs
    invoice?: boolean | invoiceFindManyArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type ProductInclude = {
    tax?: boolean | TaxFindManyArgs
    productGroup?: boolean | ProductGroupArgs
    supplier?: boolean | SupplierArgs
    disposals?: boolean | disposalsFindManyArgs
    price?: boolean | PricesFindManyArgs
    promotion?: boolean | PromotionsFindManyArgs
    invoice?: boolean | invoiceFindManyArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type ProductGetPayload<
    S extends boolean | null | undefined | ProductArgs,
    U = keyof S
      > = S extends true
        ? Product
    : S extends undefined
    ? never
    : S extends ProductArgs | ProductFindManyArgs
    ?'include' extends U
    ? Product  & {
    [P in TrueKeys<S['include']>]:
        P extends 'tax' ? Array < TaxGetPayload<S['include'][P]>>  :
        P extends 'productGroup' ? ProductGroupGetPayload<S['include'][P]> | null :
        P extends 'supplier' ? SupplierGetPayload<S['include'][P]> | null :
        P extends 'disposals' ? Array < disposalsGetPayload<S['include'][P]>>  :
        P extends 'price' ? Array < PricesGetPayload<S['include'][P]>>  :
        P extends 'promotion' ? Array < PromotionsGetPayload<S['include'][P]>>  :
        P extends 'invoice' ? Array < invoiceGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'tax' ? Array < TaxGetPayload<S['select'][P]>>  :
        P extends 'productGroup' ? ProductGroupGetPayload<S['select'][P]> | null :
        P extends 'supplier' ? SupplierGetPayload<S['select'][P]> | null :
        P extends 'disposals' ? Array < disposalsGetPayload<S['select'][P]>>  :
        P extends 'price' ? Array < PricesGetPayload<S['select'][P]>>  :
        P extends 'promotion' ? Array < PromotionsGetPayload<S['select'][P]>>  :
        P extends 'invoice' ? Array < invoiceGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Product ? Product[P] : never
  } 
    : Product
  : Product


  type ProductCountArgs = Merge<
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }
  >

  export interface ProductDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs>(
      args?: SelectSubset<T, ProductFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs>(
      args: SelectSubset<T, ProductCreateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs>(
      args?: SelectSubset<T, ProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs>(
      args: SelectSubset<T, ProductDeleteArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs>(
      args: SelectSubset<T, ProductUpdateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs>(
      args: SelectSubset<T, ProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs>(
      args: SelectSubset<T, ProductUpsertArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Find one Product that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Find the first Product that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    tax<T extends TaxFindManyArgs = {}>(args?: Subset<T, TaxFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Tax>>, PrismaPromise<Array<TaxGetPayload<T>>>>;

    productGroup<T extends ProductGroupArgs = {}>(args?: Subset<T, ProductGroupArgs>): CheckSelect<T, Prisma__ProductGroupClient<ProductGroup | null >, Prisma__ProductGroupClient<ProductGroupGetPayload<T> | null >>;

    supplier<T extends SupplierArgs = {}>(args?: Subset<T, SupplierArgs>): CheckSelect<T, Prisma__SupplierClient<Supplier | null >, Prisma__SupplierClient<SupplierGetPayload<T> | null >>;

    disposals<T extends disposalsFindManyArgs = {}>(args?: Subset<T, disposalsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<disposals>>, PrismaPromise<Array<disposalsGetPayload<T>>>>;

    price<T extends PricesFindManyArgs = {}>(args?: Subset<T, PricesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Prices>>, PrismaPromise<Array<PricesGetPayload<T>>>>;

    promotion<T extends PromotionsFindManyArgs = {}>(args?: Subset<T, PromotionsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Promotions>>, PrismaPromise<Array<PromotionsGetPayload<T>>>>;

    invoice<T extends invoiceFindManyArgs = {}>(args?: Subset<T, invoiceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<invoice>>, PrismaPromise<Array<invoiceGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Product base type for findUnique actions
   */
  export type ProductFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where: ProductWhereUniqueInput
  }

  /**
   * Product: findUnique
   */
  export interface ProductFindUniqueArgs extends ProductFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product base type for findFirst actions
   */
  export type ProductFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     * 
    **/
    distinct?: Enumerable<ProductScalarFieldEnum>
  }

  /**
   * Product: findFirst
   */
  export interface ProductFindFirstArgs extends ProductFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product findMany
   */
  export type ProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Products to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product create
   */
  export type ProductCreateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to create a Product.
     * 
    **/
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs = {
    /**
     * The data used to create many Products.
     * 
    **/
    data: Enumerable<ProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to update a Product.
     * 
    **/
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs = {
    /**
     * The data used to update Products.
     * 
    **/
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     * 
    **/
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The filter to search for the Product to update in case it exists.
     * 
    **/
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     * 
    **/
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter which Product to delete.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs = {
    /**
     * Filter which Products to delete
     * 
    **/
    where?: ProductWhereInput
  }


  /**
   * Product: findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs = ProductFindUniqueArgsBase
      

  /**
   * Product: findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs = ProductFindFirstArgsBase
      

  /**
   * Product without action
   */
  export type ProductArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
  }



  /**
   * Model Prices
   */


  export type AggregatePrices = {
    _count: PricesCountAggregateOutputType | null
    _avg: PricesAvgAggregateOutputType | null
    _sum: PricesSumAggregateOutputType | null
    _min: PricesMinAggregateOutputType | null
    _max: PricesMaxAggregateOutputType | null
  }

  export type PricesAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type PricesSumAggregateOutputType = {
    price: Decimal | null
  }

  export type PricesMinAggregateOutputType = {
    id: string | null
    barcode: string | null
    price: Decimal | null
    active: boolean | null
    exchangeRateId: string | null
    productId: string | null
  }

  export type PricesMaxAggregateOutputType = {
    id: string | null
    barcode: string | null
    price: Decimal | null
    active: boolean | null
    exchangeRateId: string | null
    productId: string | null
  }

  export type PricesCountAggregateOutputType = {
    id: number
    barcode: number
    price: number
    active: number
    exchangeRateId: number
    productId: number
    _all: number
  }


  export type PricesAvgAggregateInputType = {
    price?: true
  }

  export type PricesSumAggregateInputType = {
    price?: true
  }

  export type PricesMinAggregateInputType = {
    id?: true
    barcode?: true
    price?: true
    active?: true
    exchangeRateId?: true
    productId?: true
  }

  export type PricesMaxAggregateInputType = {
    id?: true
    barcode?: true
    price?: true
    active?: true
    exchangeRateId?: true
    productId?: true
  }

  export type PricesCountAggregateInputType = {
    id?: true
    barcode?: true
    price?: true
    active?: true
    exchangeRateId?: true
    productId?: true
    _all?: true
  }

  export type PricesAggregateArgs = {
    /**
     * Filter which Prices to aggregate.
     * 
    **/
    where?: PricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     * 
    **/
    orderBy?: Enumerable<PricesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prices
    **/
    _count?: true | PricesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PricesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PricesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PricesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PricesMaxAggregateInputType
  }

  export type GetPricesAggregateType<T extends PricesAggregateArgs> = {
        [P in keyof T & keyof AggregatePrices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrices[P]>
      : GetScalarType<T[P], AggregatePrices[P]>
  }




  export type PricesGroupByArgs = {
    where?: PricesWhereInput
    orderBy?: Enumerable<PricesOrderByWithAggregationInput>
    by: Array<PricesScalarFieldEnum>
    having?: PricesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PricesCountAggregateInputType | true
    _avg?: PricesAvgAggregateInputType
    _sum?: PricesSumAggregateInputType
    _min?: PricesMinAggregateInputType
    _max?: PricesMaxAggregateInputType
  }


  export type PricesGroupByOutputType = {
    id: string
    barcode: string
    price: Decimal
    active: boolean
    exchangeRateId: string
    productId: string | null
    _count: PricesCountAggregateOutputType | null
    _avg: PricesAvgAggregateOutputType | null
    _sum: PricesSumAggregateOutputType | null
    _min: PricesMinAggregateOutputType | null
    _max: PricesMaxAggregateOutputType | null
  }

  type GetPricesGroupByPayload<T extends PricesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PricesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PricesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PricesGroupByOutputType[P]>
            : GetScalarType<T[P], PricesGroupByOutputType[P]>
        }
      >
    >


  export type PricesSelect = {
    id?: boolean
    barcode?: boolean
    price?: boolean
    active?: boolean
    exchangeRateId?: boolean
    productId?: boolean
    exchangeRates?: boolean | exchangeRatesArgs
    Product?: boolean | ProductArgs
    disposals?: boolean | disposalsFindManyArgs
    _count?: boolean | PricesCountOutputTypeArgs
  }

  export type PricesInclude = {
    exchangeRates?: boolean | exchangeRatesArgs
    Product?: boolean | ProductArgs
    disposals?: boolean | disposalsFindManyArgs
    _count?: boolean | PricesCountOutputTypeArgs
  }

  export type PricesGetPayload<
    S extends boolean | null | undefined | PricesArgs,
    U = keyof S
      > = S extends true
        ? Prices
    : S extends undefined
    ? never
    : S extends PricesArgs | PricesFindManyArgs
    ?'include' extends U
    ? Prices  & {
    [P in TrueKeys<S['include']>]:
        P extends 'exchangeRates' ? exchangeRatesGetPayload<S['include'][P]> :
        P extends 'Product' ? ProductGetPayload<S['include'][P]> | null :
        P extends 'disposals' ? Array < disposalsGetPayload<S['include'][P]>>  :
        P extends '_count' ? PricesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'exchangeRates' ? exchangeRatesGetPayload<S['select'][P]> :
        P extends 'Product' ? ProductGetPayload<S['select'][P]> | null :
        P extends 'disposals' ? Array < disposalsGetPayload<S['select'][P]>>  :
        P extends '_count' ? PricesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Prices ? Prices[P] : never
  } 
    : Prices
  : Prices


  type PricesCountArgs = Merge<
    Omit<PricesFindManyArgs, 'select' | 'include'> & {
      select?: PricesCountAggregateInputType | true
    }
  >

  export interface PricesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Prices that matches the filter.
     * @param {PricesFindUniqueArgs} args - Arguments to find a Prices
     * @example
     * // Get one Prices
     * const prices = await prisma.prices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PricesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PricesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Prices'> extends True ? CheckSelect<T, Prisma__PricesClient<Prices>, Prisma__PricesClient<PricesGetPayload<T>>> : CheckSelect<T, Prisma__PricesClient<Prices | null >, Prisma__PricesClient<PricesGetPayload<T> | null >>

    /**
     * Find the first Prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesFindFirstArgs} args - Arguments to find a Prices
     * @example
     * // Get one Prices
     * const prices = await prisma.prices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PricesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PricesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Prices'> extends True ? CheckSelect<T, Prisma__PricesClient<Prices>, Prisma__PricesClient<PricesGetPayload<T>>> : CheckSelect<T, Prisma__PricesClient<Prices | null >, Prisma__PricesClient<PricesGetPayload<T> | null >>

    /**
     * Find zero or more Prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prices
     * const prices = await prisma.prices.findMany()
     * 
     * // Get first 10 Prices
     * const prices = await prisma.prices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pricesWithIdOnly = await prisma.prices.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PricesFindManyArgs>(
      args?: SelectSubset<T, PricesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Prices>>, PrismaPromise<Array<PricesGetPayload<T>>>>

    /**
     * Create a Prices.
     * @param {PricesCreateArgs} args - Arguments to create a Prices.
     * @example
     * // Create one Prices
     * const Prices = await prisma.prices.create({
     *   data: {
     *     // ... data to create a Prices
     *   }
     * })
     * 
    **/
    create<T extends PricesCreateArgs>(
      args: SelectSubset<T, PricesCreateArgs>
    ): CheckSelect<T, Prisma__PricesClient<Prices>, Prisma__PricesClient<PricesGetPayload<T>>>

    /**
     * Create many Prices.
     *     @param {PricesCreateManyArgs} args - Arguments to create many Prices.
     *     @example
     *     // Create many Prices
     *     const prices = await prisma.prices.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PricesCreateManyArgs>(
      args?: SelectSubset<T, PricesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Prices.
     * @param {PricesDeleteArgs} args - Arguments to delete one Prices.
     * @example
     * // Delete one Prices
     * const Prices = await prisma.prices.delete({
     *   where: {
     *     // ... filter to delete one Prices
     *   }
     * })
     * 
    **/
    delete<T extends PricesDeleteArgs>(
      args: SelectSubset<T, PricesDeleteArgs>
    ): CheckSelect<T, Prisma__PricesClient<Prices>, Prisma__PricesClient<PricesGetPayload<T>>>

    /**
     * Update one Prices.
     * @param {PricesUpdateArgs} args - Arguments to update one Prices.
     * @example
     * // Update one Prices
     * const prices = await prisma.prices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PricesUpdateArgs>(
      args: SelectSubset<T, PricesUpdateArgs>
    ): CheckSelect<T, Prisma__PricesClient<Prices>, Prisma__PricesClient<PricesGetPayload<T>>>

    /**
     * Delete zero or more Prices.
     * @param {PricesDeleteManyArgs} args - Arguments to filter Prices to delete.
     * @example
     * // Delete a few Prices
     * const { count } = await prisma.prices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PricesDeleteManyArgs>(
      args?: SelectSubset<T, PricesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prices
     * const prices = await prisma.prices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PricesUpdateManyArgs>(
      args: SelectSubset<T, PricesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Prices.
     * @param {PricesUpsertArgs} args - Arguments to update or create a Prices.
     * @example
     * // Update or create a Prices
     * const prices = await prisma.prices.upsert({
     *   create: {
     *     // ... data to create a Prices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prices we want to update
     *   }
     * })
    **/
    upsert<T extends PricesUpsertArgs>(
      args: SelectSubset<T, PricesUpsertArgs>
    ): CheckSelect<T, Prisma__PricesClient<Prices>, Prisma__PricesClient<PricesGetPayload<T>>>

    /**
     * Find one Prices that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PricesFindUniqueOrThrowArgs} args - Arguments to find a Prices
     * @example
     * // Get one Prices
     * const prices = await prisma.prices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PricesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PricesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PricesClient<Prices>, Prisma__PricesClient<PricesGetPayload<T>>>

    /**
     * Find the first Prices that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesFindFirstOrThrowArgs} args - Arguments to find a Prices
     * @example
     * // Get one Prices
     * const prices = await prisma.prices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PricesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PricesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PricesClient<Prices>, Prisma__PricesClient<PricesGetPayload<T>>>

    /**
     * Count the number of Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesCountArgs} args - Arguments to filter Prices to count.
     * @example
     * // Count the number of Prices
     * const count = await prisma.prices.count({
     *   where: {
     *     // ... the filter for the Prices we want to count
     *   }
     * })
    **/
    count<T extends PricesCountArgs>(
      args?: Subset<T, PricesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PricesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PricesAggregateArgs>(args: Subset<T, PricesAggregateArgs>): PrismaPromise<GetPricesAggregateType<T>>

    /**
     * Group by Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PricesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PricesGroupByArgs['orderBy'] }
        : { orderBy?: PricesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PricesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PricesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    exchangeRates<T extends exchangeRatesArgs = {}>(args?: Subset<T, exchangeRatesArgs>): CheckSelect<T, Prisma__exchangeRatesClient<exchangeRates | null >, Prisma__exchangeRatesClient<exchangeRatesGetPayload<T> | null >>;

    Product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    disposals<T extends disposalsFindManyArgs = {}>(args?: Subset<T, disposalsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<disposals>>, PrismaPromise<Array<disposalsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Prices base type for findUnique actions
   */
  export type PricesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Prices
     * 
    **/
    select?: PricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PricesInclude | null
    /**
     * Filter, which Prices to fetch.
     * 
    **/
    where: PricesWhereUniqueInput
  }

  /**
   * Prices: findUnique
   */
  export interface PricesFindUniqueArgs extends PricesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Prices base type for findFirst actions
   */
  export type PricesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Prices
     * 
    **/
    select?: PricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PricesInclude | null
    /**
     * Filter, which Prices to fetch.
     * 
    **/
    where?: PricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     * 
    **/
    orderBy?: Enumerable<PricesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prices.
     * 
    **/
    cursor?: PricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prices.
     * 
    **/
    distinct?: Enumerable<PricesScalarFieldEnum>
  }

  /**
   * Prices: findFirst
   */
  export interface PricesFindFirstArgs extends PricesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Prices findMany
   */
  export type PricesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Prices
     * 
    **/
    select?: PricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PricesInclude | null
    /**
     * Filter, which Prices to fetch.
     * 
    **/
    where?: PricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     * 
    **/
    orderBy?: Enumerable<PricesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prices.
     * 
    **/
    cursor?: PricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PricesScalarFieldEnum>
  }


  /**
   * Prices create
   */
  export type PricesCreateArgs = {
    /**
     * Select specific fields to fetch from the Prices
     * 
    **/
    select?: PricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PricesInclude | null
    /**
     * The data needed to create a Prices.
     * 
    **/
    data: XOR<PricesCreateInput, PricesUncheckedCreateInput>
  }


  /**
   * Prices createMany
   */
  export type PricesCreateManyArgs = {
    /**
     * The data used to create many Prices.
     * 
    **/
    data: Enumerable<PricesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Prices update
   */
  export type PricesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Prices
     * 
    **/
    select?: PricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PricesInclude | null
    /**
     * The data needed to update a Prices.
     * 
    **/
    data: XOR<PricesUpdateInput, PricesUncheckedUpdateInput>
    /**
     * Choose, which Prices to update.
     * 
    **/
    where: PricesWhereUniqueInput
  }


  /**
   * Prices updateMany
   */
  export type PricesUpdateManyArgs = {
    /**
     * The data used to update Prices.
     * 
    **/
    data: XOR<PricesUpdateManyMutationInput, PricesUncheckedUpdateManyInput>
    /**
     * Filter which Prices to update
     * 
    **/
    where?: PricesWhereInput
  }


  /**
   * Prices upsert
   */
  export type PricesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Prices
     * 
    **/
    select?: PricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PricesInclude | null
    /**
     * The filter to search for the Prices to update in case it exists.
     * 
    **/
    where: PricesWhereUniqueInput
    /**
     * In case the Prices found by the `where` argument doesn't exist, create a new Prices with this data.
     * 
    **/
    create: XOR<PricesCreateInput, PricesUncheckedCreateInput>
    /**
     * In case the Prices was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PricesUpdateInput, PricesUncheckedUpdateInput>
  }


  /**
   * Prices delete
   */
  export type PricesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Prices
     * 
    **/
    select?: PricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PricesInclude | null
    /**
     * Filter which Prices to delete.
     * 
    **/
    where: PricesWhereUniqueInput
  }


  /**
   * Prices deleteMany
   */
  export type PricesDeleteManyArgs = {
    /**
     * Filter which Prices to delete
     * 
    **/
    where?: PricesWhereInput
  }


  /**
   * Prices: findUniqueOrThrow
   */
  export type PricesFindUniqueOrThrowArgs = PricesFindUniqueArgsBase
      

  /**
   * Prices: findFirstOrThrow
   */
  export type PricesFindFirstOrThrowArgs = PricesFindFirstArgsBase
      

  /**
   * Prices without action
   */
  export type PricesArgs = {
    /**
     * Select specific fields to fetch from the Prices
     * 
    **/
    select?: PricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PricesInclude | null
  }



  /**
   * Model invoice
   */


  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    discount: Decimal | null
    price: Decimal | null
    quantity: number | null
    transactionId: number | null
    cashierId: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    discount: Decimal | null
    price: Decimal | null
    quantity: number | null
    transactionId: number | null
    cashierId: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    productId: string | null
    discount: Decimal | null
    price: Decimal | null
    quantity: number | null
    transactionId: number | null
    cashierId: number | null
    customerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    supplierId: string | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    discount: Decimal | null
    price: Decimal | null
    quantity: number | null
    transactionId: number | null
    cashierId: number | null
    customerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    supplierId: string | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    productId: number
    discount: number
    price: number
    quantity: number
    transactionId: number
    cashierId: number
    customerId: number
    createdAt: number
    updatedAt: number
    supplierId: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    discount?: true
    price?: true
    quantity?: true
    transactionId?: true
    cashierId?: true
  }

  export type InvoiceSumAggregateInputType = {
    discount?: true
    price?: true
    quantity?: true
    transactionId?: true
    cashierId?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    productId?: true
    discount?: true
    price?: true
    quantity?: true
    transactionId?: true
    cashierId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
    supplierId?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    productId?: true
    discount?: true
    price?: true
    quantity?: true
    transactionId?: true
    cashierId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
    supplierId?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    productId?: true
    discount?: true
    price?: true
    quantity?: true
    transactionId?: true
    cashierId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
    supplierId?: true
    _all?: true
  }

  export type InvoiceAggregateArgs = {
    /**
     * Filter which invoice to aggregate.
     * 
    **/
    where?: invoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     * 
    **/
    orderBy?: Enumerable<invoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: invoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs = {
    where?: invoiceWhereInput
    orderBy?: Enumerable<invoiceOrderByWithAggregationInput>
    by: Array<InvoiceScalarFieldEnum>
    having?: invoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }


  export type InvoiceGroupByOutputType = {
    id: string
    productId: string
    discount: Decimal
    price: Decimal
    quantity: number
    transactionId: number
    cashierId: number
    customerId: string | null
    createdAt: Date
    updatedAt: Date
    supplierId: string | null
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type invoiceSelect = {
    id?: boolean
    productId?: boolean
    discount?: boolean
    price?: boolean
    quantity?: boolean
    transactionId?: boolean
    cashierId?: boolean
    tax?: boolean | TaxFindManyArgs
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cashier?: boolean | UserArgs
    customer?: boolean | CustomerArgs
    product?: boolean | ProductArgs
    transaction?: boolean | TransactionArgs
    Supplier?: boolean | SupplierArgs
    supplierId?: boolean
    _count?: boolean | InvoiceCountOutputTypeArgs
  }

  export type invoiceInclude = {
    tax?: boolean | TaxFindManyArgs
    cashier?: boolean | UserArgs
    customer?: boolean | CustomerArgs
    product?: boolean | ProductArgs
    transaction?: boolean | TransactionArgs
    Supplier?: boolean | SupplierArgs
    _count?: boolean | InvoiceCountOutputTypeArgs
  }

  export type invoiceGetPayload<
    S extends boolean | null | undefined | invoiceArgs,
    U = keyof S
      > = S extends true
        ? invoice
    : S extends undefined
    ? never
    : S extends invoiceArgs | invoiceFindManyArgs
    ?'include' extends U
    ? invoice  & {
    [P in TrueKeys<S['include']>]:
        P extends 'tax' ? Array < TaxGetPayload<S['include'][P]>>  :
        P extends 'cashier' ? UserGetPayload<S['include'][P]> :
        P extends 'customer' ? CustomerGetPayload<S['include'][P]> | null :
        P extends 'product' ? ProductGetPayload<S['include'][P]> :
        P extends 'transaction' ? TransactionGetPayload<S['include'][P]> :
        P extends 'Supplier' ? SupplierGetPayload<S['include'][P]> | null :
        P extends '_count' ? InvoiceCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'tax' ? Array < TaxGetPayload<S['select'][P]>>  :
        P extends 'cashier' ? UserGetPayload<S['select'][P]> :
        P extends 'customer' ? CustomerGetPayload<S['select'][P]> | null :
        P extends 'product' ? ProductGetPayload<S['select'][P]> :
        P extends 'transaction' ? TransactionGetPayload<S['select'][P]> :
        P extends 'Supplier' ? SupplierGetPayload<S['select'][P]> | null :
        P extends '_count' ? InvoiceCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof invoice ? invoice[P] : never
  } 
    : invoice
  : invoice


  type invoiceCountArgs = Merge<
    Omit<invoiceFindManyArgs, 'select' | 'include'> & {
      select?: InvoiceCountAggregateInputType | true
    }
  >

  export interface invoiceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {invoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invoiceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, invoiceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'invoice'> extends True ? CheckSelect<T, Prisma__invoiceClient<invoice>, Prisma__invoiceClient<invoiceGetPayload<T>>> : CheckSelect<T, Prisma__invoiceClient<invoice | null >, Prisma__invoiceClient<invoiceGetPayload<T> | null >>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invoiceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, invoiceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'invoice'> extends True ? CheckSelect<T, Prisma__invoiceClient<invoice>, Prisma__invoiceClient<invoiceGetPayload<T>>> : CheckSelect<T, Prisma__invoiceClient<invoice | null >, Prisma__invoiceClient<invoiceGetPayload<T> | null >>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends invoiceFindManyArgs>(
      args?: SelectSubset<T, invoiceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<invoice>>, PrismaPromise<Array<invoiceGetPayload<T>>>>

    /**
     * Create a Invoice.
     * @param {invoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
    **/
    create<T extends invoiceCreateArgs>(
      args: SelectSubset<T, invoiceCreateArgs>
    ): CheckSelect<T, Prisma__invoiceClient<invoice>, Prisma__invoiceClient<invoiceGetPayload<T>>>

    /**
     * Create many Invoices.
     *     @param {invoiceCreateManyArgs} args - Arguments to create many Invoices.
     *     @example
     *     // Create many Invoices
     *     const invoice = await prisma.invoice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invoiceCreateManyArgs>(
      args?: SelectSubset<T, invoiceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Invoice.
     * @param {invoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
    **/
    delete<T extends invoiceDeleteArgs>(
      args: SelectSubset<T, invoiceDeleteArgs>
    ): CheckSelect<T, Prisma__invoiceClient<invoice>, Prisma__invoiceClient<invoiceGetPayload<T>>>

    /**
     * Update one Invoice.
     * @param {invoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invoiceUpdateArgs>(
      args: SelectSubset<T, invoiceUpdateArgs>
    ): CheckSelect<T, Prisma__invoiceClient<invoice>, Prisma__invoiceClient<invoiceGetPayload<T>>>

    /**
     * Delete zero or more Invoices.
     * @param {invoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invoiceDeleteManyArgs>(
      args?: SelectSubset<T, invoiceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invoiceUpdateManyArgs>(
      args: SelectSubset<T, invoiceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {invoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
    **/
    upsert<T extends invoiceUpsertArgs>(
      args: SelectSubset<T, invoiceUpsertArgs>
    ): CheckSelect<T, Prisma__invoiceClient<invoice>, Prisma__invoiceClient<invoiceGetPayload<T>>>

    /**
     * Find one Invoice that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {invoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invoiceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, invoiceFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__invoiceClient<invoice>, Prisma__invoiceClient<invoiceGetPayload<T>>>

    /**
     * Find the first Invoice that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invoiceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, invoiceFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__invoiceClient<invoice>, Prisma__invoiceClient<invoiceGetPayload<T>>>

    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends invoiceCountArgs>(
      args?: Subset<T, invoiceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invoiceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    tax<T extends TaxFindManyArgs = {}>(args?: Subset<T, TaxFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Tax>>, PrismaPromise<Array<TaxGetPayload<T>>>>;

    cashier<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    customer<T extends CustomerArgs = {}>(args?: Subset<T, CustomerArgs>): CheckSelect<T, Prisma__CustomerClient<Customer | null >, Prisma__CustomerClient<CustomerGetPayload<T> | null >>;

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    transaction<T extends TransactionArgs = {}>(args?: Subset<T, TransactionArgs>): CheckSelect<T, Prisma__TransactionClient<Transaction | null >, Prisma__TransactionClient<TransactionGetPayload<T> | null >>;

    Supplier<T extends SupplierArgs = {}>(args?: Subset<T, SupplierArgs>): CheckSelect<T, Prisma__SupplierClient<Supplier | null >, Prisma__SupplierClient<SupplierGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * invoice base type for findUnique actions
   */
  export type invoiceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the invoice
     * 
    **/
    select?: invoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: invoiceInclude | null
    /**
     * Filter, which invoice to fetch.
     * 
    **/
    where: invoiceWhereUniqueInput
  }

  /**
   * invoice: findUnique
   */
  export interface invoiceFindUniqueArgs extends invoiceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invoice base type for findFirst actions
   */
  export type invoiceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the invoice
     * 
    **/
    select?: invoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: invoiceInclude | null
    /**
     * Filter, which invoice to fetch.
     * 
    **/
    where?: invoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     * 
    **/
    orderBy?: Enumerable<invoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoices.
     * 
    **/
    cursor?: invoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoices.
     * 
    **/
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }

  /**
   * invoice: findFirst
   */
  export interface invoiceFindFirstArgs extends invoiceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invoice findMany
   */
  export type invoiceFindManyArgs = {
    /**
     * Select specific fields to fetch from the invoice
     * 
    **/
    select?: invoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: invoiceInclude | null
    /**
     * Filter, which invoices to fetch.
     * 
    **/
    where?: invoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     * 
    **/
    orderBy?: Enumerable<invoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invoices.
     * 
    **/
    cursor?: invoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }


  /**
   * invoice create
   */
  export type invoiceCreateArgs = {
    /**
     * Select specific fields to fetch from the invoice
     * 
    **/
    select?: invoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: invoiceInclude | null
    /**
     * The data needed to create a invoice.
     * 
    **/
    data: XOR<invoiceCreateInput, invoiceUncheckedCreateInput>
  }


  /**
   * invoice createMany
   */
  export type invoiceCreateManyArgs = {
    /**
     * The data used to create many invoices.
     * 
    **/
    data: Enumerable<invoiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * invoice update
   */
  export type invoiceUpdateArgs = {
    /**
     * Select specific fields to fetch from the invoice
     * 
    **/
    select?: invoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: invoiceInclude | null
    /**
     * The data needed to update a invoice.
     * 
    **/
    data: XOR<invoiceUpdateInput, invoiceUncheckedUpdateInput>
    /**
     * Choose, which invoice to update.
     * 
    **/
    where: invoiceWhereUniqueInput
  }


  /**
   * invoice updateMany
   */
  export type invoiceUpdateManyArgs = {
    /**
     * The data used to update invoices.
     * 
    **/
    data: XOR<invoiceUpdateManyMutationInput, invoiceUncheckedUpdateManyInput>
    /**
     * Filter which invoices to update
     * 
    **/
    where?: invoiceWhereInput
  }


  /**
   * invoice upsert
   */
  export type invoiceUpsertArgs = {
    /**
     * Select specific fields to fetch from the invoice
     * 
    **/
    select?: invoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: invoiceInclude | null
    /**
     * The filter to search for the invoice to update in case it exists.
     * 
    **/
    where: invoiceWhereUniqueInput
    /**
     * In case the invoice found by the `where` argument doesn't exist, create a new invoice with this data.
     * 
    **/
    create: XOR<invoiceCreateInput, invoiceUncheckedCreateInput>
    /**
     * In case the invoice was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<invoiceUpdateInput, invoiceUncheckedUpdateInput>
  }


  /**
   * invoice delete
   */
  export type invoiceDeleteArgs = {
    /**
     * Select specific fields to fetch from the invoice
     * 
    **/
    select?: invoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: invoiceInclude | null
    /**
     * Filter which invoice to delete.
     * 
    **/
    where: invoiceWhereUniqueInput
  }


  /**
   * invoice deleteMany
   */
  export type invoiceDeleteManyArgs = {
    /**
     * Filter which invoices to delete
     * 
    **/
    where?: invoiceWhereInput
  }


  /**
   * invoice: findUniqueOrThrow
   */
  export type invoiceFindUniqueOrThrowArgs = invoiceFindUniqueArgsBase
      

  /**
   * invoice: findFirstOrThrow
   */
  export type invoiceFindFirstOrThrowArgs = invoiceFindFirstArgsBase
      

  /**
   * invoice without action
   */
  export type invoiceArgs = {
    /**
     * Select specific fields to fetch from the invoice
     * 
    **/
    select?: invoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: invoiceInclude | null
  }



  /**
   * Model Supplier
   */


  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    corporateName: string | null
    updatedAt: Date | null
    createdAt: Date | null
    emailAddress: string | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    corporateName: string | null
    updatedAt: Date | null
    createdAt: Date | null
    emailAddress: string | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    phoneNumber: number
    corporateName: number
    updatedAt: number
    createdAt: number
    emailAddress: number
    _all: number
  }


  export type SupplierMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    corporateName?: true
    updatedAt?: true
    createdAt?: true
    emailAddress?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    corporateName?: true
    updatedAt?: true
    createdAt?: true
    emailAddress?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    corporateName?: true
    updatedAt?: true
    createdAt?: true
    emailAddress?: true
    _all?: true
  }

  export type SupplierAggregateArgs = {
    /**
     * Filter which Supplier to aggregate.
     * 
    **/
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     * 
    **/
    orderBy?: Enumerable<SupplierOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs = {
    where?: SupplierWhereInput
    orderBy?: Enumerable<SupplierOrderByWithAggregationInput>
    by: Array<SupplierScalarFieldEnum>
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }


  export type SupplierGroupByOutputType = {
    id: string
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    corporateName: string | null
    updatedAt: Date
    createdAt: Date
    emailAddress: string | null
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    corporateName?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    emailAddress?: boolean
    address?: boolean | AddressFindManyArgs
    product?: boolean | ProductFindManyArgs
    invoice?: boolean | invoiceFindManyArgs
    transactions?: boolean | TransactionFindManyArgs
    Journal?: boolean | JournalFindManyArgs
    SalesJournal?: boolean | SalesJournalFindManyArgs
    CashDisbursementsJournal?: boolean | CashDisbursementsJournalFindManyArgs
    CashReceiptsJournal?: boolean | CashReceiptsJournalFindManyArgs
    ReturnsOutwardsJournal?: boolean | ReturnsOutwardsJournalFindManyArgs
    _count?: boolean | SupplierCountOutputTypeArgs
  }

  export type SupplierInclude = {
    address?: boolean | AddressFindManyArgs
    product?: boolean | ProductFindManyArgs
    invoice?: boolean | invoiceFindManyArgs
    transactions?: boolean | TransactionFindManyArgs
    Journal?: boolean | JournalFindManyArgs
    SalesJournal?: boolean | SalesJournalFindManyArgs
    CashDisbursementsJournal?: boolean | CashDisbursementsJournalFindManyArgs
    CashReceiptsJournal?: boolean | CashReceiptsJournalFindManyArgs
    ReturnsOutwardsJournal?: boolean | ReturnsOutwardsJournalFindManyArgs
    _count?: boolean | SupplierCountOutputTypeArgs
  }

  export type SupplierGetPayload<
    S extends boolean | null | undefined | SupplierArgs,
    U = keyof S
      > = S extends true
        ? Supplier
    : S extends undefined
    ? never
    : S extends SupplierArgs | SupplierFindManyArgs
    ?'include' extends U
    ? Supplier  & {
    [P in TrueKeys<S['include']>]:
        P extends 'address' ? Array < AddressGetPayload<S['include'][P]>>  :
        P extends 'product' ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends 'invoice' ? Array < invoiceGetPayload<S['include'][P]>>  :
        P extends 'transactions' ? Array < TransactionGetPayload<S['include'][P]>>  :
        P extends 'Journal' ? Array < JournalGetPayload<S['include'][P]>>  :
        P extends 'SalesJournal' ? Array < SalesJournalGetPayload<S['include'][P]>>  :
        P extends 'CashDisbursementsJournal' ? Array < CashDisbursementsJournalGetPayload<S['include'][P]>>  :
        P extends 'CashReceiptsJournal' ? Array < CashReceiptsJournalGetPayload<S['include'][P]>>  :
        P extends 'ReturnsOutwardsJournal' ? Array < ReturnsOutwardsJournalGetPayload<S['include'][P]>>  :
        P extends '_count' ? SupplierCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'address' ? Array < AddressGetPayload<S['select'][P]>>  :
        P extends 'product' ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends 'invoice' ? Array < invoiceGetPayload<S['select'][P]>>  :
        P extends 'transactions' ? Array < TransactionGetPayload<S['select'][P]>>  :
        P extends 'Journal' ? Array < JournalGetPayload<S['select'][P]>>  :
        P extends 'SalesJournal' ? Array < SalesJournalGetPayload<S['select'][P]>>  :
        P extends 'CashDisbursementsJournal' ? Array < CashDisbursementsJournalGetPayload<S['select'][P]>>  :
        P extends 'CashReceiptsJournal' ? Array < CashReceiptsJournalGetPayload<S['select'][P]>>  :
        P extends 'ReturnsOutwardsJournal' ? Array < ReturnsOutwardsJournalGetPayload<S['select'][P]>>  :
        P extends '_count' ? SupplierCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Supplier ? Supplier[P] : never
  } 
    : Supplier
  : Supplier


  type SupplierCountArgs = Merge<
    Omit<SupplierFindManyArgs, 'select' | 'include'> & {
      select?: SupplierCountAggregateInputType | true
    }
  >

  export interface SupplierDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SupplierFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SupplierFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Supplier'> extends True ? CheckSelect<T, Prisma__SupplierClient<Supplier>, Prisma__SupplierClient<SupplierGetPayload<T>>> : CheckSelect<T, Prisma__SupplierClient<Supplier | null >, Prisma__SupplierClient<SupplierGetPayload<T> | null >>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SupplierFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SupplierFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Supplier'> extends True ? CheckSelect<T, Prisma__SupplierClient<Supplier>, Prisma__SupplierClient<SupplierGetPayload<T>>> : CheckSelect<T, Prisma__SupplierClient<Supplier | null >, Prisma__SupplierClient<SupplierGetPayload<T> | null >>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SupplierFindManyArgs>(
      args?: SelectSubset<T, SupplierFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Supplier>>, PrismaPromise<Array<SupplierGetPayload<T>>>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
    **/
    create<T extends SupplierCreateArgs>(
      args: SelectSubset<T, SupplierCreateArgs>
    ): CheckSelect<T, Prisma__SupplierClient<Supplier>, Prisma__SupplierClient<SupplierGetPayload<T>>>

    /**
     * Create many Suppliers.
     *     @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     *     @example
     *     // Create many Suppliers
     *     const supplier = await prisma.supplier.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SupplierCreateManyArgs>(
      args?: SelectSubset<T, SupplierCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
    **/
    delete<T extends SupplierDeleteArgs>(
      args: SelectSubset<T, SupplierDeleteArgs>
    ): CheckSelect<T, Prisma__SupplierClient<Supplier>, Prisma__SupplierClient<SupplierGetPayload<T>>>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SupplierUpdateArgs>(
      args: SelectSubset<T, SupplierUpdateArgs>
    ): CheckSelect<T, Prisma__SupplierClient<Supplier>, Prisma__SupplierClient<SupplierGetPayload<T>>>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SupplierDeleteManyArgs>(
      args?: SelectSubset<T, SupplierDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SupplierUpdateManyArgs>(
      args: SelectSubset<T, SupplierUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
    **/
    upsert<T extends SupplierUpsertArgs>(
      args: SelectSubset<T, SupplierUpsertArgs>
    ): CheckSelect<T, Prisma__SupplierClient<Supplier>, Prisma__SupplierClient<SupplierGetPayload<T>>>

    /**
     * Find one Supplier that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SupplierFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SupplierClient<Supplier>, Prisma__SupplierClient<SupplierGetPayload<T>>>

    /**
     * Find the first Supplier that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SupplierFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SupplierClient<Supplier>, Prisma__SupplierClient<SupplierGetPayload<T>>>

    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SupplierClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    address<T extends AddressFindManyArgs = {}>(args?: Subset<T, AddressFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Address>>, PrismaPromise<Array<AddressGetPayload<T>>>>;

    product<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    invoice<T extends invoiceFindManyArgs = {}>(args?: Subset<T, invoiceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<invoice>>, PrismaPromise<Array<invoiceGetPayload<T>>>>;

    transactions<T extends TransactionFindManyArgs = {}>(args?: Subset<T, TransactionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Transaction>>, PrismaPromise<Array<TransactionGetPayload<T>>>>;

    Journal<T extends JournalFindManyArgs = {}>(args?: Subset<T, JournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Journal>>, PrismaPromise<Array<JournalGetPayload<T>>>>;

    SalesJournal<T extends SalesJournalFindManyArgs = {}>(args?: Subset<T, SalesJournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SalesJournal>>, PrismaPromise<Array<SalesJournalGetPayload<T>>>>;

    CashDisbursementsJournal<T extends CashDisbursementsJournalFindManyArgs = {}>(args?: Subset<T, CashDisbursementsJournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CashDisbursementsJournal>>, PrismaPromise<Array<CashDisbursementsJournalGetPayload<T>>>>;

    CashReceiptsJournal<T extends CashReceiptsJournalFindManyArgs = {}>(args?: Subset<T, CashReceiptsJournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CashReceiptsJournal>>, PrismaPromise<Array<CashReceiptsJournalGetPayload<T>>>>;

    ReturnsOutwardsJournal<T extends ReturnsOutwardsJournalFindManyArgs = {}>(args?: Subset<T, ReturnsOutwardsJournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ReturnsOutwardsJournal>>, PrismaPromise<Array<ReturnsOutwardsJournalGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Supplier base type for findUnique actions
   */
  export type SupplierFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Supplier
     * 
    **/
    select?: SupplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SupplierInclude | null
    /**
     * Filter, which Supplier to fetch.
     * 
    **/
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier: findUnique
   */
  export interface SupplierFindUniqueArgs extends SupplierFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Supplier base type for findFirst actions
   */
  export type SupplierFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Supplier
     * 
    **/
    select?: SupplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SupplierInclude | null
    /**
     * Filter, which Supplier to fetch.
     * 
    **/
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     * 
    **/
    orderBy?: Enumerable<SupplierOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     * 
    **/
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     * 
    **/
    distinct?: Enumerable<SupplierScalarFieldEnum>
  }

  /**
   * Supplier: findFirst
   */
  export interface SupplierFindFirstArgs extends SupplierFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs = {
    /**
     * Select specific fields to fetch from the Supplier
     * 
    **/
    select?: SupplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SupplierInclude | null
    /**
     * Filter, which Suppliers to fetch.
     * 
    **/
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     * 
    **/
    orderBy?: Enumerable<SupplierOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     * 
    **/
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SupplierScalarFieldEnum>
  }


  /**
   * Supplier create
   */
  export type SupplierCreateArgs = {
    /**
     * Select specific fields to fetch from the Supplier
     * 
    **/
    select?: SupplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SupplierInclude | null
    /**
     * The data needed to create a Supplier.
     * 
    **/
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }


  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs = {
    /**
     * The data used to create many Suppliers.
     * 
    **/
    data: Enumerable<SupplierCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Supplier update
   */
  export type SupplierUpdateArgs = {
    /**
     * Select specific fields to fetch from the Supplier
     * 
    **/
    select?: SupplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SupplierInclude | null
    /**
     * The data needed to update a Supplier.
     * 
    **/
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     * 
    **/
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs = {
    /**
     * The data used to update Suppliers.
     * 
    **/
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     * 
    **/
    where?: SupplierWhereInput
  }


  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs = {
    /**
     * Select specific fields to fetch from the Supplier
     * 
    **/
    select?: SupplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SupplierInclude | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     * 
    **/
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     * 
    **/
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }


  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs = {
    /**
     * Select specific fields to fetch from the Supplier
     * 
    **/
    select?: SupplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SupplierInclude | null
    /**
     * Filter which Supplier to delete.
     * 
    **/
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs = {
    /**
     * Filter which Suppliers to delete
     * 
    **/
    where?: SupplierWhereInput
  }


  /**
   * Supplier: findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs = SupplierFindUniqueArgsBase
      

  /**
   * Supplier: findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs = SupplierFindFirstArgsBase
      

  /**
   * Supplier without action
   */
  export type SupplierArgs = {
    /**
     * Select specific fields to fetch from the Supplier
     * 
    **/
    select?: SupplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SupplierInclude | null
  }



  /**
   * Model Customer
   */


  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    emailAddress: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    emailAddress: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    phoneNumber: number
    emailAddress: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    emailAddress?: true
    updatedAt?: true
    createdAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    emailAddress?: true
    updatedAt?: true
    createdAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    emailAddress?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs = {
    /**
     * Filter which Customer to aggregate.
     * 
    **/
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs = {
    where?: CustomerWhereInput
    orderBy?: Enumerable<CustomerOrderByWithAggregationInput>
    by: Array<CustomerScalarFieldEnum>
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }


  export type CustomerGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    phoneNumber: string | null
    emailAddress: string | null
    updatedAt: Date
    createdAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    emailAddress?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    address?: boolean | AddressFindManyArgs
    invoice?: boolean | invoiceFindManyArgs
    transaction?: boolean | TransactionFindManyArgs
    Journal?: boolean | JournalFindManyArgs
    PurchasesJournal?: boolean | PurchasesJournalFindManyArgs
    CashDisbursementsJournal?: boolean | CashDisbursementsJournalFindManyArgs
    CashReceiptsJournal?: boolean | CashReceiptsJournalFindManyArgs
    ReturnsInwardsJournal?: boolean | ReturnsInwardsJournalFindManyArgs
    _count?: boolean | CustomerCountOutputTypeArgs
  }

  export type CustomerInclude = {
    address?: boolean | AddressFindManyArgs
    invoice?: boolean | invoiceFindManyArgs
    transaction?: boolean | TransactionFindManyArgs
    Journal?: boolean | JournalFindManyArgs
    PurchasesJournal?: boolean | PurchasesJournalFindManyArgs
    CashDisbursementsJournal?: boolean | CashDisbursementsJournalFindManyArgs
    CashReceiptsJournal?: boolean | CashReceiptsJournalFindManyArgs
    ReturnsInwardsJournal?: boolean | ReturnsInwardsJournalFindManyArgs
    _count?: boolean | CustomerCountOutputTypeArgs
  }

  export type CustomerGetPayload<
    S extends boolean | null | undefined | CustomerArgs,
    U = keyof S
      > = S extends true
        ? Customer
    : S extends undefined
    ? never
    : S extends CustomerArgs | CustomerFindManyArgs
    ?'include' extends U
    ? Customer  & {
    [P in TrueKeys<S['include']>]:
        P extends 'address' ? Array < AddressGetPayload<S['include'][P]>>  :
        P extends 'invoice' ? Array < invoiceGetPayload<S['include'][P]>>  :
        P extends 'transaction' ? Array < TransactionGetPayload<S['include'][P]>>  :
        P extends 'Journal' ? Array < JournalGetPayload<S['include'][P]>>  :
        P extends 'PurchasesJournal' ? Array < PurchasesJournalGetPayload<S['include'][P]>>  :
        P extends 'CashDisbursementsJournal' ? Array < CashDisbursementsJournalGetPayload<S['include'][P]>>  :
        P extends 'CashReceiptsJournal' ? Array < CashReceiptsJournalGetPayload<S['include'][P]>>  :
        P extends 'ReturnsInwardsJournal' ? Array < ReturnsInwardsJournalGetPayload<S['include'][P]>>  :
        P extends '_count' ? CustomerCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'address' ? Array < AddressGetPayload<S['select'][P]>>  :
        P extends 'invoice' ? Array < invoiceGetPayload<S['select'][P]>>  :
        P extends 'transaction' ? Array < TransactionGetPayload<S['select'][P]>>  :
        P extends 'Journal' ? Array < JournalGetPayload<S['select'][P]>>  :
        P extends 'PurchasesJournal' ? Array < PurchasesJournalGetPayload<S['select'][P]>>  :
        P extends 'CashDisbursementsJournal' ? Array < CashDisbursementsJournalGetPayload<S['select'][P]>>  :
        P extends 'CashReceiptsJournal' ? Array < CashReceiptsJournalGetPayload<S['select'][P]>>  :
        P extends 'ReturnsInwardsJournal' ? Array < ReturnsInwardsJournalGetPayload<S['select'][P]>>  :
        P extends '_count' ? CustomerCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Customer ? Customer[P] : never
  } 
    : Customer
  : Customer


  type CustomerCountArgs = Merge<
    Omit<CustomerFindManyArgs, 'select' | 'include'> & {
      select?: CustomerCountAggregateInputType | true
    }
  >

  export interface CustomerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Customer'> extends True ? CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>> : CheckSelect<T, Prisma__CustomerClient<Customer | null >, Prisma__CustomerClient<CustomerGetPayload<T> | null >>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Customer'> extends True ? CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>> : CheckSelect<T, Prisma__CustomerClient<Customer | null >, Prisma__CustomerClient<CustomerGetPayload<T> | null >>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomerFindManyArgs>(
      args?: SelectSubset<T, CustomerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Customer>>, PrismaPromise<Array<CustomerGetPayload<T>>>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
    **/
    create<T extends CustomerCreateArgs>(
      args: SelectSubset<T, CustomerCreateArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>

    /**
     * Create many Customers.
     *     @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     *     @example
     *     // Create many Customers
     *     const customer = await prisma.customer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerCreateManyArgs>(
      args?: SelectSubset<T, CustomerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
    **/
    delete<T extends CustomerDeleteArgs>(
      args: SelectSubset<T, CustomerDeleteArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerUpdateArgs>(
      args: SelectSubset<T, CustomerUpdateArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerDeleteManyArgs>(
      args?: SelectSubset<T, CustomerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerUpdateManyArgs>(
      args: SelectSubset<T, CustomerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerUpsertArgs>(
      args: SelectSubset<T, CustomerUpsertArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>

    /**
     * Find one Customer that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomerFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>

    /**
     * Find the first Customer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    address<T extends AddressFindManyArgs = {}>(args?: Subset<T, AddressFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Address>>, PrismaPromise<Array<AddressGetPayload<T>>>>;

    invoice<T extends invoiceFindManyArgs = {}>(args?: Subset<T, invoiceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<invoice>>, PrismaPromise<Array<invoiceGetPayload<T>>>>;

    transaction<T extends TransactionFindManyArgs = {}>(args?: Subset<T, TransactionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Transaction>>, PrismaPromise<Array<TransactionGetPayload<T>>>>;

    Journal<T extends JournalFindManyArgs = {}>(args?: Subset<T, JournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Journal>>, PrismaPromise<Array<JournalGetPayload<T>>>>;

    PurchasesJournal<T extends PurchasesJournalFindManyArgs = {}>(args?: Subset<T, PurchasesJournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PurchasesJournal>>, PrismaPromise<Array<PurchasesJournalGetPayload<T>>>>;

    CashDisbursementsJournal<T extends CashDisbursementsJournalFindManyArgs = {}>(args?: Subset<T, CashDisbursementsJournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CashDisbursementsJournal>>, PrismaPromise<Array<CashDisbursementsJournalGetPayload<T>>>>;

    CashReceiptsJournal<T extends CashReceiptsJournalFindManyArgs = {}>(args?: Subset<T, CashReceiptsJournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CashReceiptsJournal>>, PrismaPromise<Array<CashReceiptsJournalGetPayload<T>>>>;

    ReturnsInwardsJournal<T extends ReturnsInwardsJournalFindManyArgs = {}>(args?: Subset<T, ReturnsInwardsJournalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ReturnsInwardsJournal>>, PrismaPromise<Array<ReturnsInwardsJournalGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Customer base type for findUnique actions
   */
  export type CustomerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * Filter, which Customer to fetch.
     * 
    **/
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer: findUnique
   */
  export interface CustomerFindUniqueArgs extends CustomerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Customer base type for findFirst actions
   */
  export type CustomerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * Filter, which Customer to fetch.
     * 
    **/
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     * 
    **/
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     * 
    **/
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }

  /**
   * Customer: findFirst
   */
  export interface CustomerFindFirstArgs extends CustomerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * Filter, which Customers to fetch.
     * 
    **/
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     * 
    **/
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * Customer create
   */
  export type CustomerCreateArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * The data needed to create a Customer.
     * 
    **/
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }


  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs = {
    /**
     * The data used to create many Customers.
     * 
    **/
    data: Enumerable<CustomerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Customer update
   */
  export type CustomerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * The data needed to update a Customer.
     * 
    **/
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     * 
    **/
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs = {
    /**
     * The data used to update Customers.
     * 
    **/
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     * 
    **/
    where?: CustomerWhereInput
  }


  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * The filter to search for the Customer to update in case it exists.
     * 
    **/
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     * 
    **/
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }


  /**
   * Customer delete
   */
  export type CustomerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * Filter which Customer to delete.
     * 
    **/
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs = {
    /**
     * Filter which Customers to delete
     * 
    **/
    where?: CustomerWhereInput
  }


  /**
   * Customer: findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs = CustomerFindUniqueArgsBase
      

  /**
   * Customer: findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs = CustomerFindFirstArgsBase
      

  /**
   * Customer without action
   */
  export type CustomerArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
  }



  /**
   * Model Address
   */


  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
    supplierId: string | null
    customerId: string | null
    street: string | null
    city: string | null
    country: string | null
    zip: string | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
    supplierId: string | null
    customerId: string | null
    street: string | null
    city: string | null
    country: string | null
    zip: string | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    supplierId: number
    customerId: number
    street: number
    city: number
    country: number
    zip: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
    supplierId?: true
    customerId?: true
    street?: true
    city?: true
    country?: true
    zip?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    supplierId?: true
    customerId?: true
    street?: true
    city?: true
    country?: true
    zip?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    supplierId?: true
    customerId?: true
    street?: true
    city?: true
    country?: true
    zip?: true
    _all?: true
  }

  export type AddressAggregateArgs = {
    /**
     * Filter which Address to aggregate.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs = {
    where?: AddressWhereInput
    orderBy?: Enumerable<AddressOrderByWithAggregationInput>
    by: Array<AddressScalarFieldEnum>
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }


  export type AddressGroupByOutputType = {
    id: string
    supplierId: string | null
    customerId: string | null
    street: string
    city: string
    country: string
    zip: string | null
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect = {
    id?: boolean
    supplierId?: boolean
    customerId?: boolean
    street?: boolean
    city?: boolean
    country?: boolean
    zip?: boolean
    customers?: boolean | CustomerArgs
    suppliers?: boolean | SupplierArgs
  }

  export type AddressInclude = {
    customers?: boolean | CustomerArgs
    suppliers?: boolean | SupplierArgs
  }

  export type AddressGetPayload<
    S extends boolean | null | undefined | AddressArgs,
    U = keyof S
      > = S extends true
        ? Address
    : S extends undefined
    ? never
    : S extends AddressArgs | AddressFindManyArgs
    ?'include' extends U
    ? Address  & {
    [P in TrueKeys<S['include']>]:
        P extends 'customers' ? CustomerGetPayload<S['include'][P]> | null :
        P extends 'suppliers' ? SupplierGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'customers' ? CustomerGetPayload<S['select'][P]> | null :
        P extends 'suppliers' ? SupplierGetPayload<S['select'][P]> | null :  P extends keyof Address ? Address[P] : never
  } 
    : Address
  : Address


  type AddressCountArgs = Merge<
    Omit<AddressFindManyArgs, 'select' | 'include'> & {
      select?: AddressCountAggregateInputType | true
    }
  >

  export interface AddressDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Address'> extends True ? CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>> : CheckSelect<T, Prisma__AddressClient<Address | null >, Prisma__AddressClient<AddressGetPayload<T> | null >>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Address'> extends True ? CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>> : CheckSelect<T, Prisma__AddressClient<Address | null >, Prisma__AddressClient<AddressGetPayload<T> | null >>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AddressFindManyArgs>(
      args?: SelectSubset<T, AddressFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Address>>, PrismaPromise<Array<AddressGetPayload<T>>>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends AddressCreateArgs>(
      args: SelectSubset<T, AddressCreateArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Create many Addresses.
     *     @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const address = await prisma.address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddressCreateManyArgs>(
      args?: SelectSubset<T, AddressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends AddressDeleteArgs>(
      args: SelectSubset<T, AddressDeleteArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressUpdateArgs>(
      args: SelectSubset<T, AddressUpdateArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressDeleteManyArgs>(
      args?: SelectSubset<T, AddressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressUpdateManyArgs>(
      args: SelectSubset<T, AddressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends AddressUpsertArgs>(
      args: SelectSubset<T, AddressUpsertArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Find one Address that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AddressFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Find the first Address that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AddressFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AddressClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    customers<T extends CustomerArgs = {}>(args?: Subset<T, CustomerArgs>): CheckSelect<T, Prisma__CustomerClient<Customer | null >, Prisma__CustomerClient<CustomerGetPayload<T> | null >>;

    suppliers<T extends SupplierArgs = {}>(args?: Subset<T, SupplierArgs>): CheckSelect<T, Prisma__SupplierClient<Supplier | null >, Prisma__SupplierClient<SupplierGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Address base type for findUnique actions
   */
  export type AddressFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Address to fetch.
     * 
    **/
    where: AddressWhereUniqueInput
  }

  /**
   * Address: findUnique
   */
  export interface AddressFindUniqueArgs extends AddressFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Address base type for findFirst actions
   */
  export type AddressFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Address to fetch.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     * 
    **/
    distinct?: Enumerable<AddressScalarFieldEnum>
  }

  /**
   * Address: findFirst
   */
  export interface AddressFindFirstArgs extends AddressFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Address findMany
   */
  export type AddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Addresses to fetch.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address create
   */
  export type AddressCreateArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The data needed to create a Address.
     * 
    **/
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }


  /**
   * Address createMany
   */
  export type AddressCreateManyArgs = {
    /**
     * The data used to create many Addresses.
     * 
    **/
    data: Enumerable<AddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Address update
   */
  export type AddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The data needed to update a Address.
     * 
    **/
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     * 
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs = {
    /**
     * The data used to update Addresses.
     * 
    **/
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     * 
    **/
    where?: AddressWhereInput
  }


  /**
   * Address upsert
   */
  export type AddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The filter to search for the Address to update in case it exists.
     * 
    **/
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     * 
    **/
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }


  /**
   * Address delete
   */
  export type AddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter which Address to delete.
     * 
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs = {
    /**
     * Filter which Addresses to delete
     * 
    **/
    where?: AddressWhereInput
  }


  /**
   * Address: findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs = AddressFindUniqueArgsBase
      

  /**
   * Address: findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs = AddressFindFirstArgsBase
      

  /**
   * Address without action
   */
  export type AddressArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
  }



  /**
   * Model baseCurrency
   */


  export type AggregateBaseCurrency = {
    _count: BaseCurrencyCountAggregateOutputType | null
    _min: BaseCurrencyMinAggregateOutputType | null
    _max: BaseCurrencyMaxAggregateOutputType | null
  }

  export type BaseCurrencyMinAggregateOutputType = {
    id: string | null
    currencyId: string | null
    createdAt: Date | null
    active: boolean | null
  }

  export type BaseCurrencyMaxAggregateOutputType = {
    id: string | null
    currencyId: string | null
    createdAt: Date | null
    active: boolean | null
  }

  export type BaseCurrencyCountAggregateOutputType = {
    id: number
    currencyId: number
    createdAt: number
    active: number
    _all: number
  }


  export type BaseCurrencyMinAggregateInputType = {
    id?: true
    currencyId?: true
    createdAt?: true
    active?: true
  }

  export type BaseCurrencyMaxAggregateInputType = {
    id?: true
    currencyId?: true
    createdAt?: true
    active?: true
  }

  export type BaseCurrencyCountAggregateInputType = {
    id?: true
    currencyId?: true
    createdAt?: true
    active?: true
    _all?: true
  }

  export type BaseCurrencyAggregateArgs = {
    /**
     * Filter which baseCurrency to aggregate.
     * 
    **/
    where?: baseCurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of baseCurrencies to fetch.
     * 
    **/
    orderBy?: Enumerable<baseCurrencyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: baseCurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` baseCurrencies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` baseCurrencies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned baseCurrencies
    **/
    _count?: true | BaseCurrencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BaseCurrencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BaseCurrencyMaxAggregateInputType
  }

  export type GetBaseCurrencyAggregateType<T extends BaseCurrencyAggregateArgs> = {
        [P in keyof T & keyof AggregateBaseCurrency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBaseCurrency[P]>
      : GetScalarType<T[P], AggregateBaseCurrency[P]>
  }




  export type BaseCurrencyGroupByArgs = {
    where?: baseCurrencyWhereInput
    orderBy?: Enumerable<baseCurrencyOrderByWithAggregationInput>
    by: Array<BaseCurrencyScalarFieldEnum>
    having?: baseCurrencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BaseCurrencyCountAggregateInputType | true
    _min?: BaseCurrencyMinAggregateInputType
    _max?: BaseCurrencyMaxAggregateInputType
  }


  export type BaseCurrencyGroupByOutputType = {
    id: string
    currencyId: string
    createdAt: Date
    active: boolean
    _count: BaseCurrencyCountAggregateOutputType | null
    _min: BaseCurrencyMinAggregateOutputType | null
    _max: BaseCurrencyMaxAggregateOutputType | null
  }

  type GetBaseCurrencyGroupByPayload<T extends BaseCurrencyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BaseCurrencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BaseCurrencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BaseCurrencyGroupByOutputType[P]>
            : GetScalarType<T[P], BaseCurrencyGroupByOutputType[P]>
        }
      >
    >


  export type baseCurrencySelect = {
    id?: boolean
    currencyId?: boolean
    createdAt?: boolean
    active?: boolean
    currency?: boolean | currencyArgs
    exchangeRates?: boolean | exchangeRatesFindManyArgs
    _count?: boolean | BaseCurrencyCountOutputTypeArgs
  }

  export type baseCurrencyInclude = {
    currency?: boolean | currencyArgs
    exchangeRates?: boolean | exchangeRatesFindManyArgs
    _count?: boolean | BaseCurrencyCountOutputTypeArgs
  }

  export type baseCurrencyGetPayload<
    S extends boolean | null | undefined | baseCurrencyArgs,
    U = keyof S
      > = S extends true
        ? baseCurrency
    : S extends undefined
    ? never
    : S extends baseCurrencyArgs | baseCurrencyFindManyArgs
    ?'include' extends U
    ? baseCurrency  & {
    [P in TrueKeys<S['include']>]:
        P extends 'currency' ? currencyGetPayload<S['include'][P]> :
        P extends 'exchangeRates' ? Array < exchangeRatesGetPayload<S['include'][P]>>  :
        P extends '_count' ? BaseCurrencyCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'currency' ? currencyGetPayload<S['select'][P]> :
        P extends 'exchangeRates' ? Array < exchangeRatesGetPayload<S['select'][P]>>  :
        P extends '_count' ? BaseCurrencyCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof baseCurrency ? baseCurrency[P] : never
  } 
    : baseCurrency
  : baseCurrency


  type baseCurrencyCountArgs = Merge<
    Omit<baseCurrencyFindManyArgs, 'select' | 'include'> & {
      select?: BaseCurrencyCountAggregateInputType | true
    }
  >

  export interface baseCurrencyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one BaseCurrency that matches the filter.
     * @param {baseCurrencyFindUniqueArgs} args - Arguments to find a BaseCurrency
     * @example
     * // Get one BaseCurrency
     * const baseCurrency = await prisma.baseCurrency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends baseCurrencyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, baseCurrencyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'baseCurrency'> extends True ? CheckSelect<T, Prisma__baseCurrencyClient<baseCurrency>, Prisma__baseCurrencyClient<baseCurrencyGetPayload<T>>> : CheckSelect<T, Prisma__baseCurrencyClient<baseCurrency | null >, Prisma__baseCurrencyClient<baseCurrencyGetPayload<T> | null >>

    /**
     * Find the first BaseCurrency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baseCurrencyFindFirstArgs} args - Arguments to find a BaseCurrency
     * @example
     * // Get one BaseCurrency
     * const baseCurrency = await prisma.baseCurrency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends baseCurrencyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, baseCurrencyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'baseCurrency'> extends True ? CheckSelect<T, Prisma__baseCurrencyClient<baseCurrency>, Prisma__baseCurrencyClient<baseCurrencyGetPayload<T>>> : CheckSelect<T, Prisma__baseCurrencyClient<baseCurrency | null >, Prisma__baseCurrencyClient<baseCurrencyGetPayload<T> | null >>

    /**
     * Find zero or more BaseCurrencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baseCurrencyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BaseCurrencies
     * const baseCurrencies = await prisma.baseCurrency.findMany()
     * 
     * // Get first 10 BaseCurrencies
     * const baseCurrencies = await prisma.baseCurrency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const baseCurrencyWithIdOnly = await prisma.baseCurrency.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends baseCurrencyFindManyArgs>(
      args?: SelectSubset<T, baseCurrencyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<baseCurrency>>, PrismaPromise<Array<baseCurrencyGetPayload<T>>>>

    /**
     * Create a BaseCurrency.
     * @param {baseCurrencyCreateArgs} args - Arguments to create a BaseCurrency.
     * @example
     * // Create one BaseCurrency
     * const BaseCurrency = await prisma.baseCurrency.create({
     *   data: {
     *     // ... data to create a BaseCurrency
     *   }
     * })
     * 
    **/
    create<T extends baseCurrencyCreateArgs>(
      args: SelectSubset<T, baseCurrencyCreateArgs>
    ): CheckSelect<T, Prisma__baseCurrencyClient<baseCurrency>, Prisma__baseCurrencyClient<baseCurrencyGetPayload<T>>>

    /**
     * Create many BaseCurrencies.
     *     @param {baseCurrencyCreateManyArgs} args - Arguments to create many BaseCurrencies.
     *     @example
     *     // Create many BaseCurrencies
     *     const baseCurrency = await prisma.baseCurrency.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends baseCurrencyCreateManyArgs>(
      args?: SelectSubset<T, baseCurrencyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a BaseCurrency.
     * @param {baseCurrencyDeleteArgs} args - Arguments to delete one BaseCurrency.
     * @example
     * // Delete one BaseCurrency
     * const BaseCurrency = await prisma.baseCurrency.delete({
     *   where: {
     *     // ... filter to delete one BaseCurrency
     *   }
     * })
     * 
    **/
    delete<T extends baseCurrencyDeleteArgs>(
      args: SelectSubset<T, baseCurrencyDeleteArgs>
    ): CheckSelect<T, Prisma__baseCurrencyClient<baseCurrency>, Prisma__baseCurrencyClient<baseCurrencyGetPayload<T>>>

    /**
     * Update one BaseCurrency.
     * @param {baseCurrencyUpdateArgs} args - Arguments to update one BaseCurrency.
     * @example
     * // Update one BaseCurrency
     * const baseCurrency = await prisma.baseCurrency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends baseCurrencyUpdateArgs>(
      args: SelectSubset<T, baseCurrencyUpdateArgs>
    ): CheckSelect<T, Prisma__baseCurrencyClient<baseCurrency>, Prisma__baseCurrencyClient<baseCurrencyGetPayload<T>>>

    /**
     * Delete zero or more BaseCurrencies.
     * @param {baseCurrencyDeleteManyArgs} args - Arguments to filter BaseCurrencies to delete.
     * @example
     * // Delete a few BaseCurrencies
     * const { count } = await prisma.baseCurrency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends baseCurrencyDeleteManyArgs>(
      args?: SelectSubset<T, baseCurrencyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more BaseCurrencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baseCurrencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BaseCurrencies
     * const baseCurrency = await prisma.baseCurrency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends baseCurrencyUpdateManyArgs>(
      args: SelectSubset<T, baseCurrencyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one BaseCurrency.
     * @param {baseCurrencyUpsertArgs} args - Arguments to update or create a BaseCurrency.
     * @example
     * // Update or create a BaseCurrency
     * const baseCurrency = await prisma.baseCurrency.upsert({
     *   create: {
     *     // ... data to create a BaseCurrency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BaseCurrency we want to update
     *   }
     * })
    **/
    upsert<T extends baseCurrencyUpsertArgs>(
      args: SelectSubset<T, baseCurrencyUpsertArgs>
    ): CheckSelect<T, Prisma__baseCurrencyClient<baseCurrency>, Prisma__baseCurrencyClient<baseCurrencyGetPayload<T>>>

    /**
     * Find one BaseCurrency that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {baseCurrencyFindUniqueOrThrowArgs} args - Arguments to find a BaseCurrency
     * @example
     * // Get one BaseCurrency
     * const baseCurrency = await prisma.baseCurrency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends baseCurrencyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, baseCurrencyFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__baseCurrencyClient<baseCurrency>, Prisma__baseCurrencyClient<baseCurrencyGetPayload<T>>>

    /**
     * Find the first BaseCurrency that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baseCurrencyFindFirstOrThrowArgs} args - Arguments to find a BaseCurrency
     * @example
     * // Get one BaseCurrency
     * const baseCurrency = await prisma.baseCurrency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends baseCurrencyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, baseCurrencyFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__baseCurrencyClient<baseCurrency>, Prisma__baseCurrencyClient<baseCurrencyGetPayload<T>>>

    /**
     * Count the number of BaseCurrencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baseCurrencyCountArgs} args - Arguments to filter BaseCurrencies to count.
     * @example
     * // Count the number of BaseCurrencies
     * const count = await prisma.baseCurrency.count({
     *   where: {
     *     // ... the filter for the BaseCurrencies we want to count
     *   }
     * })
    **/
    count<T extends baseCurrencyCountArgs>(
      args?: Subset<T, baseCurrencyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BaseCurrencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BaseCurrency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseCurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BaseCurrencyAggregateArgs>(args: Subset<T, BaseCurrencyAggregateArgs>): PrismaPromise<GetBaseCurrencyAggregateType<T>>

    /**
     * Group by BaseCurrency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseCurrencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BaseCurrencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BaseCurrencyGroupByArgs['orderBy'] }
        : { orderBy?: BaseCurrencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BaseCurrencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBaseCurrencyGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for baseCurrency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__baseCurrencyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    currency<T extends currencyArgs = {}>(args?: Subset<T, currencyArgs>): CheckSelect<T, Prisma__currencyClient<currency | null >, Prisma__currencyClient<currencyGetPayload<T> | null >>;

    exchangeRates<T extends exchangeRatesFindManyArgs = {}>(args?: Subset<T, exchangeRatesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<exchangeRates>>, PrismaPromise<Array<exchangeRatesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * baseCurrency base type for findUnique actions
   */
  export type baseCurrencyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the baseCurrency
     * 
    **/
    select?: baseCurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: baseCurrencyInclude | null
    /**
     * Filter, which baseCurrency to fetch.
     * 
    **/
    where: baseCurrencyWhereUniqueInput
  }

  /**
   * baseCurrency: findUnique
   */
  export interface baseCurrencyFindUniqueArgs extends baseCurrencyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * baseCurrency base type for findFirst actions
   */
  export type baseCurrencyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the baseCurrency
     * 
    **/
    select?: baseCurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: baseCurrencyInclude | null
    /**
     * Filter, which baseCurrency to fetch.
     * 
    **/
    where?: baseCurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of baseCurrencies to fetch.
     * 
    **/
    orderBy?: Enumerable<baseCurrencyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for baseCurrencies.
     * 
    **/
    cursor?: baseCurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` baseCurrencies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` baseCurrencies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of baseCurrencies.
     * 
    **/
    distinct?: Enumerable<BaseCurrencyScalarFieldEnum>
  }

  /**
   * baseCurrency: findFirst
   */
  export interface baseCurrencyFindFirstArgs extends baseCurrencyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * baseCurrency findMany
   */
  export type baseCurrencyFindManyArgs = {
    /**
     * Select specific fields to fetch from the baseCurrency
     * 
    **/
    select?: baseCurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: baseCurrencyInclude | null
    /**
     * Filter, which baseCurrencies to fetch.
     * 
    **/
    where?: baseCurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of baseCurrencies to fetch.
     * 
    **/
    orderBy?: Enumerable<baseCurrencyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing baseCurrencies.
     * 
    **/
    cursor?: baseCurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` baseCurrencies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` baseCurrencies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BaseCurrencyScalarFieldEnum>
  }


  /**
   * baseCurrency create
   */
  export type baseCurrencyCreateArgs = {
    /**
     * Select specific fields to fetch from the baseCurrency
     * 
    **/
    select?: baseCurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: baseCurrencyInclude | null
    /**
     * The data needed to create a baseCurrency.
     * 
    **/
    data: XOR<baseCurrencyCreateInput, baseCurrencyUncheckedCreateInput>
  }


  /**
   * baseCurrency createMany
   */
  export type baseCurrencyCreateManyArgs = {
    /**
     * The data used to create many baseCurrencies.
     * 
    **/
    data: Enumerable<baseCurrencyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * baseCurrency update
   */
  export type baseCurrencyUpdateArgs = {
    /**
     * Select specific fields to fetch from the baseCurrency
     * 
    **/
    select?: baseCurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: baseCurrencyInclude | null
    /**
     * The data needed to update a baseCurrency.
     * 
    **/
    data: XOR<baseCurrencyUpdateInput, baseCurrencyUncheckedUpdateInput>
    /**
     * Choose, which baseCurrency to update.
     * 
    **/
    where: baseCurrencyWhereUniqueInput
  }


  /**
   * baseCurrency updateMany
   */
  export type baseCurrencyUpdateManyArgs = {
    /**
     * The data used to update baseCurrencies.
     * 
    **/
    data: XOR<baseCurrencyUpdateManyMutationInput, baseCurrencyUncheckedUpdateManyInput>
    /**
     * Filter which baseCurrencies to update
     * 
    **/
    where?: baseCurrencyWhereInput
  }


  /**
   * baseCurrency upsert
   */
  export type baseCurrencyUpsertArgs = {
    /**
     * Select specific fields to fetch from the baseCurrency
     * 
    **/
    select?: baseCurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: baseCurrencyInclude | null
    /**
     * The filter to search for the baseCurrency to update in case it exists.
     * 
    **/
    where: baseCurrencyWhereUniqueInput
    /**
     * In case the baseCurrency found by the `where` argument doesn't exist, create a new baseCurrency with this data.
     * 
    **/
    create: XOR<baseCurrencyCreateInput, baseCurrencyUncheckedCreateInput>
    /**
     * In case the baseCurrency was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<baseCurrencyUpdateInput, baseCurrencyUncheckedUpdateInput>
  }


  /**
   * baseCurrency delete
   */
  export type baseCurrencyDeleteArgs = {
    /**
     * Select specific fields to fetch from the baseCurrency
     * 
    **/
    select?: baseCurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: baseCurrencyInclude | null
    /**
     * Filter which baseCurrency to delete.
     * 
    **/
    where: baseCurrencyWhereUniqueInput
  }


  /**
   * baseCurrency deleteMany
   */
  export type baseCurrencyDeleteManyArgs = {
    /**
     * Filter which baseCurrencies to delete
     * 
    **/
    where?: baseCurrencyWhereInput
  }


  /**
   * baseCurrency: findUniqueOrThrow
   */
  export type baseCurrencyFindUniqueOrThrowArgs = baseCurrencyFindUniqueArgsBase
      

  /**
   * baseCurrency: findFirstOrThrow
   */
  export type baseCurrencyFindFirstOrThrowArgs = baseCurrencyFindFirstArgsBase
      

  /**
   * baseCurrency without action
   */
  export type baseCurrencyArgs = {
    /**
     * Select specific fields to fetch from the baseCurrency
     * 
    **/
    select?: baseCurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: baseCurrencyInclude | null
  }



  /**
   * Model currency
   */


  export type AggregateCurrency = {
    _count: CurrencyCountAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  export type CurrencyMinAggregateOutputType = {
    id: string | null
    currencyName: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type CurrencyMaxAggregateOutputType = {
    id: string | null
    currencyName: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type CurrencyCountAggregateOutputType = {
    id: number
    currencyName: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type CurrencyMinAggregateInputType = {
    id?: true
    currencyName?: true
    updatedAt?: true
    createdAt?: true
  }

  export type CurrencyMaxAggregateInputType = {
    id?: true
    currencyName?: true
    updatedAt?: true
    createdAt?: true
  }

  export type CurrencyCountAggregateInputType = {
    id?: true
    currencyName?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type CurrencyAggregateArgs = {
    /**
     * Filter which currency to aggregate.
     * 
    **/
    where?: currencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of currencies to fetch.
     * 
    **/
    orderBy?: Enumerable<currencyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: currencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` currencies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` currencies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned currencies
    **/
    _count?: true | CurrencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrencyMaxAggregateInputType
  }

  export type GetCurrencyAggregateType<T extends CurrencyAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrency[P]>
      : GetScalarType<T[P], AggregateCurrency[P]>
  }




  export type CurrencyGroupByArgs = {
    where?: currencyWhereInput
    orderBy?: Enumerable<currencyOrderByWithAggregationInput>
    by: Array<CurrencyScalarFieldEnum>
    having?: currencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrencyCountAggregateInputType | true
    _min?: CurrencyMinAggregateInputType
    _max?: CurrencyMaxAggregateInputType
  }


  export type CurrencyGroupByOutputType = {
    id: string
    currencyName: string
    updatedAt: Date
    createdAt: Date
    _count: CurrencyCountAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  type GetCurrencyGroupByPayload<T extends CurrencyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CurrencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
            : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
        }
      >
    >


  export type currencySelect = {
    id?: boolean
    currencyName?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    baseCurrency?: boolean | baseCurrencyFindManyArgs
    exchangeRates?: boolean | exchangeRatesFindManyArgs
    payments?: boolean | PaymentFindManyArgs
    tax?: boolean | TaxFindManyArgs
    _count?: boolean | CurrencyCountOutputTypeArgs
  }

  export type currencyInclude = {
    baseCurrency?: boolean | baseCurrencyFindManyArgs
    exchangeRates?: boolean | exchangeRatesFindManyArgs
    payments?: boolean | PaymentFindManyArgs
    tax?: boolean | TaxFindManyArgs
    _count?: boolean | CurrencyCountOutputTypeArgs
  }

  export type currencyGetPayload<
    S extends boolean | null | undefined | currencyArgs,
    U = keyof S
      > = S extends true
        ? currency
    : S extends undefined
    ? never
    : S extends currencyArgs | currencyFindManyArgs
    ?'include' extends U
    ? currency  & {
    [P in TrueKeys<S['include']>]:
        P extends 'baseCurrency' ? Array < baseCurrencyGetPayload<S['include'][P]>>  :
        P extends 'exchangeRates' ? Array < exchangeRatesGetPayload<S['include'][P]>>  :
        P extends 'payments' ? Array < PaymentGetPayload<S['include'][P]>>  :
        P extends 'tax' ? Array < TaxGetPayload<S['include'][P]>>  :
        P extends '_count' ? CurrencyCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'baseCurrency' ? Array < baseCurrencyGetPayload<S['select'][P]>>  :
        P extends 'exchangeRates' ? Array < exchangeRatesGetPayload<S['select'][P]>>  :
        P extends 'payments' ? Array < PaymentGetPayload<S['select'][P]>>  :
        P extends 'tax' ? Array < TaxGetPayload<S['select'][P]>>  :
        P extends '_count' ? CurrencyCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof currency ? currency[P] : never
  } 
    : currency
  : currency


  type currencyCountArgs = Merge<
    Omit<currencyFindManyArgs, 'select' | 'include'> & {
      select?: CurrencyCountAggregateInputType | true
    }
  >

  export interface currencyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Currency that matches the filter.
     * @param {currencyFindUniqueArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends currencyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, currencyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'currency'> extends True ? CheckSelect<T, Prisma__currencyClient<currency>, Prisma__currencyClient<currencyGetPayload<T>>> : CheckSelect<T, Prisma__currencyClient<currency | null >, Prisma__currencyClient<currencyGetPayload<T> | null >>

    /**
     * Find the first Currency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currencyFindFirstArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends currencyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, currencyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'currency'> extends True ? CheckSelect<T, Prisma__currencyClient<currency>, Prisma__currencyClient<currencyGetPayload<T>>> : CheckSelect<T, Prisma__currencyClient<currency | null >, Prisma__currencyClient<currencyGetPayload<T> | null >>

    /**
     * Find zero or more Currencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currencyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Currencies
     * const currencies = await prisma.currency.findMany()
     * 
     * // Get first 10 Currencies
     * const currencies = await prisma.currency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currencyWithIdOnly = await prisma.currency.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends currencyFindManyArgs>(
      args?: SelectSubset<T, currencyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<currency>>, PrismaPromise<Array<currencyGetPayload<T>>>>

    /**
     * Create a Currency.
     * @param {currencyCreateArgs} args - Arguments to create a Currency.
     * @example
     * // Create one Currency
     * const Currency = await prisma.currency.create({
     *   data: {
     *     // ... data to create a Currency
     *   }
     * })
     * 
    **/
    create<T extends currencyCreateArgs>(
      args: SelectSubset<T, currencyCreateArgs>
    ): CheckSelect<T, Prisma__currencyClient<currency>, Prisma__currencyClient<currencyGetPayload<T>>>

    /**
     * Create many Currencies.
     *     @param {currencyCreateManyArgs} args - Arguments to create many Currencies.
     *     @example
     *     // Create many Currencies
     *     const currency = await prisma.currency.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends currencyCreateManyArgs>(
      args?: SelectSubset<T, currencyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Currency.
     * @param {currencyDeleteArgs} args - Arguments to delete one Currency.
     * @example
     * // Delete one Currency
     * const Currency = await prisma.currency.delete({
     *   where: {
     *     // ... filter to delete one Currency
     *   }
     * })
     * 
    **/
    delete<T extends currencyDeleteArgs>(
      args: SelectSubset<T, currencyDeleteArgs>
    ): CheckSelect<T, Prisma__currencyClient<currency>, Prisma__currencyClient<currencyGetPayload<T>>>

    /**
     * Update one Currency.
     * @param {currencyUpdateArgs} args - Arguments to update one Currency.
     * @example
     * // Update one Currency
     * const currency = await prisma.currency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends currencyUpdateArgs>(
      args: SelectSubset<T, currencyUpdateArgs>
    ): CheckSelect<T, Prisma__currencyClient<currency>, Prisma__currencyClient<currencyGetPayload<T>>>

    /**
     * Delete zero or more Currencies.
     * @param {currencyDeleteManyArgs} args - Arguments to filter Currencies to delete.
     * @example
     * // Delete a few Currencies
     * const { count } = await prisma.currency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends currencyDeleteManyArgs>(
      args?: SelectSubset<T, currencyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends currencyUpdateManyArgs>(
      args: SelectSubset<T, currencyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Currency.
     * @param {currencyUpsertArgs} args - Arguments to update or create a Currency.
     * @example
     * // Update or create a Currency
     * const currency = await prisma.currency.upsert({
     *   create: {
     *     // ... data to create a Currency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Currency we want to update
     *   }
     * })
    **/
    upsert<T extends currencyUpsertArgs>(
      args: SelectSubset<T, currencyUpsertArgs>
    ): CheckSelect<T, Prisma__currencyClient<currency>, Prisma__currencyClient<currencyGetPayload<T>>>

    /**
     * Find one Currency that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {currencyFindUniqueOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends currencyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, currencyFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__currencyClient<currency>, Prisma__currencyClient<currencyGetPayload<T>>>

    /**
     * Find the first Currency that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currencyFindFirstOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends currencyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, currencyFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__currencyClient<currency>, Prisma__currencyClient<currencyGetPayload<T>>>

    /**
     * Count the number of Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currencyCountArgs} args - Arguments to filter Currencies to count.
     * @example
     * // Count the number of Currencies
     * const count = await prisma.currency.count({
     *   where: {
     *     // ... the filter for the Currencies we want to count
     *   }
     * })
    **/
    count<T extends currencyCountArgs>(
      args?: Subset<T, currencyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrencyAggregateArgs>(args: Subset<T, CurrencyAggregateArgs>): PrismaPromise<GetCurrencyAggregateType<T>>

    /**
     * Group by Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrencyGroupByArgs['orderBy'] }
        : { orderBy?: CurrencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrencyGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for currency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__currencyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    baseCurrency<T extends baseCurrencyFindManyArgs = {}>(args?: Subset<T, baseCurrencyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<baseCurrency>>, PrismaPromise<Array<baseCurrencyGetPayload<T>>>>;

    exchangeRates<T extends exchangeRatesFindManyArgs = {}>(args?: Subset<T, exchangeRatesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<exchangeRates>>, PrismaPromise<Array<exchangeRatesGetPayload<T>>>>;

    payments<T extends PaymentFindManyArgs = {}>(args?: Subset<T, PaymentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Payment>>, PrismaPromise<Array<PaymentGetPayload<T>>>>;

    tax<T extends TaxFindManyArgs = {}>(args?: Subset<T, TaxFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Tax>>, PrismaPromise<Array<TaxGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * currency base type for findUnique actions
   */
  export type currencyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the currency
     * 
    **/
    select?: currencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: currencyInclude | null
    /**
     * Filter, which currency to fetch.
     * 
    **/
    where: currencyWhereUniqueInput
  }

  /**
   * currency: findUnique
   */
  export interface currencyFindUniqueArgs extends currencyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * currency base type for findFirst actions
   */
  export type currencyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the currency
     * 
    **/
    select?: currencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: currencyInclude | null
    /**
     * Filter, which currency to fetch.
     * 
    **/
    where?: currencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of currencies to fetch.
     * 
    **/
    orderBy?: Enumerable<currencyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for currencies.
     * 
    **/
    cursor?: currencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` currencies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` currencies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of currencies.
     * 
    **/
    distinct?: Enumerable<CurrencyScalarFieldEnum>
  }

  /**
   * currency: findFirst
   */
  export interface currencyFindFirstArgs extends currencyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * currency findMany
   */
  export type currencyFindManyArgs = {
    /**
     * Select specific fields to fetch from the currency
     * 
    **/
    select?: currencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: currencyInclude | null
    /**
     * Filter, which currencies to fetch.
     * 
    **/
    where?: currencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of currencies to fetch.
     * 
    **/
    orderBy?: Enumerable<currencyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing currencies.
     * 
    **/
    cursor?: currencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` currencies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` currencies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CurrencyScalarFieldEnum>
  }


  /**
   * currency create
   */
  export type currencyCreateArgs = {
    /**
     * Select specific fields to fetch from the currency
     * 
    **/
    select?: currencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: currencyInclude | null
    /**
     * The data needed to create a currency.
     * 
    **/
    data: XOR<currencyCreateInput, currencyUncheckedCreateInput>
  }


  /**
   * currency createMany
   */
  export type currencyCreateManyArgs = {
    /**
     * The data used to create many currencies.
     * 
    **/
    data: Enumerable<currencyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * currency update
   */
  export type currencyUpdateArgs = {
    /**
     * Select specific fields to fetch from the currency
     * 
    **/
    select?: currencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: currencyInclude | null
    /**
     * The data needed to update a currency.
     * 
    **/
    data: XOR<currencyUpdateInput, currencyUncheckedUpdateInput>
    /**
     * Choose, which currency to update.
     * 
    **/
    where: currencyWhereUniqueInput
  }


  /**
   * currency updateMany
   */
  export type currencyUpdateManyArgs = {
    /**
     * The data used to update currencies.
     * 
    **/
    data: XOR<currencyUpdateManyMutationInput, currencyUncheckedUpdateManyInput>
    /**
     * Filter which currencies to update
     * 
    **/
    where?: currencyWhereInput
  }


  /**
   * currency upsert
   */
  export type currencyUpsertArgs = {
    /**
     * Select specific fields to fetch from the currency
     * 
    **/
    select?: currencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: currencyInclude | null
    /**
     * The filter to search for the currency to update in case it exists.
     * 
    **/
    where: currencyWhereUniqueInput
    /**
     * In case the currency found by the `where` argument doesn't exist, create a new currency with this data.
     * 
    **/
    create: XOR<currencyCreateInput, currencyUncheckedCreateInput>
    /**
     * In case the currency was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<currencyUpdateInput, currencyUncheckedUpdateInput>
  }


  /**
   * currency delete
   */
  export type currencyDeleteArgs = {
    /**
     * Select specific fields to fetch from the currency
     * 
    **/
    select?: currencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: currencyInclude | null
    /**
     * Filter which currency to delete.
     * 
    **/
    where: currencyWhereUniqueInput
  }


  /**
   * currency deleteMany
   */
  export type currencyDeleteManyArgs = {
    /**
     * Filter which currencies to delete
     * 
    **/
    where?: currencyWhereInput
  }


  /**
   * currency: findUniqueOrThrow
   */
  export type currencyFindUniqueOrThrowArgs = currencyFindUniqueArgsBase
      

  /**
   * currency: findFirstOrThrow
   */
  export type currencyFindFirstOrThrowArgs = currencyFindFirstArgsBase
      

  /**
   * currency without action
   */
  export type currencyArgs = {
    /**
     * Select specific fields to fetch from the currency
     * 
    **/
    select?: currencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: currencyInclude | null
  }



  /**
   * Model disposals
   */


  export type AggregateDisposals = {
    _count: DisposalsCountAggregateOutputType | null
    _min: DisposalsMinAggregateOutputType | null
    _max: DisposalsMaxAggregateOutputType | null
  }

  export type DisposalsMinAggregateOutputType = {
    id: string | null
    productId: string | null
    priceId: string | null
    createdAt: Date | null
  }

  export type DisposalsMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    priceId: string | null
    createdAt: Date | null
  }

  export type DisposalsCountAggregateOutputType = {
    id: number
    productId: number
    priceId: number
    createdAt: number
    _all: number
  }


  export type DisposalsMinAggregateInputType = {
    id?: true
    productId?: true
    priceId?: true
    createdAt?: true
  }

  export type DisposalsMaxAggregateInputType = {
    id?: true
    productId?: true
    priceId?: true
    createdAt?: true
  }

  export type DisposalsCountAggregateInputType = {
    id?: true
    productId?: true
    priceId?: true
    createdAt?: true
    _all?: true
  }

  export type DisposalsAggregateArgs = {
    /**
     * Filter which disposals to aggregate.
     * 
    **/
    where?: disposalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of disposals to fetch.
     * 
    **/
    orderBy?: Enumerable<disposalsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: disposalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` disposals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` disposals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned disposals
    **/
    _count?: true | DisposalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisposalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisposalsMaxAggregateInputType
  }

  export type GetDisposalsAggregateType<T extends DisposalsAggregateArgs> = {
        [P in keyof T & keyof AggregateDisposals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisposals[P]>
      : GetScalarType<T[P], AggregateDisposals[P]>
  }




  export type DisposalsGroupByArgs = {
    where?: disposalsWhereInput
    orderBy?: Enumerable<disposalsOrderByWithAggregationInput>
    by: Array<DisposalsScalarFieldEnum>
    having?: disposalsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisposalsCountAggregateInputType | true
    _min?: DisposalsMinAggregateInputType
    _max?: DisposalsMaxAggregateInputType
  }


  export type DisposalsGroupByOutputType = {
    id: string
    productId: string
    priceId: string
    createdAt: Date
    _count: DisposalsCountAggregateOutputType | null
    _min: DisposalsMinAggregateOutputType | null
    _max: DisposalsMaxAggregateOutputType | null
  }

  type GetDisposalsGroupByPayload<T extends DisposalsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DisposalsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisposalsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisposalsGroupByOutputType[P]>
            : GetScalarType<T[P], DisposalsGroupByOutputType[P]>
        }
      >
    >


  export type disposalsSelect = {
    id?: boolean
    productId?: boolean
    priceId?: boolean
    createdAt?: boolean
    prices?: boolean | PricesArgs
    products?: boolean | ProductArgs
  }

  export type disposalsInclude = {
    prices?: boolean | PricesArgs
    products?: boolean | ProductArgs
  }

  export type disposalsGetPayload<
    S extends boolean | null | undefined | disposalsArgs,
    U = keyof S
      > = S extends true
        ? disposals
    : S extends undefined
    ? never
    : S extends disposalsArgs | disposalsFindManyArgs
    ?'include' extends U
    ? disposals  & {
    [P in TrueKeys<S['include']>]:
        P extends 'prices' ? PricesGetPayload<S['include'][P]> :
        P extends 'products' ? ProductGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'prices' ? PricesGetPayload<S['select'][P]> :
        P extends 'products' ? ProductGetPayload<S['select'][P]> :  P extends keyof disposals ? disposals[P] : never
  } 
    : disposals
  : disposals


  type disposalsCountArgs = Merge<
    Omit<disposalsFindManyArgs, 'select' | 'include'> & {
      select?: DisposalsCountAggregateInputType | true
    }
  >

  export interface disposalsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Disposals that matches the filter.
     * @param {disposalsFindUniqueArgs} args - Arguments to find a Disposals
     * @example
     * // Get one Disposals
     * const disposals = await prisma.disposals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends disposalsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, disposalsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'disposals'> extends True ? CheckSelect<T, Prisma__disposalsClient<disposals>, Prisma__disposalsClient<disposalsGetPayload<T>>> : CheckSelect<T, Prisma__disposalsClient<disposals | null >, Prisma__disposalsClient<disposalsGetPayload<T> | null >>

    /**
     * Find the first Disposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disposalsFindFirstArgs} args - Arguments to find a Disposals
     * @example
     * // Get one Disposals
     * const disposals = await prisma.disposals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends disposalsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, disposalsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'disposals'> extends True ? CheckSelect<T, Prisma__disposalsClient<disposals>, Prisma__disposalsClient<disposalsGetPayload<T>>> : CheckSelect<T, Prisma__disposalsClient<disposals | null >, Prisma__disposalsClient<disposalsGetPayload<T> | null >>

    /**
     * Find zero or more Disposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disposalsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Disposals
     * const disposals = await prisma.disposals.findMany()
     * 
     * // Get first 10 Disposals
     * const disposals = await prisma.disposals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disposalsWithIdOnly = await prisma.disposals.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends disposalsFindManyArgs>(
      args?: SelectSubset<T, disposalsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<disposals>>, PrismaPromise<Array<disposalsGetPayload<T>>>>

    /**
     * Create a Disposals.
     * @param {disposalsCreateArgs} args - Arguments to create a Disposals.
     * @example
     * // Create one Disposals
     * const Disposals = await prisma.disposals.create({
     *   data: {
     *     // ... data to create a Disposals
     *   }
     * })
     * 
    **/
    create<T extends disposalsCreateArgs>(
      args: SelectSubset<T, disposalsCreateArgs>
    ): CheckSelect<T, Prisma__disposalsClient<disposals>, Prisma__disposalsClient<disposalsGetPayload<T>>>

    /**
     * Create many Disposals.
     *     @param {disposalsCreateManyArgs} args - Arguments to create many Disposals.
     *     @example
     *     // Create many Disposals
     *     const disposals = await prisma.disposals.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends disposalsCreateManyArgs>(
      args?: SelectSubset<T, disposalsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Disposals.
     * @param {disposalsDeleteArgs} args - Arguments to delete one Disposals.
     * @example
     * // Delete one Disposals
     * const Disposals = await prisma.disposals.delete({
     *   where: {
     *     // ... filter to delete one Disposals
     *   }
     * })
     * 
    **/
    delete<T extends disposalsDeleteArgs>(
      args: SelectSubset<T, disposalsDeleteArgs>
    ): CheckSelect<T, Prisma__disposalsClient<disposals>, Prisma__disposalsClient<disposalsGetPayload<T>>>

    /**
     * Update one Disposals.
     * @param {disposalsUpdateArgs} args - Arguments to update one Disposals.
     * @example
     * // Update one Disposals
     * const disposals = await prisma.disposals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends disposalsUpdateArgs>(
      args: SelectSubset<T, disposalsUpdateArgs>
    ): CheckSelect<T, Prisma__disposalsClient<disposals>, Prisma__disposalsClient<disposalsGetPayload<T>>>

    /**
     * Delete zero or more Disposals.
     * @param {disposalsDeleteManyArgs} args - Arguments to filter Disposals to delete.
     * @example
     * // Delete a few Disposals
     * const { count } = await prisma.disposals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends disposalsDeleteManyArgs>(
      args?: SelectSubset<T, disposalsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Disposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disposalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Disposals
     * const disposals = await prisma.disposals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends disposalsUpdateManyArgs>(
      args: SelectSubset<T, disposalsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Disposals.
     * @param {disposalsUpsertArgs} args - Arguments to update or create a Disposals.
     * @example
     * // Update or create a Disposals
     * const disposals = await prisma.disposals.upsert({
     *   create: {
     *     // ... data to create a Disposals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Disposals we want to update
     *   }
     * })
    **/
    upsert<T extends disposalsUpsertArgs>(
      args: SelectSubset<T, disposalsUpsertArgs>
    ): CheckSelect<T, Prisma__disposalsClient<disposals>, Prisma__disposalsClient<disposalsGetPayload<T>>>

    /**
     * Find one Disposals that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {disposalsFindUniqueOrThrowArgs} args - Arguments to find a Disposals
     * @example
     * // Get one Disposals
     * const disposals = await prisma.disposals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends disposalsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, disposalsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__disposalsClient<disposals>, Prisma__disposalsClient<disposalsGetPayload<T>>>

    /**
     * Find the first Disposals that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disposalsFindFirstOrThrowArgs} args - Arguments to find a Disposals
     * @example
     * // Get one Disposals
     * const disposals = await prisma.disposals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends disposalsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, disposalsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__disposalsClient<disposals>, Prisma__disposalsClient<disposalsGetPayload<T>>>

    /**
     * Count the number of Disposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disposalsCountArgs} args - Arguments to filter Disposals to count.
     * @example
     * // Count the number of Disposals
     * const count = await prisma.disposals.count({
     *   where: {
     *     // ... the filter for the Disposals we want to count
     *   }
     * })
    **/
    count<T extends disposalsCountArgs>(
      args?: Subset<T, disposalsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisposalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Disposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisposalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisposalsAggregateArgs>(args: Subset<T, DisposalsAggregateArgs>): PrismaPromise<GetDisposalsAggregateType<T>>

    /**
     * Group by Disposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisposalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisposalsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisposalsGroupByArgs['orderBy'] }
        : { orderBy?: DisposalsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisposalsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisposalsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for disposals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__disposalsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    prices<T extends PricesArgs = {}>(args?: Subset<T, PricesArgs>): CheckSelect<T, Prisma__PricesClient<Prices | null >, Prisma__PricesClient<PricesGetPayload<T> | null >>;

    products<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * disposals base type for findUnique actions
   */
  export type disposalsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the disposals
     * 
    **/
    select?: disposalsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: disposalsInclude | null
    /**
     * Filter, which disposals to fetch.
     * 
    **/
    where: disposalsWhereUniqueInput
  }

  /**
   * disposals: findUnique
   */
  export interface disposalsFindUniqueArgs extends disposalsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * disposals base type for findFirst actions
   */
  export type disposalsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the disposals
     * 
    **/
    select?: disposalsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: disposalsInclude | null
    /**
     * Filter, which disposals to fetch.
     * 
    **/
    where?: disposalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of disposals to fetch.
     * 
    **/
    orderBy?: Enumerable<disposalsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for disposals.
     * 
    **/
    cursor?: disposalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` disposals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` disposals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of disposals.
     * 
    **/
    distinct?: Enumerable<DisposalsScalarFieldEnum>
  }

  /**
   * disposals: findFirst
   */
  export interface disposalsFindFirstArgs extends disposalsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * disposals findMany
   */
  export type disposalsFindManyArgs = {
    /**
     * Select specific fields to fetch from the disposals
     * 
    **/
    select?: disposalsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: disposalsInclude | null
    /**
     * Filter, which disposals to fetch.
     * 
    **/
    where?: disposalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of disposals to fetch.
     * 
    **/
    orderBy?: Enumerable<disposalsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing disposals.
     * 
    **/
    cursor?: disposalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` disposals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` disposals.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DisposalsScalarFieldEnum>
  }


  /**
   * disposals create
   */
  export type disposalsCreateArgs = {
    /**
     * Select specific fields to fetch from the disposals
     * 
    **/
    select?: disposalsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: disposalsInclude | null
    /**
     * The data needed to create a disposals.
     * 
    **/
    data: XOR<disposalsCreateInput, disposalsUncheckedCreateInput>
  }


  /**
   * disposals createMany
   */
  export type disposalsCreateManyArgs = {
    /**
     * The data used to create many disposals.
     * 
    **/
    data: Enumerable<disposalsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * disposals update
   */
  export type disposalsUpdateArgs = {
    /**
     * Select specific fields to fetch from the disposals
     * 
    **/
    select?: disposalsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: disposalsInclude | null
    /**
     * The data needed to update a disposals.
     * 
    **/
    data: XOR<disposalsUpdateInput, disposalsUncheckedUpdateInput>
    /**
     * Choose, which disposals to update.
     * 
    **/
    where: disposalsWhereUniqueInput
  }


  /**
   * disposals updateMany
   */
  export type disposalsUpdateManyArgs = {
    /**
     * The data used to update disposals.
     * 
    **/
    data: XOR<disposalsUpdateManyMutationInput, disposalsUncheckedUpdateManyInput>
    /**
     * Filter which disposals to update
     * 
    **/
    where?: disposalsWhereInput
  }


  /**
   * disposals upsert
   */
  export type disposalsUpsertArgs = {
    /**
     * Select specific fields to fetch from the disposals
     * 
    **/
    select?: disposalsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: disposalsInclude | null
    /**
     * The filter to search for the disposals to update in case it exists.
     * 
    **/
    where: disposalsWhereUniqueInput
    /**
     * In case the disposals found by the `where` argument doesn't exist, create a new disposals with this data.
     * 
    **/
    create: XOR<disposalsCreateInput, disposalsUncheckedCreateInput>
    /**
     * In case the disposals was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<disposalsUpdateInput, disposalsUncheckedUpdateInput>
  }


  /**
   * disposals delete
   */
  export type disposalsDeleteArgs = {
    /**
     * Select specific fields to fetch from the disposals
     * 
    **/
    select?: disposalsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: disposalsInclude | null
    /**
     * Filter which disposals to delete.
     * 
    **/
    where: disposalsWhereUniqueInput
  }


  /**
   * disposals deleteMany
   */
  export type disposalsDeleteManyArgs = {
    /**
     * Filter which disposals to delete
     * 
    **/
    where?: disposalsWhereInput
  }


  /**
   * disposals: findUniqueOrThrow
   */
  export type disposalsFindUniqueOrThrowArgs = disposalsFindUniqueArgsBase
      

  /**
   * disposals: findFirstOrThrow
   */
  export type disposalsFindFirstOrThrowArgs = disposalsFindFirstArgsBase
      

  /**
   * disposals without action
   */
  export type disposalsArgs = {
    /**
     * Select specific fields to fetch from the disposals
     * 
    **/
    select?: disposalsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: disposalsInclude | null
  }



  /**
   * Model exchangeRates
   */


  export type AggregateExchangeRates = {
    _count: ExchangeRatesCountAggregateOutputType | null
    _avg: ExchangeRatesAvgAggregateOutputType | null
    _sum: ExchangeRatesSumAggregateOutputType | null
    _min: ExchangeRatesMinAggregateOutputType | null
    _max: ExchangeRatesMaxAggregateOutputType | null
  }

  export type ExchangeRatesAvgAggregateOutputType = {
    exchangeRate: Decimal | null
  }

  export type ExchangeRatesSumAggregateOutputType = {
    exchangeRate: Decimal | null
  }

  export type ExchangeRatesMinAggregateOutputType = {
    id: string | null
    exchangeRate: Decimal | null
    currencyId: string | null
    createdAt: Date | null
    baseCurrencyId: string | null
    active: boolean | null
  }

  export type ExchangeRatesMaxAggregateOutputType = {
    id: string | null
    exchangeRate: Decimal | null
    currencyId: string | null
    createdAt: Date | null
    baseCurrencyId: string | null
    active: boolean | null
  }

  export type ExchangeRatesCountAggregateOutputType = {
    id: number
    exchangeRate: number
    currencyId: number
    createdAt: number
    baseCurrencyId: number
    active: number
    _all: number
  }


  export type ExchangeRatesAvgAggregateInputType = {
    exchangeRate?: true
  }

  export type ExchangeRatesSumAggregateInputType = {
    exchangeRate?: true
  }

  export type ExchangeRatesMinAggregateInputType = {
    id?: true
    exchangeRate?: true
    currencyId?: true
    createdAt?: true
    baseCurrencyId?: true
    active?: true
  }

  export type ExchangeRatesMaxAggregateInputType = {
    id?: true
    exchangeRate?: true
    currencyId?: true
    createdAt?: true
    baseCurrencyId?: true
    active?: true
  }

  export type ExchangeRatesCountAggregateInputType = {
    id?: true
    exchangeRate?: true
    currencyId?: true
    createdAt?: true
    baseCurrencyId?: true
    active?: true
    _all?: true
  }

  export type ExchangeRatesAggregateArgs = {
    /**
     * Filter which exchangeRates to aggregate.
     * 
    **/
    where?: exchangeRatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exchangeRates to fetch.
     * 
    **/
    orderBy?: Enumerable<exchangeRatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: exchangeRatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exchangeRates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exchangeRates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned exchangeRates
    **/
    _count?: true | ExchangeRatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExchangeRatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExchangeRatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExchangeRatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExchangeRatesMaxAggregateInputType
  }

  export type GetExchangeRatesAggregateType<T extends ExchangeRatesAggregateArgs> = {
        [P in keyof T & keyof AggregateExchangeRates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExchangeRates[P]>
      : GetScalarType<T[P], AggregateExchangeRates[P]>
  }




  export type ExchangeRatesGroupByArgs = {
    where?: exchangeRatesWhereInput
    orderBy?: Enumerable<exchangeRatesOrderByWithAggregationInput>
    by: Array<ExchangeRatesScalarFieldEnum>
    having?: exchangeRatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExchangeRatesCountAggregateInputType | true
    _avg?: ExchangeRatesAvgAggregateInputType
    _sum?: ExchangeRatesSumAggregateInputType
    _min?: ExchangeRatesMinAggregateInputType
    _max?: ExchangeRatesMaxAggregateInputType
  }


  export type ExchangeRatesGroupByOutputType = {
    id: string
    exchangeRate: Decimal
    currencyId: string
    createdAt: Date
    baseCurrencyId: string
    active: boolean
    _count: ExchangeRatesCountAggregateOutputType | null
    _avg: ExchangeRatesAvgAggregateOutputType | null
    _sum: ExchangeRatesSumAggregateOutputType | null
    _min: ExchangeRatesMinAggregateOutputType | null
    _max: ExchangeRatesMaxAggregateOutputType | null
  }

  type GetExchangeRatesGroupByPayload<T extends ExchangeRatesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ExchangeRatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExchangeRatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExchangeRatesGroupByOutputType[P]>
            : GetScalarType<T[P], ExchangeRatesGroupByOutputType[P]>
        }
      >
    >


  export type exchangeRatesSelect = {
    id?: boolean
    exchangeRate?: boolean
    currencyId?: boolean
    createdAt?: boolean
    baseCurrencyId?: boolean
    active?: boolean
    baseCurrency?: boolean | baseCurrencyArgs
    currency?: boolean | currencyArgs
    payments?: boolean | PaymentFindManyArgs
    prices?: boolean | PricesFindManyArgs
    _count?: boolean | ExchangeRatesCountOutputTypeArgs
  }

  export type exchangeRatesInclude = {
    baseCurrency?: boolean | baseCurrencyArgs
    currency?: boolean | currencyArgs
    payments?: boolean | PaymentFindManyArgs
    prices?: boolean | PricesFindManyArgs
    _count?: boolean | ExchangeRatesCountOutputTypeArgs
  }

  export type exchangeRatesGetPayload<
    S extends boolean | null | undefined | exchangeRatesArgs,
    U = keyof S
      > = S extends true
        ? exchangeRates
    : S extends undefined
    ? never
    : S extends exchangeRatesArgs | exchangeRatesFindManyArgs
    ?'include' extends U
    ? exchangeRates  & {
    [P in TrueKeys<S['include']>]:
        P extends 'baseCurrency' ? baseCurrencyGetPayload<S['include'][P]> :
        P extends 'currency' ? currencyGetPayload<S['include'][P]> :
        P extends 'payments' ? Array < PaymentGetPayload<S['include'][P]>>  :
        P extends 'prices' ? Array < PricesGetPayload<S['include'][P]>>  :
        P extends '_count' ? ExchangeRatesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'baseCurrency' ? baseCurrencyGetPayload<S['select'][P]> :
        P extends 'currency' ? currencyGetPayload<S['select'][P]> :
        P extends 'payments' ? Array < PaymentGetPayload<S['select'][P]>>  :
        P extends 'prices' ? Array < PricesGetPayload<S['select'][P]>>  :
        P extends '_count' ? ExchangeRatesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof exchangeRates ? exchangeRates[P] : never
  } 
    : exchangeRates
  : exchangeRates


  type exchangeRatesCountArgs = Merge<
    Omit<exchangeRatesFindManyArgs, 'select' | 'include'> & {
      select?: ExchangeRatesCountAggregateInputType | true
    }
  >

  export interface exchangeRatesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ExchangeRates that matches the filter.
     * @param {exchangeRatesFindUniqueArgs} args - Arguments to find a ExchangeRates
     * @example
     * // Get one ExchangeRates
     * const exchangeRates = await prisma.exchangeRates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends exchangeRatesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, exchangeRatesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'exchangeRates'> extends True ? CheckSelect<T, Prisma__exchangeRatesClient<exchangeRates>, Prisma__exchangeRatesClient<exchangeRatesGetPayload<T>>> : CheckSelect<T, Prisma__exchangeRatesClient<exchangeRates | null >, Prisma__exchangeRatesClient<exchangeRatesGetPayload<T> | null >>

    /**
     * Find the first ExchangeRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchangeRatesFindFirstArgs} args - Arguments to find a ExchangeRates
     * @example
     * // Get one ExchangeRates
     * const exchangeRates = await prisma.exchangeRates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends exchangeRatesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, exchangeRatesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'exchangeRates'> extends True ? CheckSelect<T, Prisma__exchangeRatesClient<exchangeRates>, Prisma__exchangeRatesClient<exchangeRatesGetPayload<T>>> : CheckSelect<T, Prisma__exchangeRatesClient<exchangeRates | null >, Prisma__exchangeRatesClient<exchangeRatesGetPayload<T> | null >>

    /**
     * Find zero or more ExchangeRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchangeRatesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExchangeRates
     * const exchangeRates = await prisma.exchangeRates.findMany()
     * 
     * // Get first 10 ExchangeRates
     * const exchangeRates = await prisma.exchangeRates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exchangeRatesWithIdOnly = await prisma.exchangeRates.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends exchangeRatesFindManyArgs>(
      args?: SelectSubset<T, exchangeRatesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<exchangeRates>>, PrismaPromise<Array<exchangeRatesGetPayload<T>>>>

    /**
     * Create a ExchangeRates.
     * @param {exchangeRatesCreateArgs} args - Arguments to create a ExchangeRates.
     * @example
     * // Create one ExchangeRates
     * const ExchangeRates = await prisma.exchangeRates.create({
     *   data: {
     *     // ... data to create a ExchangeRates
     *   }
     * })
     * 
    **/
    create<T extends exchangeRatesCreateArgs>(
      args: SelectSubset<T, exchangeRatesCreateArgs>
    ): CheckSelect<T, Prisma__exchangeRatesClient<exchangeRates>, Prisma__exchangeRatesClient<exchangeRatesGetPayload<T>>>

    /**
     * Create many ExchangeRates.
     *     @param {exchangeRatesCreateManyArgs} args - Arguments to create many ExchangeRates.
     *     @example
     *     // Create many ExchangeRates
     *     const exchangeRates = await prisma.exchangeRates.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends exchangeRatesCreateManyArgs>(
      args?: SelectSubset<T, exchangeRatesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ExchangeRates.
     * @param {exchangeRatesDeleteArgs} args - Arguments to delete one ExchangeRates.
     * @example
     * // Delete one ExchangeRates
     * const ExchangeRates = await prisma.exchangeRates.delete({
     *   where: {
     *     // ... filter to delete one ExchangeRates
     *   }
     * })
     * 
    **/
    delete<T extends exchangeRatesDeleteArgs>(
      args: SelectSubset<T, exchangeRatesDeleteArgs>
    ): CheckSelect<T, Prisma__exchangeRatesClient<exchangeRates>, Prisma__exchangeRatesClient<exchangeRatesGetPayload<T>>>

    /**
     * Update one ExchangeRates.
     * @param {exchangeRatesUpdateArgs} args - Arguments to update one ExchangeRates.
     * @example
     * // Update one ExchangeRates
     * const exchangeRates = await prisma.exchangeRates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends exchangeRatesUpdateArgs>(
      args: SelectSubset<T, exchangeRatesUpdateArgs>
    ): CheckSelect<T, Prisma__exchangeRatesClient<exchangeRates>, Prisma__exchangeRatesClient<exchangeRatesGetPayload<T>>>

    /**
     * Delete zero or more ExchangeRates.
     * @param {exchangeRatesDeleteManyArgs} args - Arguments to filter ExchangeRates to delete.
     * @example
     * // Delete a few ExchangeRates
     * const { count } = await prisma.exchangeRates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends exchangeRatesDeleteManyArgs>(
      args?: SelectSubset<T, exchangeRatesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExchangeRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchangeRatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExchangeRates
     * const exchangeRates = await prisma.exchangeRates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends exchangeRatesUpdateManyArgs>(
      args: SelectSubset<T, exchangeRatesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ExchangeRates.
     * @param {exchangeRatesUpsertArgs} args - Arguments to update or create a ExchangeRates.
     * @example
     * // Update or create a ExchangeRates
     * const exchangeRates = await prisma.exchangeRates.upsert({
     *   create: {
     *     // ... data to create a ExchangeRates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExchangeRates we want to update
     *   }
     * })
    **/
    upsert<T extends exchangeRatesUpsertArgs>(
      args: SelectSubset<T, exchangeRatesUpsertArgs>
    ): CheckSelect<T, Prisma__exchangeRatesClient<exchangeRates>, Prisma__exchangeRatesClient<exchangeRatesGetPayload<T>>>

    /**
     * Find one ExchangeRates that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {exchangeRatesFindUniqueOrThrowArgs} args - Arguments to find a ExchangeRates
     * @example
     * // Get one ExchangeRates
     * const exchangeRates = await prisma.exchangeRates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends exchangeRatesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, exchangeRatesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__exchangeRatesClient<exchangeRates>, Prisma__exchangeRatesClient<exchangeRatesGetPayload<T>>>

    /**
     * Find the first ExchangeRates that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchangeRatesFindFirstOrThrowArgs} args - Arguments to find a ExchangeRates
     * @example
     * // Get one ExchangeRates
     * const exchangeRates = await prisma.exchangeRates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends exchangeRatesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, exchangeRatesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__exchangeRatesClient<exchangeRates>, Prisma__exchangeRatesClient<exchangeRatesGetPayload<T>>>

    /**
     * Count the number of ExchangeRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchangeRatesCountArgs} args - Arguments to filter ExchangeRates to count.
     * @example
     * // Count the number of ExchangeRates
     * const count = await prisma.exchangeRates.count({
     *   where: {
     *     // ... the filter for the ExchangeRates we want to count
     *   }
     * })
    **/
    count<T extends exchangeRatesCountArgs>(
      args?: Subset<T, exchangeRatesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExchangeRatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExchangeRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExchangeRatesAggregateArgs>(args: Subset<T, ExchangeRatesAggregateArgs>): PrismaPromise<GetExchangeRatesAggregateType<T>>

    /**
     * Group by ExchangeRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExchangeRatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExchangeRatesGroupByArgs['orderBy'] }
        : { orderBy?: ExchangeRatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExchangeRatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExchangeRatesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for exchangeRates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__exchangeRatesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    baseCurrency<T extends baseCurrencyArgs = {}>(args?: Subset<T, baseCurrencyArgs>): CheckSelect<T, Prisma__baseCurrencyClient<baseCurrency | null >, Prisma__baseCurrencyClient<baseCurrencyGetPayload<T> | null >>;

    currency<T extends currencyArgs = {}>(args?: Subset<T, currencyArgs>): CheckSelect<T, Prisma__currencyClient<currency | null >, Prisma__currencyClient<currencyGetPayload<T> | null >>;

    payments<T extends PaymentFindManyArgs = {}>(args?: Subset<T, PaymentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Payment>>, PrismaPromise<Array<PaymentGetPayload<T>>>>;

    prices<T extends PricesFindManyArgs = {}>(args?: Subset<T, PricesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Prices>>, PrismaPromise<Array<PricesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * exchangeRates base type for findUnique actions
   */
  export type exchangeRatesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the exchangeRates
     * 
    **/
    select?: exchangeRatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchangeRatesInclude | null
    /**
     * Filter, which exchangeRates to fetch.
     * 
    **/
    where: exchangeRatesWhereUniqueInput
  }

  /**
   * exchangeRates: findUnique
   */
  export interface exchangeRatesFindUniqueArgs extends exchangeRatesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * exchangeRates base type for findFirst actions
   */
  export type exchangeRatesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the exchangeRates
     * 
    **/
    select?: exchangeRatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchangeRatesInclude | null
    /**
     * Filter, which exchangeRates to fetch.
     * 
    **/
    where?: exchangeRatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exchangeRates to fetch.
     * 
    **/
    orderBy?: Enumerable<exchangeRatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exchangeRates.
     * 
    **/
    cursor?: exchangeRatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exchangeRates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exchangeRates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exchangeRates.
     * 
    **/
    distinct?: Enumerable<ExchangeRatesScalarFieldEnum>
  }

  /**
   * exchangeRates: findFirst
   */
  export interface exchangeRatesFindFirstArgs extends exchangeRatesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * exchangeRates findMany
   */
  export type exchangeRatesFindManyArgs = {
    /**
     * Select specific fields to fetch from the exchangeRates
     * 
    **/
    select?: exchangeRatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchangeRatesInclude | null
    /**
     * Filter, which exchangeRates to fetch.
     * 
    **/
    where?: exchangeRatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exchangeRates to fetch.
     * 
    **/
    orderBy?: Enumerable<exchangeRatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing exchangeRates.
     * 
    **/
    cursor?: exchangeRatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exchangeRates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exchangeRates.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ExchangeRatesScalarFieldEnum>
  }


  /**
   * exchangeRates create
   */
  export type exchangeRatesCreateArgs = {
    /**
     * Select specific fields to fetch from the exchangeRates
     * 
    **/
    select?: exchangeRatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchangeRatesInclude | null
    /**
     * The data needed to create a exchangeRates.
     * 
    **/
    data: XOR<exchangeRatesCreateInput, exchangeRatesUncheckedCreateInput>
  }


  /**
   * exchangeRates createMany
   */
  export type exchangeRatesCreateManyArgs = {
    /**
     * The data used to create many exchangeRates.
     * 
    **/
    data: Enumerable<exchangeRatesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * exchangeRates update
   */
  export type exchangeRatesUpdateArgs = {
    /**
     * Select specific fields to fetch from the exchangeRates
     * 
    **/
    select?: exchangeRatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchangeRatesInclude | null
    /**
     * The data needed to update a exchangeRates.
     * 
    **/
    data: XOR<exchangeRatesUpdateInput, exchangeRatesUncheckedUpdateInput>
    /**
     * Choose, which exchangeRates to update.
     * 
    **/
    where: exchangeRatesWhereUniqueInput
  }


  /**
   * exchangeRates updateMany
   */
  export type exchangeRatesUpdateManyArgs = {
    /**
     * The data used to update exchangeRates.
     * 
    **/
    data: XOR<exchangeRatesUpdateManyMutationInput, exchangeRatesUncheckedUpdateManyInput>
    /**
     * Filter which exchangeRates to update
     * 
    **/
    where?: exchangeRatesWhereInput
  }


  /**
   * exchangeRates upsert
   */
  export type exchangeRatesUpsertArgs = {
    /**
     * Select specific fields to fetch from the exchangeRates
     * 
    **/
    select?: exchangeRatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchangeRatesInclude | null
    /**
     * The filter to search for the exchangeRates to update in case it exists.
     * 
    **/
    where: exchangeRatesWhereUniqueInput
    /**
     * In case the exchangeRates found by the `where` argument doesn't exist, create a new exchangeRates with this data.
     * 
    **/
    create: XOR<exchangeRatesCreateInput, exchangeRatesUncheckedCreateInput>
    /**
     * In case the exchangeRates was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<exchangeRatesUpdateInput, exchangeRatesUncheckedUpdateInput>
  }


  /**
   * exchangeRates delete
   */
  export type exchangeRatesDeleteArgs = {
    /**
     * Select specific fields to fetch from the exchangeRates
     * 
    **/
    select?: exchangeRatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchangeRatesInclude | null
    /**
     * Filter which exchangeRates to delete.
     * 
    **/
    where: exchangeRatesWhereUniqueInput
  }


  /**
   * exchangeRates deleteMany
   */
  export type exchangeRatesDeleteManyArgs = {
    /**
     * Filter which exchangeRates to delete
     * 
    **/
    where?: exchangeRatesWhereInput
  }


  /**
   * exchangeRates: findUniqueOrThrow
   */
  export type exchangeRatesFindUniqueOrThrowArgs = exchangeRatesFindUniqueArgsBase
      

  /**
   * exchangeRates: findFirstOrThrow
   */
  export type exchangeRatesFindFirstOrThrowArgs = exchangeRatesFindFirstArgsBase
      

  /**
   * exchangeRates without action
   */
  export type exchangeRatesArgs = {
    /**
     * Select specific fields to fetch from the exchangeRates
     * 
    **/
    select?: exchangeRatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchangeRatesInclude | null
  }



  /**
   * Model Journal
   */


  export type AggregateJournal = {
    _count: JournalCountAggregateOutputType | null
    _avg: JournalAvgAggregateOutputType | null
    _sum: JournalSumAggregateOutputType | null
    _min: JournalMinAggregateOutputType | null
    _max: JournalMaxAggregateOutputType | null
  }

  export type JournalAvgAggregateOutputType = {
    recorderId: number | null
    transactionId: number | null
    amount: Decimal | null
  }

  export type JournalSumAggregateOutputType = {
    recorderId: number | null
    transactionId: number | null
    amount: Decimal | null
  }

  export type JournalMinAggregateOutputType = {
    id: string | null
    recorderId: number | null
    supplierId: string | null
    customerId: string | null
    transactionId: number | null
    narration: string | null
    amount: Decimal | null
  }

  export type JournalMaxAggregateOutputType = {
    id: string | null
    recorderId: number | null
    supplierId: string | null
    customerId: string | null
    transactionId: number | null
    narration: string | null
    amount: Decimal | null
  }

  export type JournalCountAggregateOutputType = {
    id: number
    recorderId: number
    supplierId: number
    customerId: number
    transactionId: number
    narration: number
    amount: number
    _all: number
  }


  export type JournalAvgAggregateInputType = {
    recorderId?: true
    transactionId?: true
    amount?: true
  }

  export type JournalSumAggregateInputType = {
    recorderId?: true
    transactionId?: true
    amount?: true
  }

  export type JournalMinAggregateInputType = {
    id?: true
    recorderId?: true
    supplierId?: true
    customerId?: true
    transactionId?: true
    narration?: true
    amount?: true
  }

  export type JournalMaxAggregateInputType = {
    id?: true
    recorderId?: true
    supplierId?: true
    customerId?: true
    transactionId?: true
    narration?: true
    amount?: true
  }

  export type JournalCountAggregateInputType = {
    id?: true
    recorderId?: true
    supplierId?: true
    customerId?: true
    transactionId?: true
    narration?: true
    amount?: true
    _all?: true
  }

  export type JournalAggregateArgs = {
    /**
     * Filter which Journal to aggregate.
     * 
    **/
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     * 
    **/
    orderBy?: Enumerable<JournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Journals
    **/
    _count?: true | JournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalMaxAggregateInputType
  }

  export type GetJournalAggregateType<T extends JournalAggregateArgs> = {
        [P in keyof T & keyof AggregateJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournal[P]>
      : GetScalarType<T[P], AggregateJournal[P]>
  }




  export type JournalGroupByArgs = {
    where?: JournalWhereInput
    orderBy?: Enumerable<JournalOrderByWithAggregationInput>
    by: Array<JournalScalarFieldEnum>
    having?: JournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalCountAggregateInputType | true
    _avg?: JournalAvgAggregateInputType
    _sum?: JournalSumAggregateInputType
    _min?: JournalMinAggregateInputType
    _max?: JournalMaxAggregateInputType
  }


  export type JournalGroupByOutputType = {
    id: string
    recorderId: number
    supplierId: string | null
    customerId: string | null
    transactionId: number
    narration: string
    amount: Decimal
    _count: JournalCountAggregateOutputType | null
    _avg: JournalAvgAggregateOutputType | null
    _sum: JournalSumAggregateOutputType | null
    _min: JournalMinAggregateOutputType | null
    _max: JournalMaxAggregateOutputType | null
  }

  type GetJournalGroupByPayload<T extends JournalGroupByArgs> = PrismaPromise<
    Array<
      PickArray<JournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalGroupByOutputType[P]>
            : GetScalarType<T[P], JournalGroupByOutputType[P]>
        }
      >
    >


  export type JournalSelect = {
    id?: boolean
    recorder?: boolean | UserArgs
    recorderId?: boolean
    supplier?: boolean | SupplierArgs
    supplierId?: boolean
    customer?: boolean | CustomerArgs
    customerId?: boolean
    transaction?: boolean | TransactionArgs
    transactionId?: boolean
    narration?: boolean
    amount?: boolean
  }

  export type JournalInclude = {
    recorder?: boolean | UserArgs
    supplier?: boolean | SupplierArgs
    customer?: boolean | CustomerArgs
    transaction?: boolean | TransactionArgs
  }

  export type JournalGetPayload<
    S extends boolean | null | undefined | JournalArgs,
    U = keyof S
      > = S extends true
        ? Journal
    : S extends undefined
    ? never
    : S extends JournalArgs | JournalFindManyArgs
    ?'include' extends U
    ? Journal  & {
    [P in TrueKeys<S['include']>]:
        P extends 'recorder' ? UserGetPayload<S['include'][P]> :
        P extends 'supplier' ? SupplierGetPayload<S['include'][P]> | null :
        P extends 'customer' ? CustomerGetPayload<S['include'][P]> | null :
        P extends 'transaction' ? TransactionGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'recorder' ? UserGetPayload<S['select'][P]> :
        P extends 'supplier' ? SupplierGetPayload<S['select'][P]> | null :
        P extends 'customer' ? CustomerGetPayload<S['select'][P]> | null :
        P extends 'transaction' ? TransactionGetPayload<S['select'][P]> :  P extends keyof Journal ? Journal[P] : never
  } 
    : Journal
  : Journal


  type JournalCountArgs = Merge<
    Omit<JournalFindManyArgs, 'select' | 'include'> & {
      select?: JournalCountAggregateInputType | true
    }
  >

  export interface JournalDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Journal that matches the filter.
     * @param {JournalFindUniqueArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JournalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, JournalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Journal'> extends True ? CheckSelect<T, Prisma__JournalClient<Journal>, Prisma__JournalClient<JournalGetPayload<T>>> : CheckSelect<T, Prisma__JournalClient<Journal | null >, Prisma__JournalClient<JournalGetPayload<T> | null >>

    /**
     * Find the first Journal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindFirstArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JournalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, JournalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Journal'> extends True ? CheckSelect<T, Prisma__JournalClient<Journal>, Prisma__JournalClient<JournalGetPayload<T>>> : CheckSelect<T, Prisma__JournalClient<Journal | null >, Prisma__JournalClient<JournalGetPayload<T> | null >>

    /**
     * Find zero or more Journals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Journals
     * const journals = await prisma.journal.findMany()
     * 
     * // Get first 10 Journals
     * const journals = await prisma.journal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalWithIdOnly = await prisma.journal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends JournalFindManyArgs>(
      args?: SelectSubset<T, JournalFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Journal>>, PrismaPromise<Array<JournalGetPayload<T>>>>

    /**
     * Create a Journal.
     * @param {JournalCreateArgs} args - Arguments to create a Journal.
     * @example
     * // Create one Journal
     * const Journal = await prisma.journal.create({
     *   data: {
     *     // ... data to create a Journal
     *   }
     * })
     * 
    **/
    create<T extends JournalCreateArgs>(
      args: SelectSubset<T, JournalCreateArgs>
    ): CheckSelect<T, Prisma__JournalClient<Journal>, Prisma__JournalClient<JournalGetPayload<T>>>

    /**
     * Create many Journals.
     *     @param {JournalCreateManyArgs} args - Arguments to create many Journals.
     *     @example
     *     // Create many Journals
     *     const journal = await prisma.journal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JournalCreateManyArgs>(
      args?: SelectSubset<T, JournalCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Journal.
     * @param {JournalDeleteArgs} args - Arguments to delete one Journal.
     * @example
     * // Delete one Journal
     * const Journal = await prisma.journal.delete({
     *   where: {
     *     // ... filter to delete one Journal
     *   }
     * })
     * 
    **/
    delete<T extends JournalDeleteArgs>(
      args: SelectSubset<T, JournalDeleteArgs>
    ): CheckSelect<T, Prisma__JournalClient<Journal>, Prisma__JournalClient<JournalGetPayload<T>>>

    /**
     * Update one Journal.
     * @param {JournalUpdateArgs} args - Arguments to update one Journal.
     * @example
     * // Update one Journal
     * const journal = await prisma.journal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JournalUpdateArgs>(
      args: SelectSubset<T, JournalUpdateArgs>
    ): CheckSelect<T, Prisma__JournalClient<Journal>, Prisma__JournalClient<JournalGetPayload<T>>>

    /**
     * Delete zero or more Journals.
     * @param {JournalDeleteManyArgs} args - Arguments to filter Journals to delete.
     * @example
     * // Delete a few Journals
     * const { count } = await prisma.journal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JournalDeleteManyArgs>(
      args?: SelectSubset<T, JournalDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Journals
     * const journal = await prisma.journal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JournalUpdateManyArgs>(
      args: SelectSubset<T, JournalUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Journal.
     * @param {JournalUpsertArgs} args - Arguments to update or create a Journal.
     * @example
     * // Update or create a Journal
     * const journal = await prisma.journal.upsert({
     *   create: {
     *     // ... data to create a Journal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Journal we want to update
     *   }
     * })
    **/
    upsert<T extends JournalUpsertArgs>(
      args: SelectSubset<T, JournalUpsertArgs>
    ): CheckSelect<T, Prisma__JournalClient<Journal>, Prisma__JournalClient<JournalGetPayload<T>>>

    /**
     * Find one Journal that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {JournalFindUniqueOrThrowArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JournalFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, JournalFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__JournalClient<Journal>, Prisma__JournalClient<JournalGetPayload<T>>>

    /**
     * Find the first Journal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindFirstOrThrowArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JournalFindFirstOrThrowArgs>(
      args?: SelectSubset<T, JournalFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__JournalClient<Journal>, Prisma__JournalClient<JournalGetPayload<T>>>

    /**
     * Count the number of Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCountArgs} args - Arguments to filter Journals to count.
     * @example
     * // Count the number of Journals
     * const count = await prisma.journal.count({
     *   where: {
     *     // ... the filter for the Journals we want to count
     *   }
     * })
    **/
    count<T extends JournalCountArgs>(
      args?: Subset<T, JournalCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Journal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalAggregateArgs>(args: Subset<T, JournalAggregateArgs>): PrismaPromise<GetJournalAggregateType<T>>

    /**
     * Group by Journal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalGroupByArgs['orderBy'] }
        : { orderBy?: JournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Journal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__JournalClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    recorder<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    supplier<T extends SupplierArgs = {}>(args?: Subset<T, SupplierArgs>): CheckSelect<T, Prisma__SupplierClient<Supplier | null >, Prisma__SupplierClient<SupplierGetPayload<T> | null >>;

    customer<T extends CustomerArgs = {}>(args?: Subset<T, CustomerArgs>): CheckSelect<T, Prisma__CustomerClient<Customer | null >, Prisma__CustomerClient<CustomerGetPayload<T> | null >>;

    transaction<T extends TransactionArgs = {}>(args?: Subset<T, TransactionArgs>): CheckSelect<T, Prisma__TransactionClient<Transaction | null >, Prisma__TransactionClient<TransactionGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Journal base type for findUnique actions
   */
  export type JournalFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Journal
     * 
    **/
    select?: JournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JournalInclude | null
    /**
     * Filter, which Journal to fetch.
     * 
    **/
    where: JournalWhereUniqueInput
  }

  /**
   * Journal: findUnique
   */
  export interface JournalFindUniqueArgs extends JournalFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Journal base type for findFirst actions
   */
  export type JournalFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Journal
     * 
    **/
    select?: JournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JournalInclude | null
    /**
     * Filter, which Journal to fetch.
     * 
    **/
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     * 
    **/
    orderBy?: Enumerable<JournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Journals.
     * 
    **/
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Journals.
     * 
    **/
    distinct?: Enumerable<JournalScalarFieldEnum>
  }

  /**
   * Journal: findFirst
   */
  export interface JournalFindFirstArgs extends JournalFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Journal findMany
   */
  export type JournalFindManyArgs = {
    /**
     * Select specific fields to fetch from the Journal
     * 
    **/
    select?: JournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JournalInclude | null
    /**
     * Filter, which Journals to fetch.
     * 
    **/
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     * 
    **/
    orderBy?: Enumerable<JournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Journals.
     * 
    **/
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     * 
    **/
    skip?: number
    distinct?: Enumerable<JournalScalarFieldEnum>
  }


  /**
   * Journal create
   */
  export type JournalCreateArgs = {
    /**
     * Select specific fields to fetch from the Journal
     * 
    **/
    select?: JournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JournalInclude | null
    /**
     * The data needed to create a Journal.
     * 
    **/
    data: XOR<JournalCreateInput, JournalUncheckedCreateInput>
  }


  /**
   * Journal createMany
   */
  export type JournalCreateManyArgs = {
    /**
     * The data used to create many Journals.
     * 
    **/
    data: Enumerable<JournalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Journal update
   */
  export type JournalUpdateArgs = {
    /**
     * Select specific fields to fetch from the Journal
     * 
    **/
    select?: JournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JournalInclude | null
    /**
     * The data needed to update a Journal.
     * 
    **/
    data: XOR<JournalUpdateInput, JournalUncheckedUpdateInput>
    /**
     * Choose, which Journal to update.
     * 
    **/
    where: JournalWhereUniqueInput
  }


  /**
   * Journal updateMany
   */
  export type JournalUpdateManyArgs = {
    /**
     * The data used to update Journals.
     * 
    **/
    data: XOR<JournalUpdateManyMutationInput, JournalUncheckedUpdateManyInput>
    /**
     * Filter which Journals to update
     * 
    **/
    where?: JournalWhereInput
  }


  /**
   * Journal upsert
   */
  export type JournalUpsertArgs = {
    /**
     * Select specific fields to fetch from the Journal
     * 
    **/
    select?: JournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JournalInclude | null
    /**
     * The filter to search for the Journal to update in case it exists.
     * 
    **/
    where: JournalWhereUniqueInput
    /**
     * In case the Journal found by the `where` argument doesn't exist, create a new Journal with this data.
     * 
    **/
    create: XOR<JournalCreateInput, JournalUncheckedCreateInput>
    /**
     * In case the Journal was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<JournalUpdateInput, JournalUncheckedUpdateInput>
  }


  /**
   * Journal delete
   */
  export type JournalDeleteArgs = {
    /**
     * Select specific fields to fetch from the Journal
     * 
    **/
    select?: JournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JournalInclude | null
    /**
     * Filter which Journal to delete.
     * 
    **/
    where: JournalWhereUniqueInput
  }


  /**
   * Journal deleteMany
   */
  export type JournalDeleteManyArgs = {
    /**
     * Filter which Journals to delete
     * 
    **/
    where?: JournalWhereInput
  }


  /**
   * Journal: findUniqueOrThrow
   */
  export type JournalFindUniqueOrThrowArgs = JournalFindUniqueArgsBase
      

  /**
   * Journal: findFirstOrThrow
   */
  export type JournalFindFirstOrThrowArgs = JournalFindFirstArgsBase
      

  /**
   * Journal without action
   */
  export type JournalArgs = {
    /**
     * Select specific fields to fetch from the Journal
     * 
    **/
    select?: JournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JournalInclude | null
  }



  /**
   * Model SalesJournal
   */


  export type AggregateSalesJournal = {
    _count: SalesJournalCountAggregateOutputType | null
    _avg: SalesJournalAvgAggregateOutputType | null
    _sum: SalesJournalSumAggregateOutputType | null
    _min: SalesJournalMinAggregateOutputType | null
    _max: SalesJournalMaxAggregateOutputType | null
  }

  export type SalesJournalAvgAggregateOutputType = {
    recorderId: number | null
    transactionId: number | null
    amount: Decimal | null
  }

  export type SalesJournalSumAggregateOutputType = {
    recorderId: number | null
    transactionId: number | null
    amount: Decimal | null
  }

  export type SalesJournalMinAggregateOutputType = {
    id: string | null
    recorderId: number | null
    supplierId: string | null
    transactionId: number | null
    narration: string | null
    amount: Decimal | null
  }

  export type SalesJournalMaxAggregateOutputType = {
    id: string | null
    recorderId: number | null
    supplierId: string | null
    transactionId: number | null
    narration: string | null
    amount: Decimal | null
  }

  export type SalesJournalCountAggregateOutputType = {
    id: number
    recorderId: number
    supplierId: number
    transactionId: number
    narration: number
    amount: number
    _all: number
  }


  export type SalesJournalAvgAggregateInputType = {
    recorderId?: true
    transactionId?: true
    amount?: true
  }

  export type SalesJournalSumAggregateInputType = {
    recorderId?: true
    transactionId?: true
    amount?: true
  }

  export type SalesJournalMinAggregateInputType = {
    id?: true
    recorderId?: true
    supplierId?: true
    transactionId?: true
    narration?: true
    amount?: true
  }

  export type SalesJournalMaxAggregateInputType = {
    id?: true
    recorderId?: true
    supplierId?: true
    transactionId?: true
    narration?: true
    amount?: true
  }

  export type SalesJournalCountAggregateInputType = {
    id?: true
    recorderId?: true
    supplierId?: true
    transactionId?: true
    narration?: true
    amount?: true
    _all?: true
  }

  export type SalesJournalAggregateArgs = {
    /**
     * Filter which SalesJournal to aggregate.
     * 
    **/
    where?: SalesJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesJournals to fetch.
     * 
    **/
    orderBy?: Enumerable<SalesJournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SalesJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesJournals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesJournals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesJournals
    **/
    _count?: true | SalesJournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesJournalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesJournalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesJournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesJournalMaxAggregateInputType
  }

  export type GetSalesJournalAggregateType<T extends SalesJournalAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesJournal[P]>
      : GetScalarType<T[P], AggregateSalesJournal[P]>
  }




  export type SalesJournalGroupByArgs = {
    where?: SalesJournalWhereInput
    orderBy?: Enumerable<SalesJournalOrderByWithAggregationInput>
    by: Array<SalesJournalScalarFieldEnum>
    having?: SalesJournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesJournalCountAggregateInputType | true
    _avg?: SalesJournalAvgAggregateInputType
    _sum?: SalesJournalSumAggregateInputType
    _min?: SalesJournalMinAggregateInputType
    _max?: SalesJournalMaxAggregateInputType
  }


  export type SalesJournalGroupByOutputType = {
    id: string
    recorderId: number
    supplierId: string
    transactionId: number
    narration: string
    amount: Decimal
    _count: SalesJournalCountAggregateOutputType | null
    _avg: SalesJournalAvgAggregateOutputType | null
    _sum: SalesJournalSumAggregateOutputType | null
    _min: SalesJournalMinAggregateOutputType | null
    _max: SalesJournalMaxAggregateOutputType | null
  }

  type GetSalesJournalGroupByPayload<T extends SalesJournalGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SalesJournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesJournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesJournalGroupByOutputType[P]>
            : GetScalarType<T[P], SalesJournalGroupByOutputType[P]>
        }
      >
    >


  export type SalesJournalSelect = {
    id?: boolean
    recorder?: boolean | UserArgs
    recorderId?: boolean
    supplier?: boolean | SupplierArgs
    supplierId?: boolean
    transaction?: boolean | TransactionArgs
    transactionId?: boolean
    narration?: boolean
    amount?: boolean
  }

  export type SalesJournalInclude = {
    recorder?: boolean | UserArgs
    supplier?: boolean | SupplierArgs
    transaction?: boolean | TransactionArgs
  }

  export type SalesJournalGetPayload<
    S extends boolean | null | undefined | SalesJournalArgs,
    U = keyof S
      > = S extends true
        ? SalesJournal
    : S extends undefined
    ? never
    : S extends SalesJournalArgs | SalesJournalFindManyArgs
    ?'include' extends U
    ? SalesJournal  & {
    [P in TrueKeys<S['include']>]:
        P extends 'recorder' ? UserGetPayload<S['include'][P]> :
        P extends 'supplier' ? SupplierGetPayload<S['include'][P]> :
        P extends 'transaction' ? TransactionGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'recorder' ? UserGetPayload<S['select'][P]> :
        P extends 'supplier' ? SupplierGetPayload<S['select'][P]> :
        P extends 'transaction' ? TransactionGetPayload<S['select'][P]> :  P extends keyof SalesJournal ? SalesJournal[P] : never
  } 
    : SalesJournal
  : SalesJournal


  type SalesJournalCountArgs = Merge<
    Omit<SalesJournalFindManyArgs, 'select' | 'include'> & {
      select?: SalesJournalCountAggregateInputType | true
    }
  >

  export interface SalesJournalDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SalesJournal that matches the filter.
     * @param {SalesJournalFindUniqueArgs} args - Arguments to find a SalesJournal
     * @example
     * // Get one SalesJournal
     * const salesJournal = await prisma.salesJournal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SalesJournalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SalesJournalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SalesJournal'> extends True ? CheckSelect<T, Prisma__SalesJournalClient<SalesJournal>, Prisma__SalesJournalClient<SalesJournalGetPayload<T>>> : CheckSelect<T, Prisma__SalesJournalClient<SalesJournal | null >, Prisma__SalesJournalClient<SalesJournalGetPayload<T> | null >>

    /**
     * Find the first SalesJournal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesJournalFindFirstArgs} args - Arguments to find a SalesJournal
     * @example
     * // Get one SalesJournal
     * const salesJournal = await prisma.salesJournal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SalesJournalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SalesJournalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SalesJournal'> extends True ? CheckSelect<T, Prisma__SalesJournalClient<SalesJournal>, Prisma__SalesJournalClient<SalesJournalGetPayload<T>>> : CheckSelect<T, Prisma__SalesJournalClient<SalesJournal | null >, Prisma__SalesJournalClient<SalesJournalGetPayload<T> | null >>

    /**
     * Find zero or more SalesJournals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesJournalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesJournals
     * const salesJournals = await prisma.salesJournal.findMany()
     * 
     * // Get first 10 SalesJournals
     * const salesJournals = await prisma.salesJournal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesJournalWithIdOnly = await prisma.salesJournal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SalesJournalFindManyArgs>(
      args?: SelectSubset<T, SalesJournalFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SalesJournal>>, PrismaPromise<Array<SalesJournalGetPayload<T>>>>

    /**
     * Create a SalesJournal.
     * @param {SalesJournalCreateArgs} args - Arguments to create a SalesJournal.
     * @example
     * // Create one SalesJournal
     * const SalesJournal = await prisma.salesJournal.create({
     *   data: {
     *     // ... data to create a SalesJournal
     *   }
     * })
     * 
    **/
    create<T extends SalesJournalCreateArgs>(
      args: SelectSubset<T, SalesJournalCreateArgs>
    ): CheckSelect<T, Prisma__SalesJournalClient<SalesJournal>, Prisma__SalesJournalClient<SalesJournalGetPayload<T>>>

    /**
     * Create many SalesJournals.
     *     @param {SalesJournalCreateManyArgs} args - Arguments to create many SalesJournals.
     *     @example
     *     // Create many SalesJournals
     *     const salesJournal = await prisma.salesJournal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SalesJournalCreateManyArgs>(
      args?: SelectSubset<T, SalesJournalCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SalesJournal.
     * @param {SalesJournalDeleteArgs} args - Arguments to delete one SalesJournal.
     * @example
     * // Delete one SalesJournal
     * const SalesJournal = await prisma.salesJournal.delete({
     *   where: {
     *     // ... filter to delete one SalesJournal
     *   }
     * })
     * 
    **/
    delete<T extends SalesJournalDeleteArgs>(
      args: SelectSubset<T, SalesJournalDeleteArgs>
    ): CheckSelect<T, Prisma__SalesJournalClient<SalesJournal>, Prisma__SalesJournalClient<SalesJournalGetPayload<T>>>

    /**
     * Update one SalesJournal.
     * @param {SalesJournalUpdateArgs} args - Arguments to update one SalesJournal.
     * @example
     * // Update one SalesJournal
     * const salesJournal = await prisma.salesJournal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SalesJournalUpdateArgs>(
      args: SelectSubset<T, SalesJournalUpdateArgs>
    ): CheckSelect<T, Prisma__SalesJournalClient<SalesJournal>, Prisma__SalesJournalClient<SalesJournalGetPayload<T>>>

    /**
     * Delete zero or more SalesJournals.
     * @param {SalesJournalDeleteManyArgs} args - Arguments to filter SalesJournals to delete.
     * @example
     * // Delete a few SalesJournals
     * const { count } = await prisma.salesJournal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SalesJournalDeleteManyArgs>(
      args?: SelectSubset<T, SalesJournalDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesJournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesJournals
     * const salesJournal = await prisma.salesJournal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SalesJournalUpdateManyArgs>(
      args: SelectSubset<T, SalesJournalUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SalesJournal.
     * @param {SalesJournalUpsertArgs} args - Arguments to update or create a SalesJournal.
     * @example
     * // Update or create a SalesJournal
     * const salesJournal = await prisma.salesJournal.upsert({
     *   create: {
     *     // ... data to create a SalesJournal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesJournal we want to update
     *   }
     * })
    **/
    upsert<T extends SalesJournalUpsertArgs>(
      args: SelectSubset<T, SalesJournalUpsertArgs>
    ): CheckSelect<T, Prisma__SalesJournalClient<SalesJournal>, Prisma__SalesJournalClient<SalesJournalGetPayload<T>>>

    /**
     * Find one SalesJournal that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SalesJournalFindUniqueOrThrowArgs} args - Arguments to find a SalesJournal
     * @example
     * // Get one SalesJournal
     * const salesJournal = await prisma.salesJournal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SalesJournalFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SalesJournalFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SalesJournalClient<SalesJournal>, Prisma__SalesJournalClient<SalesJournalGetPayload<T>>>

    /**
     * Find the first SalesJournal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesJournalFindFirstOrThrowArgs} args - Arguments to find a SalesJournal
     * @example
     * // Get one SalesJournal
     * const salesJournal = await prisma.salesJournal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SalesJournalFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SalesJournalFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SalesJournalClient<SalesJournal>, Prisma__SalesJournalClient<SalesJournalGetPayload<T>>>

    /**
     * Count the number of SalesJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesJournalCountArgs} args - Arguments to filter SalesJournals to count.
     * @example
     * // Count the number of SalesJournals
     * const count = await prisma.salesJournal.count({
     *   where: {
     *     // ... the filter for the SalesJournals we want to count
     *   }
     * })
    **/
    count<T extends SalesJournalCountArgs>(
      args?: Subset<T, SalesJournalCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesJournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesJournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesJournalAggregateArgs>(args: Subset<T, SalesJournalAggregateArgs>): PrismaPromise<GetSalesJournalAggregateType<T>>

    /**
     * Group by SalesJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesJournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesJournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesJournalGroupByArgs['orderBy'] }
        : { orderBy?: SalesJournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesJournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesJournalGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesJournal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SalesJournalClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    recorder<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    supplier<T extends SupplierArgs = {}>(args?: Subset<T, SupplierArgs>): CheckSelect<T, Prisma__SupplierClient<Supplier | null >, Prisma__SupplierClient<SupplierGetPayload<T> | null >>;

    transaction<T extends TransactionArgs = {}>(args?: Subset<T, TransactionArgs>): CheckSelect<T, Prisma__TransactionClient<Transaction | null >, Prisma__TransactionClient<TransactionGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SalesJournal base type for findUnique actions
   */
  export type SalesJournalFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SalesJournal
     * 
    **/
    select?: SalesJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalesJournalInclude | null
    /**
     * Filter, which SalesJournal to fetch.
     * 
    **/
    where: SalesJournalWhereUniqueInput
  }

  /**
   * SalesJournal: findUnique
   */
  export interface SalesJournalFindUniqueArgs extends SalesJournalFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SalesJournal base type for findFirst actions
   */
  export type SalesJournalFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SalesJournal
     * 
    **/
    select?: SalesJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalesJournalInclude | null
    /**
     * Filter, which SalesJournal to fetch.
     * 
    **/
    where?: SalesJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesJournals to fetch.
     * 
    **/
    orderBy?: Enumerable<SalesJournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesJournals.
     * 
    **/
    cursor?: SalesJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesJournals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesJournals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesJournals.
     * 
    **/
    distinct?: Enumerable<SalesJournalScalarFieldEnum>
  }

  /**
   * SalesJournal: findFirst
   */
  export interface SalesJournalFindFirstArgs extends SalesJournalFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SalesJournal findMany
   */
  export type SalesJournalFindManyArgs = {
    /**
     * Select specific fields to fetch from the SalesJournal
     * 
    **/
    select?: SalesJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalesJournalInclude | null
    /**
     * Filter, which SalesJournals to fetch.
     * 
    **/
    where?: SalesJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesJournals to fetch.
     * 
    **/
    orderBy?: Enumerable<SalesJournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesJournals.
     * 
    **/
    cursor?: SalesJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesJournals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesJournals.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SalesJournalScalarFieldEnum>
  }


  /**
   * SalesJournal create
   */
  export type SalesJournalCreateArgs = {
    /**
     * Select specific fields to fetch from the SalesJournal
     * 
    **/
    select?: SalesJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalesJournalInclude | null
    /**
     * The data needed to create a SalesJournal.
     * 
    **/
    data: XOR<SalesJournalCreateInput, SalesJournalUncheckedCreateInput>
  }


  /**
   * SalesJournal createMany
   */
  export type SalesJournalCreateManyArgs = {
    /**
     * The data used to create many SalesJournals.
     * 
    **/
    data: Enumerable<SalesJournalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SalesJournal update
   */
  export type SalesJournalUpdateArgs = {
    /**
     * Select specific fields to fetch from the SalesJournal
     * 
    **/
    select?: SalesJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalesJournalInclude | null
    /**
     * The data needed to update a SalesJournal.
     * 
    **/
    data: XOR<SalesJournalUpdateInput, SalesJournalUncheckedUpdateInput>
    /**
     * Choose, which SalesJournal to update.
     * 
    **/
    where: SalesJournalWhereUniqueInput
  }


  /**
   * SalesJournal updateMany
   */
  export type SalesJournalUpdateManyArgs = {
    /**
     * The data used to update SalesJournals.
     * 
    **/
    data: XOR<SalesJournalUpdateManyMutationInput, SalesJournalUncheckedUpdateManyInput>
    /**
     * Filter which SalesJournals to update
     * 
    **/
    where?: SalesJournalWhereInput
  }


  /**
   * SalesJournal upsert
   */
  export type SalesJournalUpsertArgs = {
    /**
     * Select specific fields to fetch from the SalesJournal
     * 
    **/
    select?: SalesJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalesJournalInclude | null
    /**
     * The filter to search for the SalesJournal to update in case it exists.
     * 
    **/
    where: SalesJournalWhereUniqueInput
    /**
     * In case the SalesJournal found by the `where` argument doesn't exist, create a new SalesJournal with this data.
     * 
    **/
    create: XOR<SalesJournalCreateInput, SalesJournalUncheckedCreateInput>
    /**
     * In case the SalesJournal was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SalesJournalUpdateInput, SalesJournalUncheckedUpdateInput>
  }


  /**
   * SalesJournal delete
   */
  export type SalesJournalDeleteArgs = {
    /**
     * Select specific fields to fetch from the SalesJournal
     * 
    **/
    select?: SalesJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalesJournalInclude | null
    /**
     * Filter which SalesJournal to delete.
     * 
    **/
    where: SalesJournalWhereUniqueInput
  }


  /**
   * SalesJournal deleteMany
   */
  export type SalesJournalDeleteManyArgs = {
    /**
     * Filter which SalesJournals to delete
     * 
    **/
    where?: SalesJournalWhereInput
  }


  /**
   * SalesJournal: findUniqueOrThrow
   */
  export type SalesJournalFindUniqueOrThrowArgs = SalesJournalFindUniqueArgsBase
      

  /**
   * SalesJournal: findFirstOrThrow
   */
  export type SalesJournalFindFirstOrThrowArgs = SalesJournalFindFirstArgsBase
      

  /**
   * SalesJournal without action
   */
  export type SalesJournalArgs = {
    /**
     * Select specific fields to fetch from the SalesJournal
     * 
    **/
    select?: SalesJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalesJournalInclude | null
  }



  /**
   * Model PurchasesJournal
   */


  export type AggregatePurchasesJournal = {
    _count: PurchasesJournalCountAggregateOutputType | null
    _avg: PurchasesJournalAvgAggregateOutputType | null
    _sum: PurchasesJournalSumAggregateOutputType | null
    _min: PurchasesJournalMinAggregateOutputType | null
    _max: PurchasesJournalMaxAggregateOutputType | null
  }

  export type PurchasesJournalAvgAggregateOutputType = {
    recorderId: number | null
    transactionId: number | null
    amount: Decimal | null
  }

  export type PurchasesJournalSumAggregateOutputType = {
    recorderId: number | null
    transactionId: number | null
    amount: Decimal | null
  }

  export type PurchasesJournalMinAggregateOutputType = {
    id: string | null
    recorderId: number | null
    customerId: string | null
    transactionId: number | null
    narration: string | null
    amount: Decimal | null
  }

  export type PurchasesJournalMaxAggregateOutputType = {
    id: string | null
    recorderId: number | null
    customerId: string | null
    transactionId: number | null
    narration: string | null
    amount: Decimal | null
  }

  export type PurchasesJournalCountAggregateOutputType = {
    id: number
    recorderId: number
    customerId: number
    transactionId: number
    narration: number
    amount: number
    _all: number
  }


  export type PurchasesJournalAvgAggregateInputType = {
    recorderId?: true
    transactionId?: true
    amount?: true
  }

  export type PurchasesJournalSumAggregateInputType = {
    recorderId?: true
    transactionId?: true
    amount?: true
  }

  export type PurchasesJournalMinAggregateInputType = {
    id?: true
    recorderId?: true
    customerId?: true
    transactionId?: true
    narration?: true
    amount?: true
  }

  export type PurchasesJournalMaxAggregateInputType = {
    id?: true
    recorderId?: true
    customerId?: true
    transactionId?: true
    narration?: true
    amount?: true
  }

  export type PurchasesJournalCountAggregateInputType = {
    id?: true
    recorderId?: true
    customerId?: true
    transactionId?: true
    narration?: true
    amount?: true
    _all?: true
  }

  export type PurchasesJournalAggregateArgs = {
    /**
     * Filter which PurchasesJournal to aggregate.
     * 
    **/
    where?: PurchasesJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasesJournals to fetch.
     * 
    **/
    orderBy?: Enumerable<PurchasesJournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PurchasesJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasesJournals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasesJournals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchasesJournals
    **/
    _count?: true | PurchasesJournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchasesJournalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchasesJournalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchasesJournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchasesJournalMaxAggregateInputType
  }

  export type GetPurchasesJournalAggregateType<T extends PurchasesJournalAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchasesJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchasesJournal[P]>
      : GetScalarType<T[P], AggregatePurchasesJournal[P]>
  }




  export type PurchasesJournalGroupByArgs = {
    where?: PurchasesJournalWhereInput
    orderBy?: Enumerable<PurchasesJournalOrderByWithAggregationInput>
    by: Array<PurchasesJournalScalarFieldEnum>
    having?: PurchasesJournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchasesJournalCountAggregateInputType | true
    _avg?: PurchasesJournalAvgAggregateInputType
    _sum?: PurchasesJournalSumAggregateInputType
    _min?: PurchasesJournalMinAggregateInputType
    _max?: PurchasesJournalMaxAggregateInputType
  }


  export type PurchasesJournalGroupByOutputType = {
    id: string
    recorderId: number
    customerId: string | null
    transactionId: number
    narration: string
    amount: Decimal
    _count: PurchasesJournalCountAggregateOutputType | null
    _avg: PurchasesJournalAvgAggregateOutputType | null
    _sum: PurchasesJournalSumAggregateOutputType | null
    _min: PurchasesJournalMinAggregateOutputType | null
    _max: PurchasesJournalMaxAggregateOutputType | null
  }

  type GetPurchasesJournalGroupByPayload<T extends PurchasesJournalGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PurchasesJournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchasesJournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchasesJournalGroupByOutputType[P]>
            : GetScalarType<T[P], PurchasesJournalGroupByOutputType[P]>
        }
      >
    >


  export type PurchasesJournalSelect = {
    id?: boolean
    recorder?: boolean | UserArgs
    recorderId?: boolean
    customer?: boolean | CustomerArgs
    customerId?: boolean
    transaction?: boolean | TransactionArgs
    transactionId?: boolean
    narration?: boolean
    amount?: boolean
  }

  export type PurchasesJournalInclude = {
    recorder?: boolean | UserArgs
    customer?: boolean | CustomerArgs
    transaction?: boolean | TransactionArgs
  }

  export type PurchasesJournalGetPayload<
    S extends boolean | null | undefined | PurchasesJournalArgs,
    U = keyof S
      > = S extends true
        ? PurchasesJournal
    : S extends undefined
    ? never
    : S extends PurchasesJournalArgs | PurchasesJournalFindManyArgs
    ?'include' extends U
    ? PurchasesJournal  & {
    [P in TrueKeys<S['include']>]:
        P extends 'recorder' ? UserGetPayload<S['include'][P]> :
        P extends 'customer' ? CustomerGetPayload<S['include'][P]> | null :
        P extends 'transaction' ? TransactionGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'recorder' ? UserGetPayload<S['select'][P]> :
        P extends 'customer' ? CustomerGetPayload<S['select'][P]> | null :
        P extends 'transaction' ? TransactionGetPayload<S['select'][P]> :  P extends keyof PurchasesJournal ? PurchasesJournal[P] : never
  } 
    : PurchasesJournal
  : PurchasesJournal


  type PurchasesJournalCountArgs = Merge<
    Omit<PurchasesJournalFindManyArgs, 'select' | 'include'> & {
      select?: PurchasesJournalCountAggregateInputType | true
    }
  >

  export interface PurchasesJournalDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PurchasesJournal that matches the filter.
     * @param {PurchasesJournalFindUniqueArgs} args - Arguments to find a PurchasesJournal
     * @example
     * // Get one PurchasesJournal
     * const purchasesJournal = await prisma.purchasesJournal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PurchasesJournalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PurchasesJournalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PurchasesJournal'> extends True ? CheckSelect<T, Prisma__PurchasesJournalClient<PurchasesJournal>, Prisma__PurchasesJournalClient<PurchasesJournalGetPayload<T>>> : CheckSelect<T, Prisma__PurchasesJournalClient<PurchasesJournal | null >, Prisma__PurchasesJournalClient<PurchasesJournalGetPayload<T> | null >>

    /**
     * Find the first PurchasesJournal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesJournalFindFirstArgs} args - Arguments to find a PurchasesJournal
     * @example
     * // Get one PurchasesJournal
     * const purchasesJournal = await prisma.purchasesJournal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PurchasesJournalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PurchasesJournalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PurchasesJournal'> extends True ? CheckSelect<T, Prisma__PurchasesJournalClient<PurchasesJournal>, Prisma__PurchasesJournalClient<PurchasesJournalGetPayload<T>>> : CheckSelect<T, Prisma__PurchasesJournalClient<PurchasesJournal | null >, Prisma__PurchasesJournalClient<PurchasesJournalGetPayload<T> | null >>

    /**
     * Find zero or more PurchasesJournals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesJournalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchasesJournals
     * const purchasesJournals = await prisma.purchasesJournal.findMany()
     * 
     * // Get first 10 PurchasesJournals
     * const purchasesJournals = await prisma.purchasesJournal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchasesJournalWithIdOnly = await prisma.purchasesJournal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PurchasesJournalFindManyArgs>(
      args?: SelectSubset<T, PurchasesJournalFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PurchasesJournal>>, PrismaPromise<Array<PurchasesJournalGetPayload<T>>>>

    /**
     * Create a PurchasesJournal.
     * @param {PurchasesJournalCreateArgs} args - Arguments to create a PurchasesJournal.
     * @example
     * // Create one PurchasesJournal
     * const PurchasesJournal = await prisma.purchasesJournal.create({
     *   data: {
     *     // ... data to create a PurchasesJournal
     *   }
     * })
     * 
    **/
    create<T extends PurchasesJournalCreateArgs>(
      args: SelectSubset<T, PurchasesJournalCreateArgs>
    ): CheckSelect<T, Prisma__PurchasesJournalClient<PurchasesJournal>, Prisma__PurchasesJournalClient<PurchasesJournalGetPayload<T>>>

    /**
     * Create many PurchasesJournals.
     *     @param {PurchasesJournalCreateManyArgs} args - Arguments to create many PurchasesJournals.
     *     @example
     *     // Create many PurchasesJournals
     *     const purchasesJournal = await prisma.purchasesJournal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PurchasesJournalCreateManyArgs>(
      args?: SelectSubset<T, PurchasesJournalCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PurchasesJournal.
     * @param {PurchasesJournalDeleteArgs} args - Arguments to delete one PurchasesJournal.
     * @example
     * // Delete one PurchasesJournal
     * const PurchasesJournal = await prisma.purchasesJournal.delete({
     *   where: {
     *     // ... filter to delete one PurchasesJournal
     *   }
     * })
     * 
    **/
    delete<T extends PurchasesJournalDeleteArgs>(
      args: SelectSubset<T, PurchasesJournalDeleteArgs>
    ): CheckSelect<T, Prisma__PurchasesJournalClient<PurchasesJournal>, Prisma__PurchasesJournalClient<PurchasesJournalGetPayload<T>>>

    /**
     * Update one PurchasesJournal.
     * @param {PurchasesJournalUpdateArgs} args - Arguments to update one PurchasesJournal.
     * @example
     * // Update one PurchasesJournal
     * const purchasesJournal = await prisma.purchasesJournal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PurchasesJournalUpdateArgs>(
      args: SelectSubset<T, PurchasesJournalUpdateArgs>
    ): CheckSelect<T, Prisma__PurchasesJournalClient<PurchasesJournal>, Prisma__PurchasesJournalClient<PurchasesJournalGetPayload<T>>>

    /**
     * Delete zero or more PurchasesJournals.
     * @param {PurchasesJournalDeleteManyArgs} args - Arguments to filter PurchasesJournals to delete.
     * @example
     * // Delete a few PurchasesJournals
     * const { count } = await prisma.purchasesJournal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PurchasesJournalDeleteManyArgs>(
      args?: SelectSubset<T, PurchasesJournalDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasesJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesJournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchasesJournals
     * const purchasesJournal = await prisma.purchasesJournal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PurchasesJournalUpdateManyArgs>(
      args: SelectSubset<T, PurchasesJournalUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchasesJournal.
     * @param {PurchasesJournalUpsertArgs} args - Arguments to update or create a PurchasesJournal.
     * @example
     * // Update or create a PurchasesJournal
     * const purchasesJournal = await prisma.purchasesJournal.upsert({
     *   create: {
     *     // ... data to create a PurchasesJournal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchasesJournal we want to update
     *   }
     * })
    **/
    upsert<T extends PurchasesJournalUpsertArgs>(
      args: SelectSubset<T, PurchasesJournalUpsertArgs>
    ): CheckSelect<T, Prisma__PurchasesJournalClient<PurchasesJournal>, Prisma__PurchasesJournalClient<PurchasesJournalGetPayload<T>>>

    /**
     * Find one PurchasesJournal that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PurchasesJournalFindUniqueOrThrowArgs} args - Arguments to find a PurchasesJournal
     * @example
     * // Get one PurchasesJournal
     * const purchasesJournal = await prisma.purchasesJournal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PurchasesJournalFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PurchasesJournalFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PurchasesJournalClient<PurchasesJournal>, Prisma__PurchasesJournalClient<PurchasesJournalGetPayload<T>>>

    /**
     * Find the first PurchasesJournal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesJournalFindFirstOrThrowArgs} args - Arguments to find a PurchasesJournal
     * @example
     * // Get one PurchasesJournal
     * const purchasesJournal = await prisma.purchasesJournal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PurchasesJournalFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PurchasesJournalFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PurchasesJournalClient<PurchasesJournal>, Prisma__PurchasesJournalClient<PurchasesJournalGetPayload<T>>>

    /**
     * Count the number of PurchasesJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesJournalCountArgs} args - Arguments to filter PurchasesJournals to count.
     * @example
     * // Count the number of PurchasesJournals
     * const count = await prisma.purchasesJournal.count({
     *   where: {
     *     // ... the filter for the PurchasesJournals we want to count
     *   }
     * })
    **/
    count<T extends PurchasesJournalCountArgs>(
      args?: Subset<T, PurchasesJournalCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchasesJournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchasesJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesJournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchasesJournalAggregateArgs>(args: Subset<T, PurchasesJournalAggregateArgs>): PrismaPromise<GetPurchasesJournalAggregateType<T>>

    /**
     * Group by PurchasesJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesJournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchasesJournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchasesJournalGroupByArgs['orderBy'] }
        : { orderBy?: PurchasesJournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchasesJournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchasesJournalGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchasesJournal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PurchasesJournalClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    recorder<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    customer<T extends CustomerArgs = {}>(args?: Subset<T, CustomerArgs>): CheckSelect<T, Prisma__CustomerClient<Customer | null >, Prisma__CustomerClient<CustomerGetPayload<T> | null >>;

    transaction<T extends TransactionArgs = {}>(args?: Subset<T, TransactionArgs>): CheckSelect<T, Prisma__TransactionClient<Transaction | null >, Prisma__TransactionClient<TransactionGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PurchasesJournal base type for findUnique actions
   */
  export type PurchasesJournalFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PurchasesJournal
     * 
    **/
    select?: PurchasesJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PurchasesJournalInclude | null
    /**
     * Filter, which PurchasesJournal to fetch.
     * 
    **/
    where: PurchasesJournalWhereUniqueInput
  }

  /**
   * PurchasesJournal: findUnique
   */
  export interface PurchasesJournalFindUniqueArgs extends PurchasesJournalFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PurchasesJournal base type for findFirst actions
   */
  export type PurchasesJournalFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PurchasesJournal
     * 
    **/
    select?: PurchasesJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PurchasesJournalInclude | null
    /**
     * Filter, which PurchasesJournal to fetch.
     * 
    **/
    where?: PurchasesJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasesJournals to fetch.
     * 
    **/
    orderBy?: Enumerable<PurchasesJournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasesJournals.
     * 
    **/
    cursor?: PurchasesJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasesJournals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasesJournals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasesJournals.
     * 
    **/
    distinct?: Enumerable<PurchasesJournalScalarFieldEnum>
  }

  /**
   * PurchasesJournal: findFirst
   */
  export interface PurchasesJournalFindFirstArgs extends PurchasesJournalFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PurchasesJournal findMany
   */
  export type PurchasesJournalFindManyArgs = {
    /**
     * Select specific fields to fetch from the PurchasesJournal
     * 
    **/
    select?: PurchasesJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PurchasesJournalInclude | null
    /**
     * Filter, which PurchasesJournals to fetch.
     * 
    **/
    where?: PurchasesJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasesJournals to fetch.
     * 
    **/
    orderBy?: Enumerable<PurchasesJournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchasesJournals.
     * 
    **/
    cursor?: PurchasesJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasesJournals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasesJournals.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PurchasesJournalScalarFieldEnum>
  }


  /**
   * PurchasesJournal create
   */
  export type PurchasesJournalCreateArgs = {
    /**
     * Select specific fields to fetch from the PurchasesJournal
     * 
    **/
    select?: PurchasesJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PurchasesJournalInclude | null
    /**
     * The data needed to create a PurchasesJournal.
     * 
    **/
    data: XOR<PurchasesJournalCreateInput, PurchasesJournalUncheckedCreateInput>
  }


  /**
   * PurchasesJournal createMany
   */
  export type PurchasesJournalCreateManyArgs = {
    /**
     * The data used to create many PurchasesJournals.
     * 
    **/
    data: Enumerable<PurchasesJournalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PurchasesJournal update
   */
  export type PurchasesJournalUpdateArgs = {
    /**
     * Select specific fields to fetch from the PurchasesJournal
     * 
    **/
    select?: PurchasesJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PurchasesJournalInclude | null
    /**
     * The data needed to update a PurchasesJournal.
     * 
    **/
    data: XOR<PurchasesJournalUpdateInput, PurchasesJournalUncheckedUpdateInput>
    /**
     * Choose, which PurchasesJournal to update.
     * 
    **/
    where: PurchasesJournalWhereUniqueInput
  }


  /**
   * PurchasesJournal updateMany
   */
  export type PurchasesJournalUpdateManyArgs = {
    /**
     * The data used to update PurchasesJournals.
     * 
    **/
    data: XOR<PurchasesJournalUpdateManyMutationInput, PurchasesJournalUncheckedUpdateManyInput>
    /**
     * Filter which PurchasesJournals to update
     * 
    **/
    where?: PurchasesJournalWhereInput
  }


  /**
   * PurchasesJournal upsert
   */
  export type PurchasesJournalUpsertArgs = {
    /**
     * Select specific fields to fetch from the PurchasesJournal
     * 
    **/
    select?: PurchasesJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PurchasesJournalInclude | null
    /**
     * The filter to search for the PurchasesJournal to update in case it exists.
     * 
    **/
    where: PurchasesJournalWhereUniqueInput
    /**
     * In case the PurchasesJournal found by the `where` argument doesn't exist, create a new PurchasesJournal with this data.
     * 
    **/
    create: XOR<PurchasesJournalCreateInput, PurchasesJournalUncheckedCreateInput>
    /**
     * In case the PurchasesJournal was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PurchasesJournalUpdateInput, PurchasesJournalUncheckedUpdateInput>
  }


  /**
   * PurchasesJournal delete
   */
  export type PurchasesJournalDeleteArgs = {
    /**
     * Select specific fields to fetch from the PurchasesJournal
     * 
    **/
    select?: PurchasesJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PurchasesJournalInclude | null
    /**
     * Filter which PurchasesJournal to delete.
     * 
    **/
    where: PurchasesJournalWhereUniqueInput
  }


  /**
   * PurchasesJournal deleteMany
   */
  export type PurchasesJournalDeleteManyArgs = {
    /**
     * Filter which PurchasesJournals to delete
     * 
    **/
    where?: PurchasesJournalWhereInput
  }


  /**
   * PurchasesJournal: findUniqueOrThrow
   */
  export type PurchasesJournalFindUniqueOrThrowArgs = PurchasesJournalFindUniqueArgsBase
      

  /**
   * PurchasesJournal: findFirstOrThrow
   */
  export type PurchasesJournalFindFirstOrThrowArgs = PurchasesJournalFindFirstArgsBase
      

  /**
   * PurchasesJournal without action
   */
  export type PurchasesJournalArgs = {
    /**
     * Select specific fields to fetch from the PurchasesJournal
     * 
    **/
    select?: PurchasesJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PurchasesJournalInclude | null
  }



  /**
   * Model CashDisbursementsJournal
   */


  export type AggregateCashDisbursementsJournal = {
    _count: CashDisbursementsJournalCountAggregateOutputType | null
    _avg: CashDisbursementsJournalAvgAggregateOutputType | null
    _sum: CashDisbursementsJournalSumAggregateOutputType | null
    _min: CashDisbursementsJournalMinAggregateOutputType | null
    _max: CashDisbursementsJournalMaxAggregateOutputType | null
  }

  export type CashDisbursementsJournalAvgAggregateOutputType = {
    recorderId: number | null
    transactionId: number | null
    amount: Decimal | null
  }

  export type CashDisbursementsJournalSumAggregateOutputType = {
    recorderId: number | null
    transactionId: number | null
    amount: Decimal | null
  }

  export type CashDisbursementsJournalMinAggregateOutputType = {
    id: string | null
    recorderId: number | null
    supplierId: string | null
    customerId: string | null
    transactionId: number | null
    narration: string | null
    amount: Decimal | null
  }

  export type CashDisbursementsJournalMaxAggregateOutputType = {
    id: string | null
    recorderId: number | null
    supplierId: string | null
    customerId: string | null
    transactionId: number | null
    narration: string | null
    amount: Decimal | null
  }

  export type CashDisbursementsJournalCountAggregateOutputType = {
    id: number
    recorderId: number
    supplierId: number
    customerId: number
    transactionId: number
    narration: number
    amount: number
    _all: number
  }


  export type CashDisbursementsJournalAvgAggregateInputType = {
    recorderId?: true
    transactionId?: true
    amount?: true
  }

  export type CashDisbursementsJournalSumAggregateInputType = {
    recorderId?: true
    transactionId?: true
    amount?: true
  }

  export type CashDisbursementsJournalMinAggregateInputType = {
    id?: true
    recorderId?: true
    supplierId?: true
    customerId?: true
    transactionId?: true
    narration?: true
    amount?: true
  }

  export type CashDisbursementsJournalMaxAggregateInputType = {
    id?: true
    recorderId?: true
    supplierId?: true
    customerId?: true
    transactionId?: true
    narration?: true
    amount?: true
  }

  export type CashDisbursementsJournalCountAggregateInputType = {
    id?: true
    recorderId?: true
    supplierId?: true
    customerId?: true
    transactionId?: true
    narration?: true
    amount?: true
    _all?: true
  }

  export type CashDisbursementsJournalAggregateArgs = {
    /**
     * Filter which CashDisbursementsJournal to aggregate.
     * 
    **/
    where?: CashDisbursementsJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashDisbursementsJournals to fetch.
     * 
    **/
    orderBy?: Enumerable<CashDisbursementsJournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CashDisbursementsJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashDisbursementsJournals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashDisbursementsJournals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashDisbursementsJournals
    **/
    _count?: true | CashDisbursementsJournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashDisbursementsJournalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashDisbursementsJournalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashDisbursementsJournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashDisbursementsJournalMaxAggregateInputType
  }

  export type GetCashDisbursementsJournalAggregateType<T extends CashDisbursementsJournalAggregateArgs> = {
        [P in keyof T & keyof AggregateCashDisbursementsJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashDisbursementsJournal[P]>
      : GetScalarType<T[P], AggregateCashDisbursementsJournal[P]>
  }




  export type CashDisbursementsJournalGroupByArgs = {
    where?: CashDisbursementsJournalWhereInput
    orderBy?: Enumerable<CashDisbursementsJournalOrderByWithAggregationInput>
    by: Array<CashDisbursementsJournalScalarFieldEnum>
    having?: CashDisbursementsJournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashDisbursementsJournalCountAggregateInputType | true
    _avg?: CashDisbursementsJournalAvgAggregateInputType
    _sum?: CashDisbursementsJournalSumAggregateInputType
    _min?: CashDisbursementsJournalMinAggregateInputType
    _max?: CashDisbursementsJournalMaxAggregateInputType
  }


  export type CashDisbursementsJournalGroupByOutputType = {
    id: string
    recorderId: number
    supplierId: string | null
    customerId: string | null
    transactionId: number
    narration: string
    amount: Decimal
    _count: CashDisbursementsJournalCountAggregateOutputType | null
    _avg: CashDisbursementsJournalAvgAggregateOutputType | null
    _sum: CashDisbursementsJournalSumAggregateOutputType | null
    _min: CashDisbursementsJournalMinAggregateOutputType | null
    _max: CashDisbursementsJournalMaxAggregateOutputType | null
  }

  type GetCashDisbursementsJournalGroupByPayload<T extends CashDisbursementsJournalGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CashDisbursementsJournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashDisbursementsJournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashDisbursementsJournalGroupByOutputType[P]>
            : GetScalarType<T[P], CashDisbursementsJournalGroupByOutputType[P]>
        }
      >
    >


  export type CashDisbursementsJournalSelect = {
    id?: boolean
    recorder?: boolean | UserArgs
    recorderId?: boolean
    supplier?: boolean | SupplierArgs
    supplierId?: boolean
    customer?: boolean | CustomerArgs
    customerId?: boolean
    transaction?: boolean | TransactionArgs
    transactionId?: boolean
    narration?: boolean
    amount?: boolean
  }

  export type CashDisbursementsJournalInclude = {
    recorder?: boolean | UserArgs
    supplier?: boolean | SupplierArgs
    customer?: boolean | CustomerArgs
    transaction?: boolean | TransactionArgs
  }

  export type CashDisbursementsJournalGetPayload<
    S extends boolean | null | undefined | CashDisbursementsJournalArgs,
    U = keyof S
      > = S extends true
        ? CashDisbursementsJournal
    : S extends undefined
    ? never
    : S extends CashDisbursementsJournalArgs | CashDisbursementsJournalFindManyArgs
    ?'include' extends U
    ? CashDisbursementsJournal  & {
    [P in TrueKeys<S['include']>]:
        P extends 'recorder' ? UserGetPayload<S['include'][P]> :
        P extends 'supplier' ? SupplierGetPayload<S['include'][P]> | null :
        P extends 'customer' ? CustomerGetPayload<S['include'][P]> | null :
        P extends 'transaction' ? TransactionGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'recorder' ? UserGetPayload<S['select'][P]> :
        P extends 'supplier' ? SupplierGetPayload<S['select'][P]> | null :
        P extends 'customer' ? CustomerGetPayload<S['select'][P]> | null :
        P extends 'transaction' ? TransactionGetPayload<S['select'][P]> :  P extends keyof CashDisbursementsJournal ? CashDisbursementsJournal[P] : never
  } 
    : CashDisbursementsJournal
  : CashDisbursementsJournal


  type CashDisbursementsJournalCountArgs = Merge<
    Omit<CashDisbursementsJournalFindManyArgs, 'select' | 'include'> & {
      select?: CashDisbursementsJournalCountAggregateInputType | true
    }
  >

  export interface CashDisbursementsJournalDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CashDisbursementsJournal that matches the filter.
     * @param {CashDisbursementsJournalFindUniqueArgs} args - Arguments to find a CashDisbursementsJournal
     * @example
     * // Get one CashDisbursementsJournal
     * const cashDisbursementsJournal = await prisma.cashDisbursementsJournal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CashDisbursementsJournalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CashDisbursementsJournalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CashDisbursementsJournal'> extends True ? CheckSelect<T, Prisma__CashDisbursementsJournalClient<CashDisbursementsJournal>, Prisma__CashDisbursementsJournalClient<CashDisbursementsJournalGetPayload<T>>> : CheckSelect<T, Prisma__CashDisbursementsJournalClient<CashDisbursementsJournal | null >, Prisma__CashDisbursementsJournalClient<CashDisbursementsJournalGetPayload<T> | null >>

    /**
     * Find the first CashDisbursementsJournal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashDisbursementsJournalFindFirstArgs} args - Arguments to find a CashDisbursementsJournal
     * @example
     * // Get one CashDisbursementsJournal
     * const cashDisbursementsJournal = await prisma.cashDisbursementsJournal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CashDisbursementsJournalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CashDisbursementsJournalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CashDisbursementsJournal'> extends True ? CheckSelect<T, Prisma__CashDisbursementsJournalClient<CashDisbursementsJournal>, Prisma__CashDisbursementsJournalClient<CashDisbursementsJournalGetPayload<T>>> : CheckSelect<T, Prisma__CashDisbursementsJournalClient<CashDisbursementsJournal | null >, Prisma__CashDisbursementsJournalClient<CashDisbursementsJournalGetPayload<T> | null >>

    /**
     * Find zero or more CashDisbursementsJournals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashDisbursementsJournalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashDisbursementsJournals
     * const cashDisbursementsJournals = await prisma.cashDisbursementsJournal.findMany()
     * 
     * // Get first 10 CashDisbursementsJournals
     * const cashDisbursementsJournals = await prisma.cashDisbursementsJournal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashDisbursementsJournalWithIdOnly = await prisma.cashDisbursementsJournal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CashDisbursementsJournalFindManyArgs>(
      args?: SelectSubset<T, CashDisbursementsJournalFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CashDisbursementsJournal>>, PrismaPromise<Array<CashDisbursementsJournalGetPayload<T>>>>

    /**
     * Create a CashDisbursementsJournal.
     * @param {CashDisbursementsJournalCreateArgs} args - Arguments to create a CashDisbursementsJournal.
     * @example
     * // Create one CashDisbursementsJournal
     * const CashDisbursementsJournal = await prisma.cashDisbursementsJournal.create({
     *   data: {
     *     // ... data to create a CashDisbursementsJournal
     *   }
     * })
     * 
    **/
    create<T extends CashDisbursementsJournalCreateArgs>(
      args: SelectSubset<T, CashDisbursementsJournalCreateArgs>
    ): CheckSelect<T, Prisma__CashDisbursementsJournalClient<CashDisbursementsJournal>, Prisma__CashDisbursementsJournalClient<CashDisbursementsJournalGetPayload<T>>>

    /**
     * Create many CashDisbursementsJournals.
     *     @param {CashDisbursementsJournalCreateManyArgs} args - Arguments to create many CashDisbursementsJournals.
     *     @example
     *     // Create many CashDisbursementsJournals
     *     const cashDisbursementsJournal = await prisma.cashDisbursementsJournal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CashDisbursementsJournalCreateManyArgs>(
      args?: SelectSubset<T, CashDisbursementsJournalCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CashDisbursementsJournal.
     * @param {CashDisbursementsJournalDeleteArgs} args - Arguments to delete one CashDisbursementsJournal.
     * @example
     * // Delete one CashDisbursementsJournal
     * const CashDisbursementsJournal = await prisma.cashDisbursementsJournal.delete({
     *   where: {
     *     // ... filter to delete one CashDisbursementsJournal
     *   }
     * })
     * 
    **/
    delete<T extends CashDisbursementsJournalDeleteArgs>(
      args: SelectSubset<T, CashDisbursementsJournalDeleteArgs>
    ): CheckSelect<T, Prisma__CashDisbursementsJournalClient<CashDisbursementsJournal>, Prisma__CashDisbursementsJournalClient<CashDisbursementsJournalGetPayload<T>>>

    /**
     * Update one CashDisbursementsJournal.
     * @param {CashDisbursementsJournalUpdateArgs} args - Arguments to update one CashDisbursementsJournal.
     * @example
     * // Update one CashDisbursementsJournal
     * const cashDisbursementsJournal = await prisma.cashDisbursementsJournal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CashDisbursementsJournalUpdateArgs>(
      args: SelectSubset<T, CashDisbursementsJournalUpdateArgs>
    ): CheckSelect<T, Prisma__CashDisbursementsJournalClient<CashDisbursementsJournal>, Prisma__CashDisbursementsJournalClient<CashDisbursementsJournalGetPayload<T>>>

    /**
     * Delete zero or more CashDisbursementsJournals.
     * @param {CashDisbursementsJournalDeleteManyArgs} args - Arguments to filter CashDisbursementsJournals to delete.
     * @example
     * // Delete a few CashDisbursementsJournals
     * const { count } = await prisma.cashDisbursementsJournal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CashDisbursementsJournalDeleteManyArgs>(
      args?: SelectSubset<T, CashDisbursementsJournalDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashDisbursementsJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashDisbursementsJournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashDisbursementsJournals
     * const cashDisbursementsJournal = await prisma.cashDisbursementsJournal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CashDisbursementsJournalUpdateManyArgs>(
      args: SelectSubset<T, CashDisbursementsJournalUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CashDisbursementsJournal.
     * @param {CashDisbursementsJournalUpsertArgs} args - Arguments to update or create a CashDisbursementsJournal.
     * @example
     * // Update or create a CashDisbursementsJournal
     * const cashDisbursementsJournal = await prisma.cashDisbursementsJournal.upsert({
     *   create: {
     *     // ... data to create a CashDisbursementsJournal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashDisbursementsJournal we want to update
     *   }
     * })
    **/
    upsert<T extends CashDisbursementsJournalUpsertArgs>(
      args: SelectSubset<T, CashDisbursementsJournalUpsertArgs>
    ): CheckSelect<T, Prisma__CashDisbursementsJournalClient<CashDisbursementsJournal>, Prisma__CashDisbursementsJournalClient<CashDisbursementsJournalGetPayload<T>>>

    /**
     * Find one CashDisbursementsJournal that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CashDisbursementsJournalFindUniqueOrThrowArgs} args - Arguments to find a CashDisbursementsJournal
     * @example
     * // Get one CashDisbursementsJournal
     * const cashDisbursementsJournal = await prisma.cashDisbursementsJournal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CashDisbursementsJournalFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CashDisbursementsJournalFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CashDisbursementsJournalClient<CashDisbursementsJournal>, Prisma__CashDisbursementsJournalClient<CashDisbursementsJournalGetPayload<T>>>

    /**
     * Find the first CashDisbursementsJournal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashDisbursementsJournalFindFirstOrThrowArgs} args - Arguments to find a CashDisbursementsJournal
     * @example
     * // Get one CashDisbursementsJournal
     * const cashDisbursementsJournal = await prisma.cashDisbursementsJournal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CashDisbursementsJournalFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CashDisbursementsJournalFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CashDisbursementsJournalClient<CashDisbursementsJournal>, Prisma__CashDisbursementsJournalClient<CashDisbursementsJournalGetPayload<T>>>

    /**
     * Count the number of CashDisbursementsJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashDisbursementsJournalCountArgs} args - Arguments to filter CashDisbursementsJournals to count.
     * @example
     * // Count the number of CashDisbursementsJournals
     * const count = await prisma.cashDisbursementsJournal.count({
     *   where: {
     *     // ... the filter for the CashDisbursementsJournals we want to count
     *   }
     * })
    **/
    count<T extends CashDisbursementsJournalCountArgs>(
      args?: Subset<T, CashDisbursementsJournalCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashDisbursementsJournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashDisbursementsJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashDisbursementsJournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashDisbursementsJournalAggregateArgs>(args: Subset<T, CashDisbursementsJournalAggregateArgs>): PrismaPromise<GetCashDisbursementsJournalAggregateType<T>>

    /**
     * Group by CashDisbursementsJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashDisbursementsJournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashDisbursementsJournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashDisbursementsJournalGroupByArgs['orderBy'] }
        : { orderBy?: CashDisbursementsJournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashDisbursementsJournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashDisbursementsJournalGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashDisbursementsJournal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CashDisbursementsJournalClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    recorder<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    supplier<T extends SupplierArgs = {}>(args?: Subset<T, SupplierArgs>): CheckSelect<T, Prisma__SupplierClient<Supplier | null >, Prisma__SupplierClient<SupplierGetPayload<T> | null >>;

    customer<T extends CustomerArgs = {}>(args?: Subset<T, CustomerArgs>): CheckSelect<T, Prisma__CustomerClient<Customer | null >, Prisma__CustomerClient<CustomerGetPayload<T> | null >>;

    transaction<T extends TransactionArgs = {}>(args?: Subset<T, TransactionArgs>): CheckSelect<T, Prisma__TransactionClient<Transaction | null >, Prisma__TransactionClient<TransactionGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CashDisbursementsJournal base type for findUnique actions
   */
  export type CashDisbursementsJournalFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CashDisbursementsJournal
     * 
    **/
    select?: CashDisbursementsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashDisbursementsJournalInclude | null
    /**
     * Filter, which CashDisbursementsJournal to fetch.
     * 
    **/
    where: CashDisbursementsJournalWhereUniqueInput
  }

  /**
   * CashDisbursementsJournal: findUnique
   */
  export interface CashDisbursementsJournalFindUniqueArgs extends CashDisbursementsJournalFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CashDisbursementsJournal base type for findFirst actions
   */
  export type CashDisbursementsJournalFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CashDisbursementsJournal
     * 
    **/
    select?: CashDisbursementsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashDisbursementsJournalInclude | null
    /**
     * Filter, which CashDisbursementsJournal to fetch.
     * 
    **/
    where?: CashDisbursementsJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashDisbursementsJournals to fetch.
     * 
    **/
    orderBy?: Enumerable<CashDisbursementsJournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashDisbursementsJournals.
     * 
    **/
    cursor?: CashDisbursementsJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashDisbursementsJournals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashDisbursementsJournals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashDisbursementsJournals.
     * 
    **/
    distinct?: Enumerable<CashDisbursementsJournalScalarFieldEnum>
  }

  /**
   * CashDisbursementsJournal: findFirst
   */
  export interface CashDisbursementsJournalFindFirstArgs extends CashDisbursementsJournalFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CashDisbursementsJournal findMany
   */
  export type CashDisbursementsJournalFindManyArgs = {
    /**
     * Select specific fields to fetch from the CashDisbursementsJournal
     * 
    **/
    select?: CashDisbursementsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashDisbursementsJournalInclude | null
    /**
     * Filter, which CashDisbursementsJournals to fetch.
     * 
    **/
    where?: CashDisbursementsJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashDisbursementsJournals to fetch.
     * 
    **/
    orderBy?: Enumerable<CashDisbursementsJournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashDisbursementsJournals.
     * 
    **/
    cursor?: CashDisbursementsJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashDisbursementsJournals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashDisbursementsJournals.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CashDisbursementsJournalScalarFieldEnum>
  }


  /**
   * CashDisbursementsJournal create
   */
  export type CashDisbursementsJournalCreateArgs = {
    /**
     * Select specific fields to fetch from the CashDisbursementsJournal
     * 
    **/
    select?: CashDisbursementsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashDisbursementsJournalInclude | null
    /**
     * The data needed to create a CashDisbursementsJournal.
     * 
    **/
    data: XOR<CashDisbursementsJournalCreateInput, CashDisbursementsJournalUncheckedCreateInput>
  }


  /**
   * CashDisbursementsJournal createMany
   */
  export type CashDisbursementsJournalCreateManyArgs = {
    /**
     * The data used to create many CashDisbursementsJournals.
     * 
    **/
    data: Enumerable<CashDisbursementsJournalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CashDisbursementsJournal update
   */
  export type CashDisbursementsJournalUpdateArgs = {
    /**
     * Select specific fields to fetch from the CashDisbursementsJournal
     * 
    **/
    select?: CashDisbursementsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashDisbursementsJournalInclude | null
    /**
     * The data needed to update a CashDisbursementsJournal.
     * 
    **/
    data: XOR<CashDisbursementsJournalUpdateInput, CashDisbursementsJournalUncheckedUpdateInput>
    /**
     * Choose, which CashDisbursementsJournal to update.
     * 
    **/
    where: CashDisbursementsJournalWhereUniqueInput
  }


  /**
   * CashDisbursementsJournal updateMany
   */
  export type CashDisbursementsJournalUpdateManyArgs = {
    /**
     * The data used to update CashDisbursementsJournals.
     * 
    **/
    data: XOR<CashDisbursementsJournalUpdateManyMutationInput, CashDisbursementsJournalUncheckedUpdateManyInput>
    /**
     * Filter which CashDisbursementsJournals to update
     * 
    **/
    where?: CashDisbursementsJournalWhereInput
  }


  /**
   * CashDisbursementsJournal upsert
   */
  export type CashDisbursementsJournalUpsertArgs = {
    /**
     * Select specific fields to fetch from the CashDisbursementsJournal
     * 
    **/
    select?: CashDisbursementsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashDisbursementsJournalInclude | null
    /**
     * The filter to search for the CashDisbursementsJournal to update in case it exists.
     * 
    **/
    where: CashDisbursementsJournalWhereUniqueInput
    /**
     * In case the CashDisbursementsJournal found by the `where` argument doesn't exist, create a new CashDisbursementsJournal with this data.
     * 
    **/
    create: XOR<CashDisbursementsJournalCreateInput, CashDisbursementsJournalUncheckedCreateInput>
    /**
     * In case the CashDisbursementsJournal was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CashDisbursementsJournalUpdateInput, CashDisbursementsJournalUncheckedUpdateInput>
  }


  /**
   * CashDisbursementsJournal delete
   */
  export type CashDisbursementsJournalDeleteArgs = {
    /**
     * Select specific fields to fetch from the CashDisbursementsJournal
     * 
    **/
    select?: CashDisbursementsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashDisbursementsJournalInclude | null
    /**
     * Filter which CashDisbursementsJournal to delete.
     * 
    **/
    where: CashDisbursementsJournalWhereUniqueInput
  }


  /**
   * CashDisbursementsJournal deleteMany
   */
  export type CashDisbursementsJournalDeleteManyArgs = {
    /**
     * Filter which CashDisbursementsJournals to delete
     * 
    **/
    where?: CashDisbursementsJournalWhereInput
  }


  /**
   * CashDisbursementsJournal: findUniqueOrThrow
   */
  export type CashDisbursementsJournalFindUniqueOrThrowArgs = CashDisbursementsJournalFindUniqueArgsBase
      

  /**
   * CashDisbursementsJournal: findFirstOrThrow
   */
  export type CashDisbursementsJournalFindFirstOrThrowArgs = CashDisbursementsJournalFindFirstArgsBase
      

  /**
   * CashDisbursementsJournal without action
   */
  export type CashDisbursementsJournalArgs = {
    /**
     * Select specific fields to fetch from the CashDisbursementsJournal
     * 
    **/
    select?: CashDisbursementsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashDisbursementsJournalInclude | null
  }



  /**
   * Model CashReceiptsJournal
   */


  export type AggregateCashReceiptsJournal = {
    _count: CashReceiptsJournalCountAggregateOutputType | null
    _avg: CashReceiptsJournalAvgAggregateOutputType | null
    _sum: CashReceiptsJournalSumAggregateOutputType | null
    _min: CashReceiptsJournalMinAggregateOutputType | null
    _max: CashReceiptsJournalMaxAggregateOutputType | null
  }

  export type CashReceiptsJournalAvgAggregateOutputType = {
    recorderId: number | null
    transactionId: number | null
    amount: Decimal | null
  }

  export type CashReceiptsJournalSumAggregateOutputType = {
    recorderId: number | null
    transactionId: number | null
    amount: Decimal | null
  }

  export type CashReceiptsJournalMinAggregateOutputType = {
    id: string | null
    recorderId: number | null
    supplierId: string | null
    customerId: string | null
    transactionId: number | null
    narration: string | null
    amount: Decimal | null
  }

  export type CashReceiptsJournalMaxAggregateOutputType = {
    id: string | null
    recorderId: number | null
    supplierId: string | null
    customerId: string | null
    transactionId: number | null
    narration: string | null
    amount: Decimal | null
  }

  export type CashReceiptsJournalCountAggregateOutputType = {
    id: number
    recorderId: number
    supplierId: number
    customerId: number
    transactionId: number
    narration: number
    amount: number
    _all: number
  }


  export type CashReceiptsJournalAvgAggregateInputType = {
    recorderId?: true
    transactionId?: true
    amount?: true
  }

  export type CashReceiptsJournalSumAggregateInputType = {
    recorderId?: true
    transactionId?: true
    amount?: true
  }

  export type CashReceiptsJournalMinAggregateInputType = {
    id?: true
    recorderId?: true
    supplierId?: true
    customerId?: true
    transactionId?: true
    narration?: true
    amount?: true
  }

  export type CashReceiptsJournalMaxAggregateInputType = {
    id?: true
    recorderId?: true
    supplierId?: true
    customerId?: true
    transactionId?: true
    narration?: true
    amount?: true
  }

  export type CashReceiptsJournalCountAggregateInputType = {
    id?: true
    recorderId?: true
    supplierId?: true
    customerId?: true
    transactionId?: true
    narration?: true
    amount?: true
    _all?: true
  }

  export type CashReceiptsJournalAggregateArgs = {
    /**
     * Filter which CashReceiptsJournal to aggregate.
     * 
    **/
    where?: CashReceiptsJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashReceiptsJournals to fetch.
     * 
    **/
    orderBy?: Enumerable<CashReceiptsJournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CashReceiptsJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashReceiptsJournals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashReceiptsJournals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashReceiptsJournals
    **/
    _count?: true | CashReceiptsJournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashReceiptsJournalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashReceiptsJournalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashReceiptsJournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashReceiptsJournalMaxAggregateInputType
  }

  export type GetCashReceiptsJournalAggregateType<T extends CashReceiptsJournalAggregateArgs> = {
        [P in keyof T & keyof AggregateCashReceiptsJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashReceiptsJournal[P]>
      : GetScalarType<T[P], AggregateCashReceiptsJournal[P]>
  }




  export type CashReceiptsJournalGroupByArgs = {
    where?: CashReceiptsJournalWhereInput
    orderBy?: Enumerable<CashReceiptsJournalOrderByWithAggregationInput>
    by: Array<CashReceiptsJournalScalarFieldEnum>
    having?: CashReceiptsJournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashReceiptsJournalCountAggregateInputType | true
    _avg?: CashReceiptsJournalAvgAggregateInputType
    _sum?: CashReceiptsJournalSumAggregateInputType
    _min?: CashReceiptsJournalMinAggregateInputType
    _max?: CashReceiptsJournalMaxAggregateInputType
  }


  export type CashReceiptsJournalGroupByOutputType = {
    id: string
    recorderId: number
    supplierId: string | null
    customerId: string | null
    transactionId: number
    narration: string
    amount: Decimal
    _count: CashReceiptsJournalCountAggregateOutputType | null
    _avg: CashReceiptsJournalAvgAggregateOutputType | null
    _sum: CashReceiptsJournalSumAggregateOutputType | null
    _min: CashReceiptsJournalMinAggregateOutputType | null
    _max: CashReceiptsJournalMaxAggregateOutputType | null
  }

  type GetCashReceiptsJournalGroupByPayload<T extends CashReceiptsJournalGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CashReceiptsJournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashReceiptsJournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashReceiptsJournalGroupByOutputType[P]>
            : GetScalarType<T[P], CashReceiptsJournalGroupByOutputType[P]>
        }
      >
    >


  export type CashReceiptsJournalSelect = {
    id?: boolean
    recorder?: boolean | UserArgs
    recorderId?: boolean
    supplier?: boolean | SupplierArgs
    supplierId?: boolean
    customer?: boolean | CustomerArgs
    customerId?: boolean
    transaction?: boolean | TransactionArgs
    transactionId?: boolean
    narration?: boolean
    amount?: boolean
  }

  export type CashReceiptsJournalInclude = {
    recorder?: boolean | UserArgs
    supplier?: boolean | SupplierArgs
    customer?: boolean | CustomerArgs
    transaction?: boolean | TransactionArgs
  }

  export type CashReceiptsJournalGetPayload<
    S extends boolean | null | undefined | CashReceiptsJournalArgs,
    U = keyof S
      > = S extends true
        ? CashReceiptsJournal
    : S extends undefined
    ? never
    : S extends CashReceiptsJournalArgs | CashReceiptsJournalFindManyArgs
    ?'include' extends U
    ? CashReceiptsJournal  & {
    [P in TrueKeys<S['include']>]:
        P extends 'recorder' ? UserGetPayload<S['include'][P]> :
        P extends 'supplier' ? SupplierGetPayload<S['include'][P]> | null :
        P extends 'customer' ? CustomerGetPayload<S['include'][P]> | null :
        P extends 'transaction' ? TransactionGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'recorder' ? UserGetPayload<S['select'][P]> :
        P extends 'supplier' ? SupplierGetPayload<S['select'][P]> | null :
        P extends 'customer' ? CustomerGetPayload<S['select'][P]> | null :
        P extends 'transaction' ? TransactionGetPayload<S['select'][P]> :  P extends keyof CashReceiptsJournal ? CashReceiptsJournal[P] : never
  } 
    : CashReceiptsJournal
  : CashReceiptsJournal


  type CashReceiptsJournalCountArgs = Merge<
    Omit<CashReceiptsJournalFindManyArgs, 'select' | 'include'> & {
      select?: CashReceiptsJournalCountAggregateInputType | true
    }
  >

  export interface CashReceiptsJournalDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CashReceiptsJournal that matches the filter.
     * @param {CashReceiptsJournalFindUniqueArgs} args - Arguments to find a CashReceiptsJournal
     * @example
     * // Get one CashReceiptsJournal
     * const cashReceiptsJournal = await prisma.cashReceiptsJournal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CashReceiptsJournalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CashReceiptsJournalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CashReceiptsJournal'> extends True ? CheckSelect<T, Prisma__CashReceiptsJournalClient<CashReceiptsJournal>, Prisma__CashReceiptsJournalClient<CashReceiptsJournalGetPayload<T>>> : CheckSelect<T, Prisma__CashReceiptsJournalClient<CashReceiptsJournal | null >, Prisma__CashReceiptsJournalClient<CashReceiptsJournalGetPayload<T> | null >>

    /**
     * Find the first CashReceiptsJournal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashReceiptsJournalFindFirstArgs} args - Arguments to find a CashReceiptsJournal
     * @example
     * // Get one CashReceiptsJournal
     * const cashReceiptsJournal = await prisma.cashReceiptsJournal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CashReceiptsJournalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CashReceiptsJournalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CashReceiptsJournal'> extends True ? CheckSelect<T, Prisma__CashReceiptsJournalClient<CashReceiptsJournal>, Prisma__CashReceiptsJournalClient<CashReceiptsJournalGetPayload<T>>> : CheckSelect<T, Prisma__CashReceiptsJournalClient<CashReceiptsJournal | null >, Prisma__CashReceiptsJournalClient<CashReceiptsJournalGetPayload<T> | null >>

    /**
     * Find zero or more CashReceiptsJournals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashReceiptsJournalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashReceiptsJournals
     * const cashReceiptsJournals = await prisma.cashReceiptsJournal.findMany()
     * 
     * // Get first 10 CashReceiptsJournals
     * const cashReceiptsJournals = await prisma.cashReceiptsJournal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashReceiptsJournalWithIdOnly = await prisma.cashReceiptsJournal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CashReceiptsJournalFindManyArgs>(
      args?: SelectSubset<T, CashReceiptsJournalFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CashReceiptsJournal>>, PrismaPromise<Array<CashReceiptsJournalGetPayload<T>>>>

    /**
     * Create a CashReceiptsJournal.
     * @param {CashReceiptsJournalCreateArgs} args - Arguments to create a CashReceiptsJournal.
     * @example
     * // Create one CashReceiptsJournal
     * const CashReceiptsJournal = await prisma.cashReceiptsJournal.create({
     *   data: {
     *     // ... data to create a CashReceiptsJournal
     *   }
     * })
     * 
    **/
    create<T extends CashReceiptsJournalCreateArgs>(
      args: SelectSubset<T, CashReceiptsJournalCreateArgs>
    ): CheckSelect<T, Prisma__CashReceiptsJournalClient<CashReceiptsJournal>, Prisma__CashReceiptsJournalClient<CashReceiptsJournalGetPayload<T>>>

    /**
     * Create many CashReceiptsJournals.
     *     @param {CashReceiptsJournalCreateManyArgs} args - Arguments to create many CashReceiptsJournals.
     *     @example
     *     // Create many CashReceiptsJournals
     *     const cashReceiptsJournal = await prisma.cashReceiptsJournal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CashReceiptsJournalCreateManyArgs>(
      args?: SelectSubset<T, CashReceiptsJournalCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CashReceiptsJournal.
     * @param {CashReceiptsJournalDeleteArgs} args - Arguments to delete one CashReceiptsJournal.
     * @example
     * // Delete one CashReceiptsJournal
     * const CashReceiptsJournal = await prisma.cashReceiptsJournal.delete({
     *   where: {
     *     // ... filter to delete one CashReceiptsJournal
     *   }
     * })
     * 
    **/
    delete<T extends CashReceiptsJournalDeleteArgs>(
      args: SelectSubset<T, CashReceiptsJournalDeleteArgs>
    ): CheckSelect<T, Prisma__CashReceiptsJournalClient<CashReceiptsJournal>, Prisma__CashReceiptsJournalClient<CashReceiptsJournalGetPayload<T>>>

    /**
     * Update one CashReceiptsJournal.
     * @param {CashReceiptsJournalUpdateArgs} args - Arguments to update one CashReceiptsJournal.
     * @example
     * // Update one CashReceiptsJournal
     * const cashReceiptsJournal = await prisma.cashReceiptsJournal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CashReceiptsJournalUpdateArgs>(
      args: SelectSubset<T, CashReceiptsJournalUpdateArgs>
    ): CheckSelect<T, Prisma__CashReceiptsJournalClient<CashReceiptsJournal>, Prisma__CashReceiptsJournalClient<CashReceiptsJournalGetPayload<T>>>

    /**
     * Delete zero or more CashReceiptsJournals.
     * @param {CashReceiptsJournalDeleteManyArgs} args - Arguments to filter CashReceiptsJournals to delete.
     * @example
     * // Delete a few CashReceiptsJournals
     * const { count } = await prisma.cashReceiptsJournal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CashReceiptsJournalDeleteManyArgs>(
      args?: SelectSubset<T, CashReceiptsJournalDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashReceiptsJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashReceiptsJournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashReceiptsJournals
     * const cashReceiptsJournal = await prisma.cashReceiptsJournal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CashReceiptsJournalUpdateManyArgs>(
      args: SelectSubset<T, CashReceiptsJournalUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CashReceiptsJournal.
     * @param {CashReceiptsJournalUpsertArgs} args - Arguments to update or create a CashReceiptsJournal.
     * @example
     * // Update or create a CashReceiptsJournal
     * const cashReceiptsJournal = await prisma.cashReceiptsJournal.upsert({
     *   create: {
     *     // ... data to create a CashReceiptsJournal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashReceiptsJournal we want to update
     *   }
     * })
    **/
    upsert<T extends CashReceiptsJournalUpsertArgs>(
      args: SelectSubset<T, CashReceiptsJournalUpsertArgs>
    ): CheckSelect<T, Prisma__CashReceiptsJournalClient<CashReceiptsJournal>, Prisma__CashReceiptsJournalClient<CashReceiptsJournalGetPayload<T>>>

    /**
     * Find one CashReceiptsJournal that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CashReceiptsJournalFindUniqueOrThrowArgs} args - Arguments to find a CashReceiptsJournal
     * @example
     * // Get one CashReceiptsJournal
     * const cashReceiptsJournal = await prisma.cashReceiptsJournal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CashReceiptsJournalFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CashReceiptsJournalFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CashReceiptsJournalClient<CashReceiptsJournal>, Prisma__CashReceiptsJournalClient<CashReceiptsJournalGetPayload<T>>>

    /**
     * Find the first CashReceiptsJournal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashReceiptsJournalFindFirstOrThrowArgs} args - Arguments to find a CashReceiptsJournal
     * @example
     * // Get one CashReceiptsJournal
     * const cashReceiptsJournal = await prisma.cashReceiptsJournal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CashReceiptsJournalFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CashReceiptsJournalFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CashReceiptsJournalClient<CashReceiptsJournal>, Prisma__CashReceiptsJournalClient<CashReceiptsJournalGetPayload<T>>>

    /**
     * Count the number of CashReceiptsJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashReceiptsJournalCountArgs} args - Arguments to filter CashReceiptsJournals to count.
     * @example
     * // Count the number of CashReceiptsJournals
     * const count = await prisma.cashReceiptsJournal.count({
     *   where: {
     *     // ... the filter for the CashReceiptsJournals we want to count
     *   }
     * })
    **/
    count<T extends CashReceiptsJournalCountArgs>(
      args?: Subset<T, CashReceiptsJournalCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashReceiptsJournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashReceiptsJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashReceiptsJournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashReceiptsJournalAggregateArgs>(args: Subset<T, CashReceiptsJournalAggregateArgs>): PrismaPromise<GetCashReceiptsJournalAggregateType<T>>

    /**
     * Group by CashReceiptsJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashReceiptsJournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashReceiptsJournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashReceiptsJournalGroupByArgs['orderBy'] }
        : { orderBy?: CashReceiptsJournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashReceiptsJournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashReceiptsJournalGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashReceiptsJournal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CashReceiptsJournalClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    recorder<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    supplier<T extends SupplierArgs = {}>(args?: Subset<T, SupplierArgs>): CheckSelect<T, Prisma__SupplierClient<Supplier | null >, Prisma__SupplierClient<SupplierGetPayload<T> | null >>;

    customer<T extends CustomerArgs = {}>(args?: Subset<T, CustomerArgs>): CheckSelect<T, Prisma__CustomerClient<Customer | null >, Prisma__CustomerClient<CustomerGetPayload<T> | null >>;

    transaction<T extends TransactionArgs = {}>(args?: Subset<T, TransactionArgs>): CheckSelect<T, Prisma__TransactionClient<Transaction | null >, Prisma__TransactionClient<TransactionGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CashReceiptsJournal base type for findUnique actions
   */
  export type CashReceiptsJournalFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CashReceiptsJournal
     * 
    **/
    select?: CashReceiptsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashReceiptsJournalInclude | null
    /**
     * Filter, which CashReceiptsJournal to fetch.
     * 
    **/
    where: CashReceiptsJournalWhereUniqueInput
  }

  /**
   * CashReceiptsJournal: findUnique
   */
  export interface CashReceiptsJournalFindUniqueArgs extends CashReceiptsJournalFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CashReceiptsJournal base type for findFirst actions
   */
  export type CashReceiptsJournalFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CashReceiptsJournal
     * 
    **/
    select?: CashReceiptsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashReceiptsJournalInclude | null
    /**
     * Filter, which CashReceiptsJournal to fetch.
     * 
    **/
    where?: CashReceiptsJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashReceiptsJournals to fetch.
     * 
    **/
    orderBy?: Enumerable<CashReceiptsJournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashReceiptsJournals.
     * 
    **/
    cursor?: CashReceiptsJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashReceiptsJournals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashReceiptsJournals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashReceiptsJournals.
     * 
    **/
    distinct?: Enumerable<CashReceiptsJournalScalarFieldEnum>
  }

  /**
   * CashReceiptsJournal: findFirst
   */
  export interface CashReceiptsJournalFindFirstArgs extends CashReceiptsJournalFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CashReceiptsJournal findMany
   */
  export type CashReceiptsJournalFindManyArgs = {
    /**
     * Select specific fields to fetch from the CashReceiptsJournal
     * 
    **/
    select?: CashReceiptsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashReceiptsJournalInclude | null
    /**
     * Filter, which CashReceiptsJournals to fetch.
     * 
    **/
    where?: CashReceiptsJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashReceiptsJournals to fetch.
     * 
    **/
    orderBy?: Enumerable<CashReceiptsJournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashReceiptsJournals.
     * 
    **/
    cursor?: CashReceiptsJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashReceiptsJournals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashReceiptsJournals.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CashReceiptsJournalScalarFieldEnum>
  }


  /**
   * CashReceiptsJournal create
   */
  export type CashReceiptsJournalCreateArgs = {
    /**
     * Select specific fields to fetch from the CashReceiptsJournal
     * 
    **/
    select?: CashReceiptsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashReceiptsJournalInclude | null
    /**
     * The data needed to create a CashReceiptsJournal.
     * 
    **/
    data: XOR<CashReceiptsJournalCreateInput, CashReceiptsJournalUncheckedCreateInput>
  }


  /**
   * CashReceiptsJournal createMany
   */
  export type CashReceiptsJournalCreateManyArgs = {
    /**
     * The data used to create many CashReceiptsJournals.
     * 
    **/
    data: Enumerable<CashReceiptsJournalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CashReceiptsJournal update
   */
  export type CashReceiptsJournalUpdateArgs = {
    /**
     * Select specific fields to fetch from the CashReceiptsJournal
     * 
    **/
    select?: CashReceiptsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashReceiptsJournalInclude | null
    /**
     * The data needed to update a CashReceiptsJournal.
     * 
    **/
    data: XOR<CashReceiptsJournalUpdateInput, CashReceiptsJournalUncheckedUpdateInput>
    /**
     * Choose, which CashReceiptsJournal to update.
     * 
    **/
    where: CashReceiptsJournalWhereUniqueInput
  }


  /**
   * CashReceiptsJournal updateMany
   */
  export type CashReceiptsJournalUpdateManyArgs = {
    /**
     * The data used to update CashReceiptsJournals.
     * 
    **/
    data: XOR<CashReceiptsJournalUpdateManyMutationInput, CashReceiptsJournalUncheckedUpdateManyInput>
    /**
     * Filter which CashReceiptsJournals to update
     * 
    **/
    where?: CashReceiptsJournalWhereInput
  }


  /**
   * CashReceiptsJournal upsert
   */
  export type CashReceiptsJournalUpsertArgs = {
    /**
     * Select specific fields to fetch from the CashReceiptsJournal
     * 
    **/
    select?: CashReceiptsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashReceiptsJournalInclude | null
    /**
     * The filter to search for the CashReceiptsJournal to update in case it exists.
     * 
    **/
    where: CashReceiptsJournalWhereUniqueInput
    /**
     * In case the CashReceiptsJournal found by the `where` argument doesn't exist, create a new CashReceiptsJournal with this data.
     * 
    **/
    create: XOR<CashReceiptsJournalCreateInput, CashReceiptsJournalUncheckedCreateInput>
    /**
     * In case the CashReceiptsJournal was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CashReceiptsJournalUpdateInput, CashReceiptsJournalUncheckedUpdateInput>
  }


  /**
   * CashReceiptsJournal delete
   */
  export type CashReceiptsJournalDeleteArgs = {
    /**
     * Select specific fields to fetch from the CashReceiptsJournal
     * 
    **/
    select?: CashReceiptsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashReceiptsJournalInclude | null
    /**
     * Filter which CashReceiptsJournal to delete.
     * 
    **/
    where: CashReceiptsJournalWhereUniqueInput
  }


  /**
   * CashReceiptsJournal deleteMany
   */
  export type CashReceiptsJournalDeleteManyArgs = {
    /**
     * Filter which CashReceiptsJournals to delete
     * 
    **/
    where?: CashReceiptsJournalWhereInput
  }


  /**
   * CashReceiptsJournal: findUniqueOrThrow
   */
  export type CashReceiptsJournalFindUniqueOrThrowArgs = CashReceiptsJournalFindUniqueArgsBase
      

  /**
   * CashReceiptsJournal: findFirstOrThrow
   */
  export type CashReceiptsJournalFindFirstOrThrowArgs = CashReceiptsJournalFindFirstArgsBase
      

  /**
   * CashReceiptsJournal without action
   */
  export type CashReceiptsJournalArgs = {
    /**
     * Select specific fields to fetch from the CashReceiptsJournal
     * 
    **/
    select?: CashReceiptsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashReceiptsJournalInclude | null
  }



  /**
   * Model ReturnsInwardsJournal
   */


  export type AggregateReturnsInwardsJournal = {
    _count: ReturnsInwardsJournalCountAggregateOutputType | null
    _avg: ReturnsInwardsJournalAvgAggregateOutputType | null
    _sum: ReturnsInwardsJournalSumAggregateOutputType | null
    _min: ReturnsInwardsJournalMinAggregateOutputType | null
    _max: ReturnsInwardsJournalMaxAggregateOutputType | null
  }

  export type ReturnsInwardsJournalAvgAggregateOutputType = {
    recorderId: number | null
    transactionId: number | null
    amount: Decimal | null
  }

  export type ReturnsInwardsJournalSumAggregateOutputType = {
    recorderId: number | null
    transactionId: number | null
    amount: Decimal | null
  }

  export type ReturnsInwardsJournalMinAggregateOutputType = {
    id: string | null
    recorderId: number | null
    customerId: string | null
    transactionId: number | null
    narration: string | null
    amount: Decimal | null
  }

  export type ReturnsInwardsJournalMaxAggregateOutputType = {
    id: string | null
    recorderId: number | null
    customerId: string | null
    transactionId: number | null
    narration: string | null
    amount: Decimal | null
  }

  export type ReturnsInwardsJournalCountAggregateOutputType = {
    id: number
    recorderId: number
    customerId: number
    transactionId: number
    narration: number
    amount: number
    _all: number
  }


  export type ReturnsInwardsJournalAvgAggregateInputType = {
    recorderId?: true
    transactionId?: true
    amount?: true
  }

  export type ReturnsInwardsJournalSumAggregateInputType = {
    recorderId?: true
    transactionId?: true
    amount?: true
  }

  export type ReturnsInwardsJournalMinAggregateInputType = {
    id?: true
    recorderId?: true
    customerId?: true
    transactionId?: true
    narration?: true
    amount?: true
  }

  export type ReturnsInwardsJournalMaxAggregateInputType = {
    id?: true
    recorderId?: true
    customerId?: true
    transactionId?: true
    narration?: true
    amount?: true
  }

  export type ReturnsInwardsJournalCountAggregateInputType = {
    id?: true
    recorderId?: true
    customerId?: true
    transactionId?: true
    narration?: true
    amount?: true
    _all?: true
  }

  export type ReturnsInwardsJournalAggregateArgs = {
    /**
     * Filter which ReturnsInwardsJournal to aggregate.
     * 
    **/
    where?: ReturnsInwardsJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnsInwardsJournals to fetch.
     * 
    **/
    orderBy?: Enumerable<ReturnsInwardsJournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ReturnsInwardsJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnsInwardsJournals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnsInwardsJournals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReturnsInwardsJournals
    **/
    _count?: true | ReturnsInwardsJournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReturnsInwardsJournalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReturnsInwardsJournalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReturnsInwardsJournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReturnsInwardsJournalMaxAggregateInputType
  }

  export type GetReturnsInwardsJournalAggregateType<T extends ReturnsInwardsJournalAggregateArgs> = {
        [P in keyof T & keyof AggregateReturnsInwardsJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReturnsInwardsJournal[P]>
      : GetScalarType<T[P], AggregateReturnsInwardsJournal[P]>
  }




  export type ReturnsInwardsJournalGroupByArgs = {
    where?: ReturnsInwardsJournalWhereInput
    orderBy?: Enumerable<ReturnsInwardsJournalOrderByWithAggregationInput>
    by: Array<ReturnsInwardsJournalScalarFieldEnum>
    having?: ReturnsInwardsJournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReturnsInwardsJournalCountAggregateInputType | true
    _avg?: ReturnsInwardsJournalAvgAggregateInputType
    _sum?: ReturnsInwardsJournalSumAggregateInputType
    _min?: ReturnsInwardsJournalMinAggregateInputType
    _max?: ReturnsInwardsJournalMaxAggregateInputType
  }


  export type ReturnsInwardsJournalGroupByOutputType = {
    id: string
    recorderId: number
    customerId: string
    transactionId: number
    narration: string
    amount: Decimal
    _count: ReturnsInwardsJournalCountAggregateOutputType | null
    _avg: ReturnsInwardsJournalAvgAggregateOutputType | null
    _sum: ReturnsInwardsJournalSumAggregateOutputType | null
    _min: ReturnsInwardsJournalMinAggregateOutputType | null
    _max: ReturnsInwardsJournalMaxAggregateOutputType | null
  }

  type GetReturnsInwardsJournalGroupByPayload<T extends ReturnsInwardsJournalGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReturnsInwardsJournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReturnsInwardsJournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReturnsInwardsJournalGroupByOutputType[P]>
            : GetScalarType<T[P], ReturnsInwardsJournalGroupByOutputType[P]>
        }
      >
    >


  export type ReturnsInwardsJournalSelect = {
    id?: boolean
    recorder?: boolean | UserArgs
    recorderId?: boolean
    customer?: boolean | CustomerArgs
    customerId?: boolean
    transaction?: boolean | TransactionArgs
    transactionId?: boolean
    narration?: boolean
    amount?: boolean
  }

  export type ReturnsInwardsJournalInclude = {
    recorder?: boolean | UserArgs
    customer?: boolean | CustomerArgs
    transaction?: boolean | TransactionArgs
  }

  export type ReturnsInwardsJournalGetPayload<
    S extends boolean | null | undefined | ReturnsInwardsJournalArgs,
    U = keyof S
      > = S extends true
        ? ReturnsInwardsJournal
    : S extends undefined
    ? never
    : S extends ReturnsInwardsJournalArgs | ReturnsInwardsJournalFindManyArgs
    ?'include' extends U
    ? ReturnsInwardsJournal  & {
    [P in TrueKeys<S['include']>]:
        P extends 'recorder' ? UserGetPayload<S['include'][P]> :
        P extends 'customer' ? CustomerGetPayload<S['include'][P]> :
        P extends 'transaction' ? TransactionGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'recorder' ? UserGetPayload<S['select'][P]> :
        P extends 'customer' ? CustomerGetPayload<S['select'][P]> :
        P extends 'transaction' ? TransactionGetPayload<S['select'][P]> :  P extends keyof ReturnsInwardsJournal ? ReturnsInwardsJournal[P] : never
  } 
    : ReturnsInwardsJournal
  : ReturnsInwardsJournal


  type ReturnsInwardsJournalCountArgs = Merge<
    Omit<ReturnsInwardsJournalFindManyArgs, 'select' | 'include'> & {
      select?: ReturnsInwardsJournalCountAggregateInputType | true
    }
  >

  export interface ReturnsInwardsJournalDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ReturnsInwardsJournal that matches the filter.
     * @param {ReturnsInwardsJournalFindUniqueArgs} args - Arguments to find a ReturnsInwardsJournal
     * @example
     * // Get one ReturnsInwardsJournal
     * const returnsInwardsJournal = await prisma.returnsInwardsJournal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReturnsInwardsJournalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReturnsInwardsJournalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ReturnsInwardsJournal'> extends True ? CheckSelect<T, Prisma__ReturnsInwardsJournalClient<ReturnsInwardsJournal>, Prisma__ReturnsInwardsJournalClient<ReturnsInwardsJournalGetPayload<T>>> : CheckSelect<T, Prisma__ReturnsInwardsJournalClient<ReturnsInwardsJournal | null >, Prisma__ReturnsInwardsJournalClient<ReturnsInwardsJournalGetPayload<T> | null >>

    /**
     * Find the first ReturnsInwardsJournal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsInwardsJournalFindFirstArgs} args - Arguments to find a ReturnsInwardsJournal
     * @example
     * // Get one ReturnsInwardsJournal
     * const returnsInwardsJournal = await prisma.returnsInwardsJournal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReturnsInwardsJournalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReturnsInwardsJournalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ReturnsInwardsJournal'> extends True ? CheckSelect<T, Prisma__ReturnsInwardsJournalClient<ReturnsInwardsJournal>, Prisma__ReturnsInwardsJournalClient<ReturnsInwardsJournalGetPayload<T>>> : CheckSelect<T, Prisma__ReturnsInwardsJournalClient<ReturnsInwardsJournal | null >, Prisma__ReturnsInwardsJournalClient<ReturnsInwardsJournalGetPayload<T> | null >>

    /**
     * Find zero or more ReturnsInwardsJournals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsInwardsJournalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReturnsInwardsJournals
     * const returnsInwardsJournals = await prisma.returnsInwardsJournal.findMany()
     * 
     * // Get first 10 ReturnsInwardsJournals
     * const returnsInwardsJournals = await prisma.returnsInwardsJournal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const returnsInwardsJournalWithIdOnly = await prisma.returnsInwardsJournal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReturnsInwardsJournalFindManyArgs>(
      args?: SelectSubset<T, ReturnsInwardsJournalFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ReturnsInwardsJournal>>, PrismaPromise<Array<ReturnsInwardsJournalGetPayload<T>>>>

    /**
     * Create a ReturnsInwardsJournal.
     * @param {ReturnsInwardsJournalCreateArgs} args - Arguments to create a ReturnsInwardsJournal.
     * @example
     * // Create one ReturnsInwardsJournal
     * const ReturnsInwardsJournal = await prisma.returnsInwardsJournal.create({
     *   data: {
     *     // ... data to create a ReturnsInwardsJournal
     *   }
     * })
     * 
    **/
    create<T extends ReturnsInwardsJournalCreateArgs>(
      args: SelectSubset<T, ReturnsInwardsJournalCreateArgs>
    ): CheckSelect<T, Prisma__ReturnsInwardsJournalClient<ReturnsInwardsJournal>, Prisma__ReturnsInwardsJournalClient<ReturnsInwardsJournalGetPayload<T>>>

    /**
     * Create many ReturnsInwardsJournals.
     *     @param {ReturnsInwardsJournalCreateManyArgs} args - Arguments to create many ReturnsInwardsJournals.
     *     @example
     *     // Create many ReturnsInwardsJournals
     *     const returnsInwardsJournal = await prisma.returnsInwardsJournal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReturnsInwardsJournalCreateManyArgs>(
      args?: SelectSubset<T, ReturnsInwardsJournalCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ReturnsInwardsJournal.
     * @param {ReturnsInwardsJournalDeleteArgs} args - Arguments to delete one ReturnsInwardsJournal.
     * @example
     * // Delete one ReturnsInwardsJournal
     * const ReturnsInwardsJournal = await prisma.returnsInwardsJournal.delete({
     *   where: {
     *     // ... filter to delete one ReturnsInwardsJournal
     *   }
     * })
     * 
    **/
    delete<T extends ReturnsInwardsJournalDeleteArgs>(
      args: SelectSubset<T, ReturnsInwardsJournalDeleteArgs>
    ): CheckSelect<T, Prisma__ReturnsInwardsJournalClient<ReturnsInwardsJournal>, Prisma__ReturnsInwardsJournalClient<ReturnsInwardsJournalGetPayload<T>>>

    /**
     * Update one ReturnsInwardsJournal.
     * @param {ReturnsInwardsJournalUpdateArgs} args - Arguments to update one ReturnsInwardsJournal.
     * @example
     * // Update one ReturnsInwardsJournal
     * const returnsInwardsJournal = await prisma.returnsInwardsJournal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReturnsInwardsJournalUpdateArgs>(
      args: SelectSubset<T, ReturnsInwardsJournalUpdateArgs>
    ): CheckSelect<T, Prisma__ReturnsInwardsJournalClient<ReturnsInwardsJournal>, Prisma__ReturnsInwardsJournalClient<ReturnsInwardsJournalGetPayload<T>>>

    /**
     * Delete zero or more ReturnsInwardsJournals.
     * @param {ReturnsInwardsJournalDeleteManyArgs} args - Arguments to filter ReturnsInwardsJournals to delete.
     * @example
     * // Delete a few ReturnsInwardsJournals
     * const { count } = await prisma.returnsInwardsJournal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReturnsInwardsJournalDeleteManyArgs>(
      args?: SelectSubset<T, ReturnsInwardsJournalDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReturnsInwardsJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsInwardsJournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReturnsInwardsJournals
     * const returnsInwardsJournal = await prisma.returnsInwardsJournal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReturnsInwardsJournalUpdateManyArgs>(
      args: SelectSubset<T, ReturnsInwardsJournalUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ReturnsInwardsJournal.
     * @param {ReturnsInwardsJournalUpsertArgs} args - Arguments to update or create a ReturnsInwardsJournal.
     * @example
     * // Update or create a ReturnsInwardsJournal
     * const returnsInwardsJournal = await prisma.returnsInwardsJournal.upsert({
     *   create: {
     *     // ... data to create a ReturnsInwardsJournal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReturnsInwardsJournal we want to update
     *   }
     * })
    **/
    upsert<T extends ReturnsInwardsJournalUpsertArgs>(
      args: SelectSubset<T, ReturnsInwardsJournalUpsertArgs>
    ): CheckSelect<T, Prisma__ReturnsInwardsJournalClient<ReturnsInwardsJournal>, Prisma__ReturnsInwardsJournalClient<ReturnsInwardsJournalGetPayload<T>>>

    /**
     * Find one ReturnsInwardsJournal that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ReturnsInwardsJournalFindUniqueOrThrowArgs} args - Arguments to find a ReturnsInwardsJournal
     * @example
     * // Get one ReturnsInwardsJournal
     * const returnsInwardsJournal = await prisma.returnsInwardsJournal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReturnsInwardsJournalFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ReturnsInwardsJournalFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ReturnsInwardsJournalClient<ReturnsInwardsJournal>, Prisma__ReturnsInwardsJournalClient<ReturnsInwardsJournalGetPayload<T>>>

    /**
     * Find the first ReturnsInwardsJournal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsInwardsJournalFindFirstOrThrowArgs} args - Arguments to find a ReturnsInwardsJournal
     * @example
     * // Get one ReturnsInwardsJournal
     * const returnsInwardsJournal = await prisma.returnsInwardsJournal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReturnsInwardsJournalFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReturnsInwardsJournalFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ReturnsInwardsJournalClient<ReturnsInwardsJournal>, Prisma__ReturnsInwardsJournalClient<ReturnsInwardsJournalGetPayload<T>>>

    /**
     * Count the number of ReturnsInwardsJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsInwardsJournalCountArgs} args - Arguments to filter ReturnsInwardsJournals to count.
     * @example
     * // Count the number of ReturnsInwardsJournals
     * const count = await prisma.returnsInwardsJournal.count({
     *   where: {
     *     // ... the filter for the ReturnsInwardsJournals we want to count
     *   }
     * })
    **/
    count<T extends ReturnsInwardsJournalCountArgs>(
      args?: Subset<T, ReturnsInwardsJournalCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReturnsInwardsJournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReturnsInwardsJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsInwardsJournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReturnsInwardsJournalAggregateArgs>(args: Subset<T, ReturnsInwardsJournalAggregateArgs>): PrismaPromise<GetReturnsInwardsJournalAggregateType<T>>

    /**
     * Group by ReturnsInwardsJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsInwardsJournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReturnsInwardsJournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReturnsInwardsJournalGroupByArgs['orderBy'] }
        : { orderBy?: ReturnsInwardsJournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReturnsInwardsJournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReturnsInwardsJournalGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReturnsInwardsJournal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReturnsInwardsJournalClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    recorder<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    customer<T extends CustomerArgs = {}>(args?: Subset<T, CustomerArgs>): CheckSelect<T, Prisma__CustomerClient<Customer | null >, Prisma__CustomerClient<CustomerGetPayload<T> | null >>;

    transaction<T extends TransactionArgs = {}>(args?: Subset<T, TransactionArgs>): CheckSelect<T, Prisma__TransactionClient<Transaction | null >, Prisma__TransactionClient<TransactionGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ReturnsInwardsJournal base type for findUnique actions
   */
  export type ReturnsInwardsJournalFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ReturnsInwardsJournal
     * 
    **/
    select?: ReturnsInwardsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReturnsInwardsJournalInclude | null
    /**
     * Filter, which ReturnsInwardsJournal to fetch.
     * 
    **/
    where: ReturnsInwardsJournalWhereUniqueInput
  }

  /**
   * ReturnsInwardsJournal: findUnique
   */
  export interface ReturnsInwardsJournalFindUniqueArgs extends ReturnsInwardsJournalFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ReturnsInwardsJournal base type for findFirst actions
   */
  export type ReturnsInwardsJournalFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ReturnsInwardsJournal
     * 
    **/
    select?: ReturnsInwardsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReturnsInwardsJournalInclude | null
    /**
     * Filter, which ReturnsInwardsJournal to fetch.
     * 
    **/
    where?: ReturnsInwardsJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnsInwardsJournals to fetch.
     * 
    **/
    orderBy?: Enumerable<ReturnsInwardsJournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReturnsInwardsJournals.
     * 
    **/
    cursor?: ReturnsInwardsJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnsInwardsJournals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnsInwardsJournals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReturnsInwardsJournals.
     * 
    **/
    distinct?: Enumerable<ReturnsInwardsJournalScalarFieldEnum>
  }

  /**
   * ReturnsInwardsJournal: findFirst
   */
  export interface ReturnsInwardsJournalFindFirstArgs extends ReturnsInwardsJournalFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ReturnsInwardsJournal findMany
   */
  export type ReturnsInwardsJournalFindManyArgs = {
    /**
     * Select specific fields to fetch from the ReturnsInwardsJournal
     * 
    **/
    select?: ReturnsInwardsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReturnsInwardsJournalInclude | null
    /**
     * Filter, which ReturnsInwardsJournals to fetch.
     * 
    **/
    where?: ReturnsInwardsJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnsInwardsJournals to fetch.
     * 
    **/
    orderBy?: Enumerable<ReturnsInwardsJournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReturnsInwardsJournals.
     * 
    **/
    cursor?: ReturnsInwardsJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnsInwardsJournals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnsInwardsJournals.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReturnsInwardsJournalScalarFieldEnum>
  }


  /**
   * ReturnsInwardsJournal create
   */
  export type ReturnsInwardsJournalCreateArgs = {
    /**
     * Select specific fields to fetch from the ReturnsInwardsJournal
     * 
    **/
    select?: ReturnsInwardsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReturnsInwardsJournalInclude | null
    /**
     * The data needed to create a ReturnsInwardsJournal.
     * 
    **/
    data: XOR<ReturnsInwardsJournalCreateInput, ReturnsInwardsJournalUncheckedCreateInput>
  }


  /**
   * ReturnsInwardsJournal createMany
   */
  export type ReturnsInwardsJournalCreateManyArgs = {
    /**
     * The data used to create many ReturnsInwardsJournals.
     * 
    **/
    data: Enumerable<ReturnsInwardsJournalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ReturnsInwardsJournal update
   */
  export type ReturnsInwardsJournalUpdateArgs = {
    /**
     * Select specific fields to fetch from the ReturnsInwardsJournal
     * 
    **/
    select?: ReturnsInwardsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReturnsInwardsJournalInclude | null
    /**
     * The data needed to update a ReturnsInwardsJournal.
     * 
    **/
    data: XOR<ReturnsInwardsJournalUpdateInput, ReturnsInwardsJournalUncheckedUpdateInput>
    /**
     * Choose, which ReturnsInwardsJournal to update.
     * 
    **/
    where: ReturnsInwardsJournalWhereUniqueInput
  }


  /**
   * ReturnsInwardsJournal updateMany
   */
  export type ReturnsInwardsJournalUpdateManyArgs = {
    /**
     * The data used to update ReturnsInwardsJournals.
     * 
    **/
    data: XOR<ReturnsInwardsJournalUpdateManyMutationInput, ReturnsInwardsJournalUncheckedUpdateManyInput>
    /**
     * Filter which ReturnsInwardsJournals to update
     * 
    **/
    where?: ReturnsInwardsJournalWhereInput
  }


  /**
   * ReturnsInwardsJournal upsert
   */
  export type ReturnsInwardsJournalUpsertArgs = {
    /**
     * Select specific fields to fetch from the ReturnsInwardsJournal
     * 
    **/
    select?: ReturnsInwardsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReturnsInwardsJournalInclude | null
    /**
     * The filter to search for the ReturnsInwardsJournal to update in case it exists.
     * 
    **/
    where: ReturnsInwardsJournalWhereUniqueInput
    /**
     * In case the ReturnsInwardsJournal found by the `where` argument doesn't exist, create a new ReturnsInwardsJournal with this data.
     * 
    **/
    create: XOR<ReturnsInwardsJournalCreateInput, ReturnsInwardsJournalUncheckedCreateInput>
    /**
     * In case the ReturnsInwardsJournal was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ReturnsInwardsJournalUpdateInput, ReturnsInwardsJournalUncheckedUpdateInput>
  }


  /**
   * ReturnsInwardsJournal delete
   */
  export type ReturnsInwardsJournalDeleteArgs = {
    /**
     * Select specific fields to fetch from the ReturnsInwardsJournal
     * 
    **/
    select?: ReturnsInwardsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReturnsInwardsJournalInclude | null
    /**
     * Filter which ReturnsInwardsJournal to delete.
     * 
    **/
    where: ReturnsInwardsJournalWhereUniqueInput
  }


  /**
   * ReturnsInwardsJournal deleteMany
   */
  export type ReturnsInwardsJournalDeleteManyArgs = {
    /**
     * Filter which ReturnsInwardsJournals to delete
     * 
    **/
    where?: ReturnsInwardsJournalWhereInput
  }


  /**
   * ReturnsInwardsJournal: findUniqueOrThrow
   */
  export type ReturnsInwardsJournalFindUniqueOrThrowArgs = ReturnsInwardsJournalFindUniqueArgsBase
      

  /**
   * ReturnsInwardsJournal: findFirstOrThrow
   */
  export type ReturnsInwardsJournalFindFirstOrThrowArgs = ReturnsInwardsJournalFindFirstArgsBase
      

  /**
   * ReturnsInwardsJournal without action
   */
  export type ReturnsInwardsJournalArgs = {
    /**
     * Select specific fields to fetch from the ReturnsInwardsJournal
     * 
    **/
    select?: ReturnsInwardsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReturnsInwardsJournalInclude | null
  }



  /**
   * Model ReturnsOutwardsJournal
   */


  export type AggregateReturnsOutwardsJournal = {
    _count: ReturnsOutwardsJournalCountAggregateOutputType | null
    _avg: ReturnsOutwardsJournalAvgAggregateOutputType | null
    _sum: ReturnsOutwardsJournalSumAggregateOutputType | null
    _min: ReturnsOutwardsJournalMinAggregateOutputType | null
    _max: ReturnsOutwardsJournalMaxAggregateOutputType | null
  }

  export type ReturnsOutwardsJournalAvgAggregateOutputType = {
    recorderId: number | null
    transactionId: number | null
    amount: Decimal | null
  }

  export type ReturnsOutwardsJournalSumAggregateOutputType = {
    recorderId: number | null
    transactionId: number | null
    amount: Decimal | null
  }

  export type ReturnsOutwardsJournalMinAggregateOutputType = {
    id: string | null
    recorderId: number | null
    supplierId: string | null
    transactionId: number | null
    narration: string | null
    amount: Decimal | null
  }

  export type ReturnsOutwardsJournalMaxAggregateOutputType = {
    id: string | null
    recorderId: number | null
    supplierId: string | null
    transactionId: number | null
    narration: string | null
    amount: Decimal | null
  }

  export type ReturnsOutwardsJournalCountAggregateOutputType = {
    id: number
    recorderId: number
    supplierId: number
    transactionId: number
    narration: number
    amount: number
    _all: number
  }


  export type ReturnsOutwardsJournalAvgAggregateInputType = {
    recorderId?: true
    transactionId?: true
    amount?: true
  }

  export type ReturnsOutwardsJournalSumAggregateInputType = {
    recorderId?: true
    transactionId?: true
    amount?: true
  }

  export type ReturnsOutwardsJournalMinAggregateInputType = {
    id?: true
    recorderId?: true
    supplierId?: true
    transactionId?: true
    narration?: true
    amount?: true
  }

  export type ReturnsOutwardsJournalMaxAggregateInputType = {
    id?: true
    recorderId?: true
    supplierId?: true
    transactionId?: true
    narration?: true
    amount?: true
  }

  export type ReturnsOutwardsJournalCountAggregateInputType = {
    id?: true
    recorderId?: true
    supplierId?: true
    transactionId?: true
    narration?: true
    amount?: true
    _all?: true
  }

  export type ReturnsOutwardsJournalAggregateArgs = {
    /**
     * Filter which ReturnsOutwardsJournal to aggregate.
     * 
    **/
    where?: ReturnsOutwardsJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnsOutwardsJournals to fetch.
     * 
    **/
    orderBy?: Enumerable<ReturnsOutwardsJournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ReturnsOutwardsJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnsOutwardsJournals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnsOutwardsJournals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReturnsOutwardsJournals
    **/
    _count?: true | ReturnsOutwardsJournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReturnsOutwardsJournalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReturnsOutwardsJournalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReturnsOutwardsJournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReturnsOutwardsJournalMaxAggregateInputType
  }

  export type GetReturnsOutwardsJournalAggregateType<T extends ReturnsOutwardsJournalAggregateArgs> = {
        [P in keyof T & keyof AggregateReturnsOutwardsJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReturnsOutwardsJournal[P]>
      : GetScalarType<T[P], AggregateReturnsOutwardsJournal[P]>
  }




  export type ReturnsOutwardsJournalGroupByArgs = {
    where?: ReturnsOutwardsJournalWhereInput
    orderBy?: Enumerable<ReturnsOutwardsJournalOrderByWithAggregationInput>
    by: Array<ReturnsOutwardsJournalScalarFieldEnum>
    having?: ReturnsOutwardsJournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReturnsOutwardsJournalCountAggregateInputType | true
    _avg?: ReturnsOutwardsJournalAvgAggregateInputType
    _sum?: ReturnsOutwardsJournalSumAggregateInputType
    _min?: ReturnsOutwardsJournalMinAggregateInputType
    _max?: ReturnsOutwardsJournalMaxAggregateInputType
  }


  export type ReturnsOutwardsJournalGroupByOutputType = {
    id: string
    recorderId: number
    supplierId: string
    transactionId: number
    narration: string
    amount: Decimal
    _count: ReturnsOutwardsJournalCountAggregateOutputType | null
    _avg: ReturnsOutwardsJournalAvgAggregateOutputType | null
    _sum: ReturnsOutwardsJournalSumAggregateOutputType | null
    _min: ReturnsOutwardsJournalMinAggregateOutputType | null
    _max: ReturnsOutwardsJournalMaxAggregateOutputType | null
  }

  type GetReturnsOutwardsJournalGroupByPayload<T extends ReturnsOutwardsJournalGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReturnsOutwardsJournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReturnsOutwardsJournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReturnsOutwardsJournalGroupByOutputType[P]>
            : GetScalarType<T[P], ReturnsOutwardsJournalGroupByOutputType[P]>
        }
      >
    >


  export type ReturnsOutwardsJournalSelect = {
    id?: boolean
    recorder?: boolean | UserArgs
    recorderId?: boolean
    supplier?: boolean | SupplierArgs
    supplierId?: boolean
    transaction?: boolean | TransactionArgs
    transactionId?: boolean
    narration?: boolean
    amount?: boolean
  }

  export type ReturnsOutwardsJournalInclude = {
    recorder?: boolean | UserArgs
    supplier?: boolean | SupplierArgs
    transaction?: boolean | TransactionArgs
  }

  export type ReturnsOutwardsJournalGetPayload<
    S extends boolean | null | undefined | ReturnsOutwardsJournalArgs,
    U = keyof S
      > = S extends true
        ? ReturnsOutwardsJournal
    : S extends undefined
    ? never
    : S extends ReturnsOutwardsJournalArgs | ReturnsOutwardsJournalFindManyArgs
    ?'include' extends U
    ? ReturnsOutwardsJournal  & {
    [P in TrueKeys<S['include']>]:
        P extends 'recorder' ? UserGetPayload<S['include'][P]> :
        P extends 'supplier' ? SupplierGetPayload<S['include'][P]> :
        P extends 'transaction' ? TransactionGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'recorder' ? UserGetPayload<S['select'][P]> :
        P extends 'supplier' ? SupplierGetPayload<S['select'][P]> :
        P extends 'transaction' ? TransactionGetPayload<S['select'][P]> :  P extends keyof ReturnsOutwardsJournal ? ReturnsOutwardsJournal[P] : never
  } 
    : ReturnsOutwardsJournal
  : ReturnsOutwardsJournal


  type ReturnsOutwardsJournalCountArgs = Merge<
    Omit<ReturnsOutwardsJournalFindManyArgs, 'select' | 'include'> & {
      select?: ReturnsOutwardsJournalCountAggregateInputType | true
    }
  >

  export interface ReturnsOutwardsJournalDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ReturnsOutwardsJournal that matches the filter.
     * @param {ReturnsOutwardsJournalFindUniqueArgs} args - Arguments to find a ReturnsOutwardsJournal
     * @example
     * // Get one ReturnsOutwardsJournal
     * const returnsOutwardsJournal = await prisma.returnsOutwardsJournal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReturnsOutwardsJournalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReturnsOutwardsJournalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ReturnsOutwardsJournal'> extends True ? CheckSelect<T, Prisma__ReturnsOutwardsJournalClient<ReturnsOutwardsJournal>, Prisma__ReturnsOutwardsJournalClient<ReturnsOutwardsJournalGetPayload<T>>> : CheckSelect<T, Prisma__ReturnsOutwardsJournalClient<ReturnsOutwardsJournal | null >, Prisma__ReturnsOutwardsJournalClient<ReturnsOutwardsJournalGetPayload<T> | null >>

    /**
     * Find the first ReturnsOutwardsJournal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsOutwardsJournalFindFirstArgs} args - Arguments to find a ReturnsOutwardsJournal
     * @example
     * // Get one ReturnsOutwardsJournal
     * const returnsOutwardsJournal = await prisma.returnsOutwardsJournal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReturnsOutwardsJournalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReturnsOutwardsJournalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ReturnsOutwardsJournal'> extends True ? CheckSelect<T, Prisma__ReturnsOutwardsJournalClient<ReturnsOutwardsJournal>, Prisma__ReturnsOutwardsJournalClient<ReturnsOutwardsJournalGetPayload<T>>> : CheckSelect<T, Prisma__ReturnsOutwardsJournalClient<ReturnsOutwardsJournal | null >, Prisma__ReturnsOutwardsJournalClient<ReturnsOutwardsJournalGetPayload<T> | null >>

    /**
     * Find zero or more ReturnsOutwardsJournals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsOutwardsJournalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReturnsOutwardsJournals
     * const returnsOutwardsJournals = await prisma.returnsOutwardsJournal.findMany()
     * 
     * // Get first 10 ReturnsOutwardsJournals
     * const returnsOutwardsJournals = await prisma.returnsOutwardsJournal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const returnsOutwardsJournalWithIdOnly = await prisma.returnsOutwardsJournal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReturnsOutwardsJournalFindManyArgs>(
      args?: SelectSubset<T, ReturnsOutwardsJournalFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ReturnsOutwardsJournal>>, PrismaPromise<Array<ReturnsOutwardsJournalGetPayload<T>>>>

    /**
     * Create a ReturnsOutwardsJournal.
     * @param {ReturnsOutwardsJournalCreateArgs} args - Arguments to create a ReturnsOutwardsJournal.
     * @example
     * // Create one ReturnsOutwardsJournal
     * const ReturnsOutwardsJournal = await prisma.returnsOutwardsJournal.create({
     *   data: {
     *     // ... data to create a ReturnsOutwardsJournal
     *   }
     * })
     * 
    **/
    create<T extends ReturnsOutwardsJournalCreateArgs>(
      args: SelectSubset<T, ReturnsOutwardsJournalCreateArgs>
    ): CheckSelect<T, Prisma__ReturnsOutwardsJournalClient<ReturnsOutwardsJournal>, Prisma__ReturnsOutwardsJournalClient<ReturnsOutwardsJournalGetPayload<T>>>

    /**
     * Create many ReturnsOutwardsJournals.
     *     @param {ReturnsOutwardsJournalCreateManyArgs} args - Arguments to create many ReturnsOutwardsJournals.
     *     @example
     *     // Create many ReturnsOutwardsJournals
     *     const returnsOutwardsJournal = await prisma.returnsOutwardsJournal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReturnsOutwardsJournalCreateManyArgs>(
      args?: SelectSubset<T, ReturnsOutwardsJournalCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ReturnsOutwardsJournal.
     * @param {ReturnsOutwardsJournalDeleteArgs} args - Arguments to delete one ReturnsOutwardsJournal.
     * @example
     * // Delete one ReturnsOutwardsJournal
     * const ReturnsOutwardsJournal = await prisma.returnsOutwardsJournal.delete({
     *   where: {
     *     // ... filter to delete one ReturnsOutwardsJournal
     *   }
     * })
     * 
    **/
    delete<T extends ReturnsOutwardsJournalDeleteArgs>(
      args: SelectSubset<T, ReturnsOutwardsJournalDeleteArgs>
    ): CheckSelect<T, Prisma__ReturnsOutwardsJournalClient<ReturnsOutwardsJournal>, Prisma__ReturnsOutwardsJournalClient<ReturnsOutwardsJournalGetPayload<T>>>

    /**
     * Update one ReturnsOutwardsJournal.
     * @param {ReturnsOutwardsJournalUpdateArgs} args - Arguments to update one ReturnsOutwardsJournal.
     * @example
     * // Update one ReturnsOutwardsJournal
     * const returnsOutwardsJournal = await prisma.returnsOutwardsJournal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReturnsOutwardsJournalUpdateArgs>(
      args: SelectSubset<T, ReturnsOutwardsJournalUpdateArgs>
    ): CheckSelect<T, Prisma__ReturnsOutwardsJournalClient<ReturnsOutwardsJournal>, Prisma__ReturnsOutwardsJournalClient<ReturnsOutwardsJournalGetPayload<T>>>

    /**
     * Delete zero or more ReturnsOutwardsJournals.
     * @param {ReturnsOutwardsJournalDeleteManyArgs} args - Arguments to filter ReturnsOutwardsJournals to delete.
     * @example
     * // Delete a few ReturnsOutwardsJournals
     * const { count } = await prisma.returnsOutwardsJournal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReturnsOutwardsJournalDeleteManyArgs>(
      args?: SelectSubset<T, ReturnsOutwardsJournalDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReturnsOutwardsJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsOutwardsJournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReturnsOutwardsJournals
     * const returnsOutwardsJournal = await prisma.returnsOutwardsJournal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReturnsOutwardsJournalUpdateManyArgs>(
      args: SelectSubset<T, ReturnsOutwardsJournalUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ReturnsOutwardsJournal.
     * @param {ReturnsOutwardsJournalUpsertArgs} args - Arguments to update or create a ReturnsOutwardsJournal.
     * @example
     * // Update or create a ReturnsOutwardsJournal
     * const returnsOutwardsJournal = await prisma.returnsOutwardsJournal.upsert({
     *   create: {
     *     // ... data to create a ReturnsOutwardsJournal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReturnsOutwardsJournal we want to update
     *   }
     * })
    **/
    upsert<T extends ReturnsOutwardsJournalUpsertArgs>(
      args: SelectSubset<T, ReturnsOutwardsJournalUpsertArgs>
    ): CheckSelect<T, Prisma__ReturnsOutwardsJournalClient<ReturnsOutwardsJournal>, Prisma__ReturnsOutwardsJournalClient<ReturnsOutwardsJournalGetPayload<T>>>

    /**
     * Find one ReturnsOutwardsJournal that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ReturnsOutwardsJournalFindUniqueOrThrowArgs} args - Arguments to find a ReturnsOutwardsJournal
     * @example
     * // Get one ReturnsOutwardsJournal
     * const returnsOutwardsJournal = await prisma.returnsOutwardsJournal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReturnsOutwardsJournalFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ReturnsOutwardsJournalFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ReturnsOutwardsJournalClient<ReturnsOutwardsJournal>, Prisma__ReturnsOutwardsJournalClient<ReturnsOutwardsJournalGetPayload<T>>>

    /**
     * Find the first ReturnsOutwardsJournal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsOutwardsJournalFindFirstOrThrowArgs} args - Arguments to find a ReturnsOutwardsJournal
     * @example
     * // Get one ReturnsOutwardsJournal
     * const returnsOutwardsJournal = await prisma.returnsOutwardsJournal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReturnsOutwardsJournalFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReturnsOutwardsJournalFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ReturnsOutwardsJournalClient<ReturnsOutwardsJournal>, Prisma__ReturnsOutwardsJournalClient<ReturnsOutwardsJournalGetPayload<T>>>

    /**
     * Count the number of ReturnsOutwardsJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsOutwardsJournalCountArgs} args - Arguments to filter ReturnsOutwardsJournals to count.
     * @example
     * // Count the number of ReturnsOutwardsJournals
     * const count = await prisma.returnsOutwardsJournal.count({
     *   where: {
     *     // ... the filter for the ReturnsOutwardsJournals we want to count
     *   }
     * })
    **/
    count<T extends ReturnsOutwardsJournalCountArgs>(
      args?: Subset<T, ReturnsOutwardsJournalCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReturnsOutwardsJournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReturnsOutwardsJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsOutwardsJournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReturnsOutwardsJournalAggregateArgs>(args: Subset<T, ReturnsOutwardsJournalAggregateArgs>): PrismaPromise<GetReturnsOutwardsJournalAggregateType<T>>

    /**
     * Group by ReturnsOutwardsJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsOutwardsJournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReturnsOutwardsJournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReturnsOutwardsJournalGroupByArgs['orderBy'] }
        : { orderBy?: ReturnsOutwardsJournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReturnsOutwardsJournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReturnsOutwardsJournalGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReturnsOutwardsJournal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReturnsOutwardsJournalClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    recorder<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    supplier<T extends SupplierArgs = {}>(args?: Subset<T, SupplierArgs>): CheckSelect<T, Prisma__SupplierClient<Supplier | null >, Prisma__SupplierClient<SupplierGetPayload<T> | null >>;

    transaction<T extends TransactionArgs = {}>(args?: Subset<T, TransactionArgs>): CheckSelect<T, Prisma__TransactionClient<Transaction | null >, Prisma__TransactionClient<TransactionGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ReturnsOutwardsJournal base type for findUnique actions
   */
  export type ReturnsOutwardsJournalFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ReturnsOutwardsJournal
     * 
    **/
    select?: ReturnsOutwardsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReturnsOutwardsJournalInclude | null
    /**
     * Filter, which ReturnsOutwardsJournal to fetch.
     * 
    **/
    where: ReturnsOutwardsJournalWhereUniqueInput
  }

  /**
   * ReturnsOutwardsJournal: findUnique
   */
  export interface ReturnsOutwardsJournalFindUniqueArgs extends ReturnsOutwardsJournalFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ReturnsOutwardsJournal base type for findFirst actions
   */
  export type ReturnsOutwardsJournalFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ReturnsOutwardsJournal
     * 
    **/
    select?: ReturnsOutwardsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReturnsOutwardsJournalInclude | null
    /**
     * Filter, which ReturnsOutwardsJournal to fetch.
     * 
    **/
    where?: ReturnsOutwardsJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnsOutwardsJournals to fetch.
     * 
    **/
    orderBy?: Enumerable<ReturnsOutwardsJournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReturnsOutwardsJournals.
     * 
    **/
    cursor?: ReturnsOutwardsJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnsOutwardsJournals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnsOutwardsJournals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReturnsOutwardsJournals.
     * 
    **/
    distinct?: Enumerable<ReturnsOutwardsJournalScalarFieldEnum>
  }

  /**
   * ReturnsOutwardsJournal: findFirst
   */
  export interface ReturnsOutwardsJournalFindFirstArgs extends ReturnsOutwardsJournalFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ReturnsOutwardsJournal findMany
   */
  export type ReturnsOutwardsJournalFindManyArgs = {
    /**
     * Select specific fields to fetch from the ReturnsOutwardsJournal
     * 
    **/
    select?: ReturnsOutwardsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReturnsOutwardsJournalInclude | null
    /**
     * Filter, which ReturnsOutwardsJournals to fetch.
     * 
    **/
    where?: ReturnsOutwardsJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnsOutwardsJournals to fetch.
     * 
    **/
    orderBy?: Enumerable<ReturnsOutwardsJournalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReturnsOutwardsJournals.
     * 
    **/
    cursor?: ReturnsOutwardsJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnsOutwardsJournals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnsOutwardsJournals.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReturnsOutwardsJournalScalarFieldEnum>
  }


  /**
   * ReturnsOutwardsJournal create
   */
  export type ReturnsOutwardsJournalCreateArgs = {
    /**
     * Select specific fields to fetch from the ReturnsOutwardsJournal
     * 
    **/
    select?: ReturnsOutwardsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReturnsOutwardsJournalInclude | null
    /**
     * The data needed to create a ReturnsOutwardsJournal.
     * 
    **/
    data: XOR<ReturnsOutwardsJournalCreateInput, ReturnsOutwardsJournalUncheckedCreateInput>
  }


  /**
   * ReturnsOutwardsJournal createMany
   */
  export type ReturnsOutwardsJournalCreateManyArgs = {
    /**
     * The data used to create many ReturnsOutwardsJournals.
     * 
    **/
    data: Enumerable<ReturnsOutwardsJournalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ReturnsOutwardsJournal update
   */
  export type ReturnsOutwardsJournalUpdateArgs = {
    /**
     * Select specific fields to fetch from the ReturnsOutwardsJournal
     * 
    **/
    select?: ReturnsOutwardsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReturnsOutwardsJournalInclude | null
    /**
     * The data needed to update a ReturnsOutwardsJournal.
     * 
    **/
    data: XOR<ReturnsOutwardsJournalUpdateInput, ReturnsOutwardsJournalUncheckedUpdateInput>
    /**
     * Choose, which ReturnsOutwardsJournal to update.
     * 
    **/
    where: ReturnsOutwardsJournalWhereUniqueInput
  }


  /**
   * ReturnsOutwardsJournal updateMany
   */
  export type ReturnsOutwardsJournalUpdateManyArgs = {
    /**
     * The data used to update ReturnsOutwardsJournals.
     * 
    **/
    data: XOR<ReturnsOutwardsJournalUpdateManyMutationInput, ReturnsOutwardsJournalUncheckedUpdateManyInput>
    /**
     * Filter which ReturnsOutwardsJournals to update
     * 
    **/
    where?: ReturnsOutwardsJournalWhereInput
  }


  /**
   * ReturnsOutwardsJournal upsert
   */
  export type ReturnsOutwardsJournalUpsertArgs = {
    /**
     * Select specific fields to fetch from the ReturnsOutwardsJournal
     * 
    **/
    select?: ReturnsOutwardsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReturnsOutwardsJournalInclude | null
    /**
     * The filter to search for the ReturnsOutwardsJournal to update in case it exists.
     * 
    **/
    where: ReturnsOutwardsJournalWhereUniqueInput
    /**
     * In case the ReturnsOutwardsJournal found by the `where` argument doesn't exist, create a new ReturnsOutwardsJournal with this data.
     * 
    **/
    create: XOR<ReturnsOutwardsJournalCreateInput, ReturnsOutwardsJournalUncheckedCreateInput>
    /**
     * In case the ReturnsOutwardsJournal was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ReturnsOutwardsJournalUpdateInput, ReturnsOutwardsJournalUncheckedUpdateInput>
  }


  /**
   * ReturnsOutwardsJournal delete
   */
  export type ReturnsOutwardsJournalDeleteArgs = {
    /**
     * Select specific fields to fetch from the ReturnsOutwardsJournal
     * 
    **/
    select?: ReturnsOutwardsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReturnsOutwardsJournalInclude | null
    /**
     * Filter which ReturnsOutwardsJournal to delete.
     * 
    **/
    where: ReturnsOutwardsJournalWhereUniqueInput
  }


  /**
   * ReturnsOutwardsJournal deleteMany
   */
  export type ReturnsOutwardsJournalDeleteManyArgs = {
    /**
     * Filter which ReturnsOutwardsJournals to delete
     * 
    **/
    where?: ReturnsOutwardsJournalWhereInput
  }


  /**
   * ReturnsOutwardsJournal: findUniqueOrThrow
   */
  export type ReturnsOutwardsJournalFindUniqueOrThrowArgs = ReturnsOutwardsJournalFindUniqueArgsBase
      

  /**
   * ReturnsOutwardsJournal: findFirstOrThrow
   */
  export type ReturnsOutwardsJournalFindFirstOrThrowArgs = ReturnsOutwardsJournalFindFirstArgsBase
      

  /**
   * ReturnsOutwardsJournal without action
   */
  export type ReturnsOutwardsJournalArgs = {
    /**
     * Select specific fields to fetch from the ReturnsOutwardsJournal
     * 
    **/
    select?: ReturnsOutwardsJournalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReturnsOutwardsJournalInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    username: 'username',
    password: 'password',
    phoneNumber: 'phoneNumber',
    isAdmin: 'isAdmin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLogin: 'lastLogin',
    emailAddress: 'emailAddress'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ActionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    actionType: 'actionType',
    description: 'description'
  };

  export type ActionScalarFieldEnum = (typeof ActionScalarFieldEnum)[keyof typeof ActionScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    initiatedBy: 'initiatedBy',
    createdAt: 'createdAt',
    totalPaid: 'totalPaid',
    totalPayable: 'totalPayable',
    supplierId: 'supplierId',
    errorDescription: 'errorDescription',
    customerId: 'customerId',
    type: 'type',
    status: 'status'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    paymentTypeId: 'paymentTypeId',
    currencyId: 'currencyId',
    exchangeRateId: 'exchangeRateId',
    transactionId: 'transactionId',
    paid: 'paid'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const PaymentTypeScalarFieldEnum: {
    id: 'id',
    paymentTypeName: 'paymentTypeName',
    charges: 'charges',
    discount: 'discount'
  };

  export type PaymentTypeScalarFieldEnum = (typeof PaymentTypeScalarFieldEnum)[keyof typeof PaymentTypeScalarFieldEnum]


  export const TaxScalarFieldEnum: {
    id: 'id',
    taxName: 'taxName',
    taxRate: 'taxRate',
    startAmount: 'startAmount',
    endAmount: 'endAmount',
    active: 'active',
    startDate: 'startDate',
    endDate: 'endDate'
  };

  export type TaxScalarFieldEnum = (typeof TaxScalarFieldEnum)[keyof typeof TaxScalarFieldEnum]


  export const PromotionsScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    productGroupId: 'productGroupId',
    startDate: 'startDate',
    endDate: 'endDate',
    discountRate: 'discountRate'
  };

  export type PromotionsScalarFieldEnum = (typeof PromotionsScalarFieldEnum)[keyof typeof PromotionsScalarFieldEnum]


  export const ProductGroupScalarFieldEnum: {
    id: 'id',
    taxId: 'taxId'
  };

  export type ProductGroupScalarFieldEnum = (typeof ProductGroupScalarFieldEnum)[keyof typeof ProductGroupScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    barcode: 'barcode',
    productName: 'productName',
    measurementUnit: 'measurementUnit',
    expiryDate: 'expiryDate',
    measurementAmount: 'measurementAmount',
    cost: 'cost',
    quantity: 'quantity',
    supplierId: 'supplierId',
    productGroupId: 'productGroupId',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt',
    depleted: 'depleted',
    disposed: 'disposed'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const PricesScalarFieldEnum: {
    id: 'id',
    barcode: 'barcode',
    price: 'price',
    active: 'active',
    exchangeRateId: 'exchangeRateId',
    productId: 'productId'
  };

  export type PricesScalarFieldEnum = (typeof PricesScalarFieldEnum)[keyof typeof PricesScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    discount: 'discount',
    price: 'price',
    quantity: 'quantity',
    transactionId: 'transactionId',
    cashierId: 'cashierId',
    customerId: 'customerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    supplierId: 'supplierId'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    phoneNumber: 'phoneNumber',
    corporateName: 'corporateName',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt',
    emailAddress: 'emailAddress'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    phoneNumber: 'phoneNumber',
    emailAddress: 'emailAddress',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    supplierId: 'supplierId',
    customerId: 'customerId',
    street: 'street',
    city: 'city',
    country: 'country',
    zip: 'zip'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const BaseCurrencyScalarFieldEnum: {
    id: 'id',
    currencyId: 'currencyId',
    createdAt: 'createdAt',
    active: 'active'
  };

  export type BaseCurrencyScalarFieldEnum = (typeof BaseCurrencyScalarFieldEnum)[keyof typeof BaseCurrencyScalarFieldEnum]


  export const CurrencyScalarFieldEnum: {
    id: 'id',
    currencyName: 'currencyName',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type CurrencyScalarFieldEnum = (typeof CurrencyScalarFieldEnum)[keyof typeof CurrencyScalarFieldEnum]


  export const DisposalsScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    priceId: 'priceId',
    createdAt: 'createdAt'
  };

  export type DisposalsScalarFieldEnum = (typeof DisposalsScalarFieldEnum)[keyof typeof DisposalsScalarFieldEnum]


  export const ExchangeRatesScalarFieldEnum: {
    id: 'id',
    exchangeRate: 'exchangeRate',
    currencyId: 'currencyId',
    createdAt: 'createdAt',
    baseCurrencyId: 'baseCurrencyId',
    active: 'active'
  };

  export type ExchangeRatesScalarFieldEnum = (typeof ExchangeRatesScalarFieldEnum)[keyof typeof ExchangeRatesScalarFieldEnum]


  export const JournalScalarFieldEnum: {
    id: 'id',
    recorderId: 'recorderId',
    supplierId: 'supplierId',
    customerId: 'customerId',
    transactionId: 'transactionId',
    narration: 'narration',
    amount: 'amount'
  };

  export type JournalScalarFieldEnum = (typeof JournalScalarFieldEnum)[keyof typeof JournalScalarFieldEnum]


  export const SalesJournalScalarFieldEnum: {
    id: 'id',
    recorderId: 'recorderId',
    supplierId: 'supplierId',
    transactionId: 'transactionId',
    narration: 'narration',
    amount: 'amount'
  };

  export type SalesJournalScalarFieldEnum = (typeof SalesJournalScalarFieldEnum)[keyof typeof SalesJournalScalarFieldEnum]


  export const PurchasesJournalScalarFieldEnum: {
    id: 'id',
    recorderId: 'recorderId',
    customerId: 'customerId',
    transactionId: 'transactionId',
    narration: 'narration',
    amount: 'amount'
  };

  export type PurchasesJournalScalarFieldEnum = (typeof PurchasesJournalScalarFieldEnum)[keyof typeof PurchasesJournalScalarFieldEnum]


  export const CashDisbursementsJournalScalarFieldEnum: {
    id: 'id',
    recorderId: 'recorderId',
    supplierId: 'supplierId',
    customerId: 'customerId',
    transactionId: 'transactionId',
    narration: 'narration',
    amount: 'amount'
  };

  export type CashDisbursementsJournalScalarFieldEnum = (typeof CashDisbursementsJournalScalarFieldEnum)[keyof typeof CashDisbursementsJournalScalarFieldEnum]


  export const CashReceiptsJournalScalarFieldEnum: {
    id: 'id',
    recorderId: 'recorderId',
    supplierId: 'supplierId',
    customerId: 'customerId',
    transactionId: 'transactionId',
    narration: 'narration',
    amount: 'amount'
  };

  export type CashReceiptsJournalScalarFieldEnum = (typeof CashReceiptsJournalScalarFieldEnum)[keyof typeof CashReceiptsJournalScalarFieldEnum]


  export const ReturnsInwardsJournalScalarFieldEnum: {
    id: 'id',
    recorderId: 'recorderId',
    customerId: 'customerId',
    transactionId: 'transactionId',
    narration: 'narration',
    amount: 'amount'
  };

  export type ReturnsInwardsJournalScalarFieldEnum = (typeof ReturnsInwardsJournalScalarFieldEnum)[keyof typeof ReturnsInwardsJournalScalarFieldEnum]


  export const ReturnsOutwardsJournalScalarFieldEnum: {
    id: 'id',
    recorderId: 'recorderId',
    supplierId: 'supplierId',
    transactionId: 'transactionId',
    narration: 'narration',
    amount: 'amount'
  };

  export type ReturnsOutwardsJournalScalarFieldEnum = (typeof ReturnsOutwardsJournalScalarFieldEnum)[keyof typeof ReturnsOutwardsJournalScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    username?: StringFilter | string
    password?: StringFilter | string
    phoneNumber?: StringFilter | string
    isAdmin?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    lastLogin?: DateTimeNullableFilter | Date | string | null
    emailAddress?: StringNullableFilter | string | null
    invoice?: InvoiceListRelationFilter
    journal?: JournalListRelationFilter
    action?: ActionListRelationFilter
    transaction?: TransactionListRelationFilter
    SalesJournal?: SalesJournalListRelationFilter
    PurchasesJournal?: PurchasesJournalListRelationFilter
    CashDisbursementsJournal?: CashDisbursementsJournalListRelationFilter
    CashReceiptsJournal?: CashReceiptsJournalListRelationFilter
    ReturnsInwardsJournal?: ReturnsInwardsJournalListRelationFilter
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
    emailAddress?: SortOrder
    invoice?: invoiceOrderByRelationAggregateInput
    journal?: JournalOrderByRelationAggregateInput
    action?: ActionOrderByRelationAggregateInput
    transaction?: TransactionOrderByRelationAggregateInput
    SalesJournal?: SalesJournalOrderByRelationAggregateInput
    PurchasesJournal?: PurchasesJournalOrderByRelationAggregateInput
    CashDisbursementsJournal?: CashDisbursementsJournalOrderByRelationAggregateInput
    CashReceiptsJournal?: CashReceiptsJournalOrderByRelationAggregateInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalOrderByRelationAggregateInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: number
    username?: string
    phoneNumber?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
    emailAddress?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    username?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    phoneNumber?: StringWithAggregatesFilter | string
    isAdmin?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    lastLogin?: DateTimeNullableWithAggregatesFilter | Date | string | null
    emailAddress?: StringNullableWithAggregatesFilter | string | null
  }

  export type ActionWhereInput = {
    AND?: Enumerable<ActionWhereInput>
    OR?: Enumerable<ActionWhereInput>
    NOT?: Enumerable<ActionWhereInput>
    id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: IntFilter | number
    actionType?: BoolFilter | boolean
    description?: StringFilter | string
  }

  export type ActionOrderByWithRelationInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
    actionType?: SortOrder
    description?: SortOrder
  }

  export type ActionWhereUniqueInput = {
    id?: string
  }

  export type ActionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    description?: SortOrder
    _count?: ActionCountOrderByAggregateInput
    _avg?: ActionAvgOrderByAggregateInput
    _max?: ActionMaxOrderByAggregateInput
    _min?: ActionMinOrderByAggregateInput
    _sum?: ActionSumOrderByAggregateInput
  }

  export type ActionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ActionScalarWhereWithAggregatesInput>
    OR?: Enumerable<ActionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ActionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    actionType?: BoolWithAggregatesFilter | boolean
    description?: StringWithAggregatesFilter | string
  }

  export type TransactionWhereInput = {
    AND?: Enumerable<TransactionWhereInput>
    OR?: Enumerable<TransactionWhereInput>
    NOT?: Enumerable<TransactionWhereInput>
    id?: IntFilter | number
    initiatedBy?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    totalPaid?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    totalPayable?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    supplierId?: StringNullableFilter | string | null
    errorDescription?: StringNullableFilter | string | null
    customerId?: StringNullableFilter | string | null
    type?: EnumTransactionTypeFilter | TransactionType
    status?: EnumTransactionStatusCodesFilter | TransactionStatusCodes
    users?: XOR<UserRelationFilter, UserWhereInput>
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput> | null
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput> | null
    payments?: PaymentListRelationFilter
    invoice?: InvoiceListRelationFilter
    journal?: JournalListRelationFilter
    SalesJournal?: SalesJournalListRelationFilter
    PurchasesJournal?: PurchasesJournalListRelationFilter
    CashDisbursementsJournal?: CashDisbursementsJournalListRelationFilter
    CashReceiptsJournal?: CashReceiptsJournalListRelationFilter
    ReturnsInwardsJournal?: ReturnsInwardsJournalListRelationFilter
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalListRelationFilter
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    initiatedBy?: SortOrder
    createdAt?: SortOrder
    totalPaid?: SortOrder
    totalPayable?: SortOrder
    supplierId?: SortOrder
    errorDescription?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    users?: UserOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    invoice?: invoiceOrderByRelationAggregateInput
    journal?: JournalOrderByRelationAggregateInput
    SalesJournal?: SalesJournalOrderByRelationAggregateInput
    PurchasesJournal?: PurchasesJournalOrderByRelationAggregateInput
    CashDisbursementsJournal?: CashDisbursementsJournalOrderByRelationAggregateInput
    CashReceiptsJournal?: CashReceiptsJournalOrderByRelationAggregateInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalOrderByRelationAggregateInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalOrderByRelationAggregateInput
  }

  export type TransactionWhereUniqueInput = {
    id?: number
  }

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    initiatedBy?: SortOrder
    createdAt?: SortOrder
    totalPaid?: SortOrder
    totalPayable?: SortOrder
    supplierId?: SortOrder
    errorDescription?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TransactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<TransactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TransactionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    initiatedBy?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    totalPaid?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    totalPayable?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    supplierId?: StringNullableWithAggregatesFilter | string | null
    errorDescription?: StringNullableWithAggregatesFilter | string | null
    customerId?: StringNullableWithAggregatesFilter | string | null
    type?: EnumTransactionTypeWithAggregatesFilter | TransactionType
    status?: EnumTransactionStatusCodesWithAggregatesFilter | TransactionStatusCodes
  }

  export type PaymentWhereInput = {
    AND?: Enumerable<PaymentWhereInput>
    OR?: Enumerable<PaymentWhereInput>
    NOT?: Enumerable<PaymentWhereInput>
    id?: StringFilter | string
    paymentType?: XOR<PaymentTypeRelationFilter, PaymentTypeWhereInput>
    paymentTypeId?: StringFilter | string
    currencyId?: StringFilter | string
    exchangeRateId?: StringFilter | string
    transactionId?: IntFilter | number
    paid?: DecimalFilter | Decimal | DecimalJsLike | number | string
    currency?: XOR<CurrencyRelationFilter, currencyWhereInput>
    exchangeRates?: XOR<ExchangeRatesRelationFilter, exchangeRatesWhereInput>
    transaction?: XOR<TransactionRelationFilter, TransactionWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    paymentType?: PaymentTypeOrderByWithRelationInput
    paymentTypeId?: SortOrder
    currencyId?: SortOrder
    exchangeRateId?: SortOrder
    transactionId?: SortOrder
    paid?: SortOrder
    currency?: currencyOrderByWithRelationInput
    exchangeRates?: exchangeRatesOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = {
    id?: string
  }

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    paymentTypeId?: SortOrder
    currencyId?: SortOrder
    exchangeRateId?: SortOrder
    transactionId?: SortOrder
    paid?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    OR?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    paymentTypeId?: StringWithAggregatesFilter | string
    currencyId?: StringWithAggregatesFilter | string
    exchangeRateId?: StringWithAggregatesFilter | string
    transactionId?: IntWithAggregatesFilter | number
    paid?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
  }

  export type PaymentTypeWhereInput = {
    AND?: Enumerable<PaymentTypeWhereInput>
    OR?: Enumerable<PaymentTypeWhereInput>
    NOT?: Enumerable<PaymentTypeWhereInput>
    id?: StringFilter | string
    paymentTypeName?: StringFilter | string
    payment?: PaymentListRelationFilter
    charges?: DecimalFilter | Decimal | DecimalJsLike | number | string
    tax?: TaxListRelationFilter
    discount?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type PaymentTypeOrderByWithRelationInput = {
    id?: SortOrder
    paymentTypeName?: SortOrder
    payment?: PaymentOrderByRelationAggregateInput
    charges?: SortOrder
    tax?: TaxOrderByRelationAggregateInput
    discount?: SortOrder
  }

  export type PaymentTypeWhereUniqueInput = {
    id?: string
    paymentTypeName?: string
  }

  export type PaymentTypeOrderByWithAggregationInput = {
    id?: SortOrder
    paymentTypeName?: SortOrder
    charges?: SortOrder
    discount?: SortOrder
    _count?: PaymentTypeCountOrderByAggregateInput
    _avg?: PaymentTypeAvgOrderByAggregateInput
    _max?: PaymentTypeMaxOrderByAggregateInput
    _min?: PaymentTypeMinOrderByAggregateInput
    _sum?: PaymentTypeSumOrderByAggregateInput
  }

  export type PaymentTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PaymentTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<PaymentTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PaymentTypeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    paymentTypeName?: StringWithAggregatesFilter | string
    charges?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    discount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
  }

  export type TaxWhereInput = {
    AND?: Enumerable<TaxWhereInput>
    OR?: Enumerable<TaxWhereInput>
    NOT?: Enumerable<TaxWhereInput>
    id?: StringFilter | string
    taxName?: StringFilter | string
    taxRate?: StringFilter | string
    startAmount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    endAmount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    active?: BoolFilter | boolean
    startDate?: DateTimeFilter | Date | string
    endDate?: DateTimeFilter | Date | string
    PaymentType?: PaymentTypeListRelationFilter
    currency?: CurrencyListRelationFilter
    product?: ProductListRelationFilter
    invoice?: InvoiceListRelationFilter
    productGroup?: ProductGroupListRelationFilter
  }

  export type TaxOrderByWithRelationInput = {
    id?: SortOrder
    taxName?: SortOrder
    taxRate?: SortOrder
    startAmount?: SortOrder
    endAmount?: SortOrder
    active?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    PaymentType?: PaymentTypeOrderByRelationAggregateInput
    currency?: currencyOrderByRelationAggregateInput
    product?: ProductOrderByRelationAggregateInput
    invoice?: invoiceOrderByRelationAggregateInput
    productGroup?: ProductGroupOrderByRelationAggregateInput
  }

  export type TaxWhereUniqueInput = {
    id?: string
  }

  export type TaxOrderByWithAggregationInput = {
    id?: SortOrder
    taxName?: SortOrder
    taxRate?: SortOrder
    startAmount?: SortOrder
    endAmount?: SortOrder
    active?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    _count?: TaxCountOrderByAggregateInput
    _avg?: TaxAvgOrderByAggregateInput
    _max?: TaxMaxOrderByAggregateInput
    _min?: TaxMinOrderByAggregateInput
    _sum?: TaxSumOrderByAggregateInput
  }

  export type TaxScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TaxScalarWhereWithAggregatesInput>
    OR?: Enumerable<TaxScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TaxScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    taxName?: StringWithAggregatesFilter | string
    taxRate?: StringWithAggregatesFilter | string
    startAmount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    endAmount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    active?: BoolWithAggregatesFilter | boolean
    startDate?: DateTimeWithAggregatesFilter | Date | string
    endDate?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PromotionsWhereInput = {
    AND?: Enumerable<PromotionsWhereInput>
    OR?: Enumerable<PromotionsWhereInput>
    NOT?: Enumerable<PromotionsWhereInput>
    id?: StringFilter | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    productId?: StringFilter | string
    productGroup?: XOR<ProductGroupRelationFilter, ProductGroupWhereInput>
    productGroupId?: StringFilter | string
    startDate?: DateTimeFilter | Date | string
    endDate?: DateTimeFilter | Date | string
    discountRate?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type PromotionsOrderByWithRelationInput = {
    id?: SortOrder
    product?: ProductOrderByWithRelationInput
    productId?: SortOrder
    productGroup?: ProductGroupOrderByWithRelationInput
    productGroupId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    discountRate?: SortOrder
  }

  export type PromotionsWhereUniqueInput = {
    id?: string
  }

  export type PromotionsOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    productGroupId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    discountRate?: SortOrder
    _count?: PromotionsCountOrderByAggregateInput
    _avg?: PromotionsAvgOrderByAggregateInput
    _max?: PromotionsMaxOrderByAggregateInput
    _min?: PromotionsMinOrderByAggregateInput
    _sum?: PromotionsSumOrderByAggregateInput
  }

  export type PromotionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PromotionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<PromotionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PromotionsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    productId?: StringWithAggregatesFilter | string
    productGroupId?: StringWithAggregatesFilter | string
    startDate?: DateTimeWithAggregatesFilter | Date | string
    endDate?: DateTimeWithAggregatesFilter | Date | string
    discountRate?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
  }

  export type ProductGroupWhereInput = {
    AND?: Enumerable<ProductGroupWhereInput>
    OR?: Enumerable<ProductGroupWhereInput>
    NOT?: Enumerable<ProductGroupWhereInput>
    id?: StringFilter | string
    product?: ProductListRelationFilter
    Tax?: XOR<TaxRelationFilter, TaxWhereInput> | null
    taxId?: StringNullableFilter | string | null
    Promotions?: PromotionsListRelationFilter
  }

  export type ProductGroupOrderByWithRelationInput = {
    id?: SortOrder
    product?: ProductOrderByRelationAggregateInput
    Tax?: TaxOrderByWithRelationInput
    taxId?: SortOrder
    Promotions?: PromotionsOrderByRelationAggregateInput
  }

  export type ProductGroupWhereUniqueInput = {
    id?: string
  }

  export type ProductGroupOrderByWithAggregationInput = {
    id?: SortOrder
    taxId?: SortOrder
    _count?: ProductGroupCountOrderByAggregateInput
    _max?: ProductGroupMaxOrderByAggregateInput
    _min?: ProductGroupMinOrderByAggregateInput
  }

  export type ProductGroupScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductGroupScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductGroupScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductGroupScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    taxId?: StringNullableWithAggregatesFilter | string | null
  }

  export type ProductWhereInput = {
    AND?: Enumerable<ProductWhereInput>
    OR?: Enumerable<ProductWhereInput>
    NOT?: Enumerable<ProductWhereInput>
    id?: StringFilter | string
    barcode?: StringFilter | string
    productName?: StringFilter | string
    measurementUnit?: EnumMeasurementUnitFilter | MeasurementUnit
    expiryDate?: DateTimeFilter | Date | string
    measurementAmount?: IntFilter | number
    cost?: DecimalFilter | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter | number
    supplierId?: StringNullableFilter | string | null
    tax?: TaxListRelationFilter
    productGroup?: XOR<ProductGroupRelationFilter, ProductGroupWhereInput> | null
    productGroupId?: StringNullableFilter | string | null
    updatedAt?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    depleted?: BoolFilter | boolean
    disposed?: BoolFilter | boolean
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput> | null
    disposals?: DisposalsListRelationFilter
    price?: PricesListRelationFilter
    promotion?: PromotionsListRelationFilter
    invoice?: InvoiceListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    barcode?: SortOrder
    productName?: SortOrder
    measurementUnit?: SortOrder
    expiryDate?: SortOrder
    measurementAmount?: SortOrder
    cost?: SortOrder
    quantity?: SortOrder
    supplierId?: SortOrder
    tax?: TaxOrderByRelationAggregateInput
    productGroup?: ProductGroupOrderByWithRelationInput
    productGroupId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    depleted?: SortOrder
    disposed?: SortOrder
    supplier?: SupplierOrderByWithRelationInput
    disposals?: disposalsOrderByRelationAggregateInput
    price?: PricesOrderByRelationAggregateInput
    promotion?: PromotionsOrderByRelationAggregateInput
    invoice?: invoiceOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = {
    id?: string
  }

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    barcode?: SortOrder
    productName?: SortOrder
    measurementUnit?: SortOrder
    expiryDate?: SortOrder
    measurementAmount?: SortOrder
    cost?: SortOrder
    quantity?: SortOrder
    supplierId?: SortOrder
    productGroupId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    depleted?: SortOrder
    disposed?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    barcode?: StringWithAggregatesFilter | string
    productName?: StringWithAggregatesFilter | string
    measurementUnit?: EnumMeasurementUnitWithAggregatesFilter | MeasurementUnit
    expiryDate?: DateTimeWithAggregatesFilter | Date | string
    measurementAmount?: IntWithAggregatesFilter | number
    cost?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    quantity?: IntWithAggregatesFilter | number
    supplierId?: StringNullableWithAggregatesFilter | string | null
    productGroupId?: StringNullableWithAggregatesFilter | string | null
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    depleted?: BoolWithAggregatesFilter | boolean
    disposed?: BoolWithAggregatesFilter | boolean
  }

  export type PricesWhereInput = {
    AND?: Enumerable<PricesWhereInput>
    OR?: Enumerable<PricesWhereInput>
    NOT?: Enumerable<PricesWhereInput>
    id?: StringFilter | string
    barcode?: StringFilter | string
    price?: DecimalFilter | Decimal | DecimalJsLike | number | string
    active?: BoolFilter | boolean
    exchangeRateId?: StringFilter | string
    productId?: StringNullableFilter | string | null
    exchangeRates?: XOR<ExchangeRatesRelationFilter, exchangeRatesWhereInput>
    Product?: XOR<ProductRelationFilter, ProductWhereInput> | null
    disposals?: DisposalsListRelationFilter
  }

  export type PricesOrderByWithRelationInput = {
    id?: SortOrder
    barcode?: SortOrder
    price?: SortOrder
    active?: SortOrder
    exchangeRateId?: SortOrder
    productId?: SortOrder
    exchangeRates?: exchangeRatesOrderByWithRelationInput
    Product?: ProductOrderByWithRelationInput
    disposals?: disposalsOrderByRelationAggregateInput
  }

  export type PricesWhereUniqueInput = {
    id?: string
  }

  export type PricesOrderByWithAggregationInput = {
    id?: SortOrder
    barcode?: SortOrder
    price?: SortOrder
    active?: SortOrder
    exchangeRateId?: SortOrder
    productId?: SortOrder
    _count?: PricesCountOrderByAggregateInput
    _avg?: PricesAvgOrderByAggregateInput
    _max?: PricesMaxOrderByAggregateInput
    _min?: PricesMinOrderByAggregateInput
    _sum?: PricesSumOrderByAggregateInput
  }

  export type PricesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PricesScalarWhereWithAggregatesInput>
    OR?: Enumerable<PricesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PricesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    barcode?: StringWithAggregatesFilter | string
    price?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    active?: BoolWithAggregatesFilter | boolean
    exchangeRateId?: StringWithAggregatesFilter | string
    productId?: StringNullableWithAggregatesFilter | string | null
  }

  export type invoiceWhereInput = {
    AND?: Enumerable<invoiceWhereInput>
    OR?: Enumerable<invoiceWhereInput>
    NOT?: Enumerable<invoiceWhereInput>
    id?: StringFilter | string
    productId?: StringFilter | string
    discount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    price?: DecimalFilter | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter | number
    transactionId?: IntFilter | number
    cashierId?: IntFilter | number
    tax?: TaxListRelationFilter
    customerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    cashier?: XOR<UserRelationFilter, UserWhereInput>
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput> | null
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    transaction?: XOR<TransactionRelationFilter, TransactionWhereInput>
    Supplier?: XOR<SupplierRelationFilter, SupplierWhereInput> | null
    supplierId?: StringNullableFilter | string | null
  }

  export type invoiceOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    discount?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    transactionId?: SortOrder
    cashierId?: SortOrder
    tax?: TaxOrderByRelationAggregateInput
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cashier?: UserOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
    Supplier?: SupplierOrderByWithRelationInput
    supplierId?: SortOrder
  }

  export type invoiceWhereUniqueInput = {
    id?: string
  }

  export type invoiceOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    discount?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    transactionId?: SortOrder
    cashierId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplierId?: SortOrder
    _count?: invoiceCountOrderByAggregateInput
    _avg?: invoiceAvgOrderByAggregateInput
    _max?: invoiceMaxOrderByAggregateInput
    _min?: invoiceMinOrderByAggregateInput
    _sum?: invoiceSumOrderByAggregateInput
  }

  export type invoiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<invoiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<invoiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<invoiceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    productId?: StringWithAggregatesFilter | string
    discount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    price?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    quantity?: IntWithAggregatesFilter | number
    transactionId?: IntWithAggregatesFilter | number
    cashierId?: IntWithAggregatesFilter | number
    customerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    supplierId?: StringNullableWithAggregatesFilter | string | null
  }

  export type SupplierWhereInput = {
    AND?: Enumerable<SupplierWhereInput>
    OR?: Enumerable<SupplierWhereInput>
    NOT?: Enumerable<SupplierWhereInput>
    id?: StringFilter | string
    firstName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    phoneNumber?: StringNullableFilter | string | null
    corporateName?: StringNullableFilter | string | null
    updatedAt?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    emailAddress?: StringNullableFilter | string | null
    address?: AddressListRelationFilter
    product?: ProductListRelationFilter
    invoice?: InvoiceListRelationFilter
    transactions?: TransactionListRelationFilter
    Journal?: JournalListRelationFilter
    SalesJournal?: SalesJournalListRelationFilter
    CashDisbursementsJournal?: CashDisbursementsJournalListRelationFilter
    CashReceiptsJournal?: CashReceiptsJournalListRelationFilter
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    corporateName?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    emailAddress?: SortOrder
    address?: AddressOrderByRelationAggregateInput
    product?: ProductOrderByRelationAggregateInput
    invoice?: invoiceOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    Journal?: JournalOrderByRelationAggregateInput
    SalesJournal?: SalesJournalOrderByRelationAggregateInput
    CashDisbursementsJournal?: CashDisbursementsJournalOrderByRelationAggregateInput
    CashReceiptsJournal?: CashReceiptsJournalOrderByRelationAggregateInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = {
    id?: string
    phoneNumber?: string
    corporateName?: string
    emailAddress?: string
  }

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    corporateName?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    emailAddress?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SupplierScalarWhereWithAggregatesInput>
    OR?: Enumerable<SupplierScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SupplierScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    firstName?: StringNullableWithAggregatesFilter | string | null
    lastName?: StringNullableWithAggregatesFilter | string | null
    phoneNumber?: StringNullableWithAggregatesFilter | string | null
    corporateName?: StringNullableWithAggregatesFilter | string | null
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    emailAddress?: StringNullableWithAggregatesFilter | string | null
  }

  export type CustomerWhereInput = {
    AND?: Enumerable<CustomerWhereInput>
    OR?: Enumerable<CustomerWhereInput>
    NOT?: Enumerable<CustomerWhereInput>
    id?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    phoneNumber?: StringNullableFilter | string | null
    emailAddress?: StringNullableFilter | string | null
    updatedAt?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    address?: AddressListRelationFilter
    invoice?: InvoiceListRelationFilter
    transaction?: TransactionListRelationFilter
    Journal?: JournalListRelationFilter
    PurchasesJournal?: PurchasesJournalListRelationFilter
    CashDisbursementsJournal?: CashDisbursementsJournalListRelationFilter
    CashReceiptsJournal?: CashReceiptsJournalListRelationFilter
    ReturnsInwardsJournal?: ReturnsInwardsJournalListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    emailAddress?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    address?: AddressOrderByRelationAggregateInput
    invoice?: invoiceOrderByRelationAggregateInput
    transaction?: TransactionOrderByRelationAggregateInput
    Journal?: JournalOrderByRelationAggregateInput
    PurchasesJournal?: PurchasesJournalOrderByRelationAggregateInput
    CashDisbursementsJournal?: CashDisbursementsJournalOrderByRelationAggregateInput
    CashReceiptsJournal?: CashReceiptsJournalOrderByRelationAggregateInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = {
    id?: string
  }

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    emailAddress?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    phoneNumber?: StringNullableWithAggregatesFilter | string | null
    emailAddress?: StringNullableWithAggregatesFilter | string | null
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AddressWhereInput = {
    AND?: Enumerable<AddressWhereInput>
    OR?: Enumerable<AddressWhereInput>
    NOT?: Enumerable<AddressWhereInput>
    id?: StringFilter | string
    supplierId?: StringNullableFilter | string | null
    customerId?: StringNullableFilter | string | null
    street?: StringFilter | string
    city?: StringFilter | string
    country?: StringFilter | string
    zip?: StringNullableFilter | string | null
    customers?: XOR<CustomerRelationFilter, CustomerWhereInput> | null
    suppliers?: XOR<SupplierRelationFilter, SupplierWhereInput> | null
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    customerId?: SortOrder
    street?: SortOrder
    city?: SortOrder
    country?: SortOrder
    zip?: SortOrder
    customers?: CustomerOrderByWithRelationInput
    suppliers?: SupplierOrderByWithRelationInput
  }

  export type AddressWhereUniqueInput = {
    id?: string
  }

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    customerId?: SortOrder
    street?: SortOrder
    city?: SortOrder
    country?: SortOrder
    zip?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<AddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AddressScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    supplierId?: StringNullableWithAggregatesFilter | string | null
    customerId?: StringNullableWithAggregatesFilter | string | null
    street?: StringWithAggregatesFilter | string
    city?: StringWithAggregatesFilter | string
    country?: StringWithAggregatesFilter | string
    zip?: StringNullableWithAggregatesFilter | string | null
  }

  export type baseCurrencyWhereInput = {
    AND?: Enumerable<baseCurrencyWhereInput>
    OR?: Enumerable<baseCurrencyWhereInput>
    NOT?: Enumerable<baseCurrencyWhereInput>
    id?: StringFilter | string
    currencyId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    active?: BoolFilter | boolean
    currency?: XOR<CurrencyRelationFilter, currencyWhereInput>
    exchangeRates?: ExchangeRatesListRelationFilter
  }

  export type baseCurrencyOrderByWithRelationInput = {
    id?: SortOrder
    currencyId?: SortOrder
    createdAt?: SortOrder
    active?: SortOrder
    currency?: currencyOrderByWithRelationInput
    exchangeRates?: exchangeRatesOrderByRelationAggregateInput
  }

  export type baseCurrencyWhereUniqueInput = {
    id?: string
  }

  export type baseCurrencyOrderByWithAggregationInput = {
    id?: SortOrder
    currencyId?: SortOrder
    createdAt?: SortOrder
    active?: SortOrder
    _count?: baseCurrencyCountOrderByAggregateInput
    _max?: baseCurrencyMaxOrderByAggregateInput
    _min?: baseCurrencyMinOrderByAggregateInput
  }

  export type baseCurrencyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<baseCurrencyScalarWhereWithAggregatesInput>
    OR?: Enumerable<baseCurrencyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<baseCurrencyScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    currencyId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    active?: BoolWithAggregatesFilter | boolean
  }

  export type currencyWhereInput = {
    AND?: Enumerable<currencyWhereInput>
    OR?: Enumerable<currencyWhereInput>
    NOT?: Enumerable<currencyWhereInput>
    id?: StringFilter | string
    currencyName?: StringFilter | string
    updatedAt?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    baseCurrency?: BaseCurrencyListRelationFilter
    exchangeRates?: ExchangeRatesListRelationFilter
    payments?: PaymentListRelationFilter
    tax?: TaxListRelationFilter
  }

  export type currencyOrderByWithRelationInput = {
    id?: SortOrder
    currencyName?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    baseCurrency?: baseCurrencyOrderByRelationAggregateInput
    exchangeRates?: exchangeRatesOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    tax?: TaxOrderByRelationAggregateInput
  }

  export type currencyWhereUniqueInput = {
    id?: string
    currencyName?: string
  }

  export type currencyOrderByWithAggregationInput = {
    id?: SortOrder
    currencyName?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: currencyCountOrderByAggregateInput
    _max?: currencyMaxOrderByAggregateInput
    _min?: currencyMinOrderByAggregateInput
  }

  export type currencyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<currencyScalarWhereWithAggregatesInput>
    OR?: Enumerable<currencyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<currencyScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    currencyName?: StringWithAggregatesFilter | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type disposalsWhereInput = {
    AND?: Enumerable<disposalsWhereInput>
    OR?: Enumerable<disposalsWhereInput>
    NOT?: Enumerable<disposalsWhereInput>
    id?: StringFilter | string
    productId?: StringFilter | string
    priceId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    prices?: XOR<PricesRelationFilter, PricesWhereInput>
    products?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type disposalsOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    priceId?: SortOrder
    createdAt?: SortOrder
    prices?: PricesOrderByWithRelationInput
    products?: ProductOrderByWithRelationInput
  }

  export type disposalsWhereUniqueInput = {
    id?: string
  }

  export type disposalsOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    priceId?: SortOrder
    createdAt?: SortOrder
    _count?: disposalsCountOrderByAggregateInput
    _max?: disposalsMaxOrderByAggregateInput
    _min?: disposalsMinOrderByAggregateInput
  }

  export type disposalsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<disposalsScalarWhereWithAggregatesInput>
    OR?: Enumerable<disposalsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<disposalsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    productId?: StringWithAggregatesFilter | string
    priceId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type exchangeRatesWhereInput = {
    AND?: Enumerable<exchangeRatesWhereInput>
    OR?: Enumerable<exchangeRatesWhereInput>
    NOT?: Enumerable<exchangeRatesWhereInput>
    id?: StringFilter | string
    exchangeRate?: DecimalFilter | Decimal | DecimalJsLike | number | string
    currencyId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    baseCurrencyId?: StringFilter | string
    active?: BoolFilter | boolean
    baseCurrency?: XOR<BaseCurrencyRelationFilter, baseCurrencyWhereInput>
    currency?: XOR<CurrencyRelationFilter, currencyWhereInput>
    payments?: PaymentListRelationFilter
    prices?: PricesListRelationFilter
  }

  export type exchangeRatesOrderByWithRelationInput = {
    id?: SortOrder
    exchangeRate?: SortOrder
    currencyId?: SortOrder
    createdAt?: SortOrder
    baseCurrencyId?: SortOrder
    active?: SortOrder
    baseCurrency?: baseCurrencyOrderByWithRelationInput
    currency?: currencyOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    prices?: PricesOrderByRelationAggregateInput
  }

  export type exchangeRatesWhereUniqueInput = {
    id?: string
  }

  export type exchangeRatesOrderByWithAggregationInput = {
    id?: SortOrder
    exchangeRate?: SortOrder
    currencyId?: SortOrder
    createdAt?: SortOrder
    baseCurrencyId?: SortOrder
    active?: SortOrder
    _count?: exchangeRatesCountOrderByAggregateInput
    _avg?: exchangeRatesAvgOrderByAggregateInput
    _max?: exchangeRatesMaxOrderByAggregateInput
    _min?: exchangeRatesMinOrderByAggregateInput
    _sum?: exchangeRatesSumOrderByAggregateInput
  }

  export type exchangeRatesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<exchangeRatesScalarWhereWithAggregatesInput>
    OR?: Enumerable<exchangeRatesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<exchangeRatesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    exchangeRate?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    currencyId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    baseCurrencyId?: StringWithAggregatesFilter | string
    active?: BoolWithAggregatesFilter | boolean
  }

  export type JournalWhereInput = {
    AND?: Enumerable<JournalWhereInput>
    OR?: Enumerable<JournalWhereInput>
    NOT?: Enumerable<JournalWhereInput>
    id?: StringFilter | string
    recorder?: XOR<UserRelationFilter, UserWhereInput>
    recorderId?: IntFilter | number
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput> | null
    supplierId?: StringNullableFilter | string | null
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput> | null
    customerId?: StringNullableFilter | string | null
    transaction?: XOR<TransactionRelationFilter, TransactionWhereInput>
    transactionId?: IntFilter | number
    narration?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type JournalOrderByWithRelationInput = {
    id?: SortOrder
    recorder?: UserOrderByWithRelationInput
    recorderId?: SortOrder
    supplier?: SupplierOrderByWithRelationInput
    supplierId?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    customerId?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type JournalWhereUniqueInput = {
    id?: string
  }

  export type JournalOrderByWithAggregationInput = {
    id?: SortOrder
    recorderId?: SortOrder
    supplierId?: SortOrder
    customerId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
    _count?: JournalCountOrderByAggregateInput
    _avg?: JournalAvgOrderByAggregateInput
    _max?: JournalMaxOrderByAggregateInput
    _min?: JournalMinOrderByAggregateInput
    _sum?: JournalSumOrderByAggregateInput
  }

  export type JournalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<JournalScalarWhereWithAggregatesInput>
    OR?: Enumerable<JournalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<JournalScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    recorderId?: IntWithAggregatesFilter | number
    supplierId?: StringNullableWithAggregatesFilter | string | null
    customerId?: StringNullableWithAggregatesFilter | string | null
    transactionId?: IntWithAggregatesFilter | number
    narration?: StringWithAggregatesFilter | string
    amount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalWhereInput = {
    AND?: Enumerable<SalesJournalWhereInput>
    OR?: Enumerable<SalesJournalWhereInput>
    NOT?: Enumerable<SalesJournalWhereInput>
    id?: StringFilter | string
    recorder?: XOR<UserRelationFilter, UserWhereInput>
    recorderId?: IntFilter | number
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    supplierId?: StringFilter | string
    transaction?: XOR<TransactionRelationFilter, TransactionWhereInput>
    transactionId?: IntFilter | number
    narration?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalOrderByWithRelationInput = {
    id?: SortOrder
    recorder?: UserOrderByWithRelationInput
    recorderId?: SortOrder
    supplier?: SupplierOrderByWithRelationInput
    supplierId?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type SalesJournalWhereUniqueInput = {
    id?: string
  }

  export type SalesJournalOrderByWithAggregationInput = {
    id?: SortOrder
    recorderId?: SortOrder
    supplierId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
    _count?: SalesJournalCountOrderByAggregateInput
    _avg?: SalesJournalAvgOrderByAggregateInput
    _max?: SalesJournalMaxOrderByAggregateInput
    _min?: SalesJournalMinOrderByAggregateInput
    _sum?: SalesJournalSumOrderByAggregateInput
  }

  export type SalesJournalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SalesJournalScalarWhereWithAggregatesInput>
    OR?: Enumerable<SalesJournalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SalesJournalScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    recorderId?: IntWithAggregatesFilter | number
    supplierId?: StringWithAggregatesFilter | string
    transactionId?: IntWithAggregatesFilter | number
    narration?: StringWithAggregatesFilter | string
    amount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalWhereInput = {
    AND?: Enumerable<PurchasesJournalWhereInput>
    OR?: Enumerable<PurchasesJournalWhereInput>
    NOT?: Enumerable<PurchasesJournalWhereInput>
    id?: StringFilter | string
    recorder?: XOR<UserRelationFilter, UserWhereInput>
    recorderId?: IntFilter | number
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput> | null
    customerId?: StringNullableFilter | string | null
    transaction?: XOR<TransactionRelationFilter, TransactionWhereInput>
    transactionId?: IntFilter | number
    narration?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalOrderByWithRelationInput = {
    id?: SortOrder
    recorder?: UserOrderByWithRelationInput
    recorderId?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    customerId?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type PurchasesJournalWhereUniqueInput = {
    id?: string
  }

  export type PurchasesJournalOrderByWithAggregationInput = {
    id?: SortOrder
    recorderId?: SortOrder
    customerId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
    _count?: PurchasesJournalCountOrderByAggregateInput
    _avg?: PurchasesJournalAvgOrderByAggregateInput
    _max?: PurchasesJournalMaxOrderByAggregateInput
    _min?: PurchasesJournalMinOrderByAggregateInput
    _sum?: PurchasesJournalSumOrderByAggregateInput
  }

  export type PurchasesJournalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PurchasesJournalScalarWhereWithAggregatesInput>
    OR?: Enumerable<PurchasesJournalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PurchasesJournalScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    recorderId?: IntWithAggregatesFilter | number
    customerId?: StringNullableWithAggregatesFilter | string | null
    transactionId?: IntWithAggregatesFilter | number
    narration?: StringWithAggregatesFilter | string
    amount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalWhereInput = {
    AND?: Enumerable<CashDisbursementsJournalWhereInput>
    OR?: Enumerable<CashDisbursementsJournalWhereInput>
    NOT?: Enumerable<CashDisbursementsJournalWhereInput>
    id?: StringFilter | string
    recorder?: XOR<UserRelationFilter, UserWhereInput>
    recorderId?: IntFilter | number
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput> | null
    supplierId?: StringNullableFilter | string | null
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput> | null
    customerId?: StringNullableFilter | string | null
    transaction?: XOR<TransactionRelationFilter, TransactionWhereInput>
    transactionId?: IntFilter | number
    narration?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalOrderByWithRelationInput = {
    id?: SortOrder
    recorder?: UserOrderByWithRelationInput
    recorderId?: SortOrder
    supplier?: SupplierOrderByWithRelationInput
    supplierId?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    customerId?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type CashDisbursementsJournalWhereUniqueInput = {
    id?: string
  }

  export type CashDisbursementsJournalOrderByWithAggregationInput = {
    id?: SortOrder
    recorderId?: SortOrder
    supplierId?: SortOrder
    customerId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
    _count?: CashDisbursementsJournalCountOrderByAggregateInput
    _avg?: CashDisbursementsJournalAvgOrderByAggregateInput
    _max?: CashDisbursementsJournalMaxOrderByAggregateInput
    _min?: CashDisbursementsJournalMinOrderByAggregateInput
    _sum?: CashDisbursementsJournalSumOrderByAggregateInput
  }

  export type CashDisbursementsJournalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CashDisbursementsJournalScalarWhereWithAggregatesInput>
    OR?: Enumerable<CashDisbursementsJournalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CashDisbursementsJournalScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    recorderId?: IntWithAggregatesFilter | number
    supplierId?: StringNullableWithAggregatesFilter | string | null
    customerId?: StringNullableWithAggregatesFilter | string | null
    transactionId?: IntWithAggregatesFilter | number
    narration?: StringWithAggregatesFilter | string
    amount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalWhereInput = {
    AND?: Enumerable<CashReceiptsJournalWhereInput>
    OR?: Enumerable<CashReceiptsJournalWhereInput>
    NOT?: Enumerable<CashReceiptsJournalWhereInput>
    id?: StringFilter | string
    recorder?: XOR<UserRelationFilter, UserWhereInput>
    recorderId?: IntFilter | number
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput> | null
    supplierId?: StringNullableFilter | string | null
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput> | null
    customerId?: StringNullableFilter | string | null
    transaction?: XOR<TransactionRelationFilter, TransactionWhereInput>
    transactionId?: IntFilter | number
    narration?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalOrderByWithRelationInput = {
    id?: SortOrder
    recorder?: UserOrderByWithRelationInput
    recorderId?: SortOrder
    supplier?: SupplierOrderByWithRelationInput
    supplierId?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    customerId?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type CashReceiptsJournalWhereUniqueInput = {
    id?: string
  }

  export type CashReceiptsJournalOrderByWithAggregationInput = {
    id?: SortOrder
    recorderId?: SortOrder
    supplierId?: SortOrder
    customerId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
    _count?: CashReceiptsJournalCountOrderByAggregateInput
    _avg?: CashReceiptsJournalAvgOrderByAggregateInput
    _max?: CashReceiptsJournalMaxOrderByAggregateInput
    _min?: CashReceiptsJournalMinOrderByAggregateInput
    _sum?: CashReceiptsJournalSumOrderByAggregateInput
  }

  export type CashReceiptsJournalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CashReceiptsJournalScalarWhereWithAggregatesInput>
    OR?: Enumerable<CashReceiptsJournalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CashReceiptsJournalScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    recorderId?: IntWithAggregatesFilter | number
    supplierId?: StringNullableWithAggregatesFilter | string | null
    customerId?: StringNullableWithAggregatesFilter | string | null
    transactionId?: IntWithAggregatesFilter | number
    narration?: StringWithAggregatesFilter | string
    amount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalWhereInput = {
    AND?: Enumerable<ReturnsInwardsJournalWhereInput>
    OR?: Enumerable<ReturnsInwardsJournalWhereInput>
    NOT?: Enumerable<ReturnsInwardsJournalWhereInput>
    id?: StringFilter | string
    recorder?: XOR<UserRelationFilter, UserWhereInput>
    recorderId?: IntFilter | number
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    customerId?: StringFilter | string
    transaction?: XOR<TransactionRelationFilter, TransactionWhereInput>
    transactionId?: IntFilter | number
    narration?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalOrderByWithRelationInput = {
    id?: SortOrder
    recorder?: UserOrderByWithRelationInput
    recorderId?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    customerId?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type ReturnsInwardsJournalWhereUniqueInput = {
    id?: string
  }

  export type ReturnsInwardsJournalOrderByWithAggregationInput = {
    id?: SortOrder
    recorderId?: SortOrder
    customerId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
    _count?: ReturnsInwardsJournalCountOrderByAggregateInput
    _avg?: ReturnsInwardsJournalAvgOrderByAggregateInput
    _max?: ReturnsInwardsJournalMaxOrderByAggregateInput
    _min?: ReturnsInwardsJournalMinOrderByAggregateInput
    _sum?: ReturnsInwardsJournalSumOrderByAggregateInput
  }

  export type ReturnsInwardsJournalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReturnsInwardsJournalScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReturnsInwardsJournalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReturnsInwardsJournalScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    recorderId?: IntWithAggregatesFilter | number
    customerId?: StringWithAggregatesFilter | string
    transactionId?: IntWithAggregatesFilter | number
    narration?: StringWithAggregatesFilter | string
    amount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalWhereInput = {
    AND?: Enumerable<ReturnsOutwardsJournalWhereInput>
    OR?: Enumerable<ReturnsOutwardsJournalWhereInput>
    NOT?: Enumerable<ReturnsOutwardsJournalWhereInput>
    id?: StringFilter | string
    recorder?: XOR<UserRelationFilter, UserWhereInput>
    recorderId?: IntFilter | number
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    supplierId?: StringFilter | string
    transaction?: XOR<TransactionRelationFilter, TransactionWhereInput>
    transactionId?: IntFilter | number
    narration?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalOrderByWithRelationInput = {
    id?: SortOrder
    recorder?: UserOrderByWithRelationInput
    recorderId?: SortOrder
    supplier?: SupplierOrderByWithRelationInput
    supplierId?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type ReturnsOutwardsJournalWhereUniqueInput = {
    id?: string
  }

  export type ReturnsOutwardsJournalOrderByWithAggregationInput = {
    id?: SortOrder
    recorderId?: SortOrder
    supplierId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
    _count?: ReturnsOutwardsJournalCountOrderByAggregateInput
    _avg?: ReturnsOutwardsJournalAvgOrderByAggregateInput
    _max?: ReturnsOutwardsJournalMaxOrderByAggregateInput
    _min?: ReturnsOutwardsJournalMinOrderByAggregateInput
    _sum?: ReturnsOutwardsJournalSumOrderByAggregateInput
  }

  export type ReturnsOutwardsJournalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReturnsOutwardsJournalScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReturnsOutwardsJournalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReturnsOutwardsJournalScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    recorderId?: IntWithAggregatesFilter | number
    supplierId?: StringWithAggregatesFilter | string
    transactionId?: IntWithAggregatesFilter | number
    narration?: StringWithAggregatesFilter | string
    amount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
  }

  export type UserCreateInput = {
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    invoice?: invoiceCreateNestedManyWithoutCashierInput
    journal?: JournalCreateNestedManyWithoutRecorderInput
    action?: ActionCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUsersInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutRecorderInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutRecorderInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutRecorderInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutRecorderInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutRecorderInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutRecorderInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    invoice?: invoiceUncheckedCreateNestedManyWithoutCashierInput
    journal?: JournalUncheckedCreateNestedManyWithoutRecorderInput
    action?: ActionUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUsersInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutRecorderInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutRecorderInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutRecorderInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutRecorderInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutRecorderInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutRecorderInput
  }

  export type UserUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoiceUpdateManyWithoutCashierNestedInput
    journal?: JournalUpdateManyWithoutRecorderNestedInput
    action?: ActionUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUsersNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutRecorderNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutRecorderNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutRecorderNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutRecorderNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutRecorderNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutRecorderNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoiceUncheckedUpdateManyWithoutCashierNestedInput
    journal?: JournalUncheckedUpdateManyWithoutRecorderNestedInput
    action?: ActionUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUsersNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutRecorderNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutRecorderNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
  }

  export type UserUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActionCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutActionInput
    actionType: boolean
    description: string
  }

  export type ActionUncheckedCreateInput = {
    id?: string
    userId: number
    actionType: boolean
    description: string
  }

  export type ActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutActionNestedInput
    actionType?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    actionType?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ActionCreateManyInput = {
    id?: string
    userId: number
    actionType: boolean
    description: string
  }

  export type ActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    actionType?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionCreateInput = {
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    errorDescription?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    users: UserCreateNestedOneWithoutTransactionInput
    customer?: CustomerCreateNestedOneWithoutTransactionInput
    supplier?: SupplierCreateNestedOneWithoutTransactionsInput
    payments?: PaymentCreateNestedManyWithoutTransactionInput
    invoice?: invoiceCreateNestedManyWithoutTransactionInput
    journal?: JournalCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: number
    initiatedBy: number
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    supplierId?: string | null
    errorDescription?: string | null
    customerId?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    payments?: PaymentUncheckedCreateNestedManyWithoutTransactionInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutTransactionInput
    journal?: JournalUncheckedCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    users?: UserUpdateOneRequiredWithoutTransactionNestedInput
    customer?: CustomerUpdateOneWithoutTransactionNestedInput
    supplier?: SupplierUpdateOneWithoutTransactionsNestedInput
    payments?: PaymentUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUpdateManyWithoutTransactionNestedInput
    journal?: JournalUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    initiatedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    payments?: PaymentUncheckedUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutTransactionNestedInput
    journal?: JournalUncheckedUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: number
    initiatedBy: number
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    supplierId?: string | null
    errorDescription?: string | null
    customerId?: string | null
    type: TransactionType
    status: TransactionStatusCodes
  }

  export type TransactionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    initiatedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
  }

  export type PaymentCreateInput = {
    id?: string
    paymentType: PaymentTypeCreateNestedOneWithoutPaymentInput
    paid: Decimal | DecimalJsLike | number | string
    currency: currencyCreateNestedOneWithoutPaymentsInput
    exchangeRates: exchangeRatesCreateNestedOneWithoutPaymentsInput
    transaction: TransactionCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    paymentTypeId: string
    currencyId: string
    exchangeRateId: string
    transactionId: number
    paid: Decimal | DecimalJsLike | number | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentType?: PaymentTypeUpdateOneRequiredWithoutPaymentNestedInput
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: currencyUpdateOneRequiredWithoutPaymentsNestedInput
    exchangeRates?: exchangeRatesUpdateOneRequiredWithoutPaymentsNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentTypeId?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    exchangeRateId?: StringFieldUpdateOperationsInput | string
    transactionId?: IntFieldUpdateOperationsInput | number
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    paymentTypeId: string
    currencyId: string
    exchangeRateId: string
    transactionId: number
    paid: Decimal | DecimalJsLike | number | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentTypeId?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    exchangeRateId?: StringFieldUpdateOperationsInput | string
    transactionId?: IntFieldUpdateOperationsInput | number
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentTypeCreateInput = {
    id?: string
    paymentTypeName: string
    payment?: PaymentCreateNestedManyWithoutPaymentTypeInput
    charges: Decimal | DecimalJsLike | number | string
    tax?: TaxCreateNestedManyWithoutPaymentTypeInput
    discount: Decimal | DecimalJsLike | number | string
  }

  export type PaymentTypeUncheckedCreateInput = {
    id?: string
    paymentTypeName: string
    payment?: PaymentUncheckedCreateNestedManyWithoutPaymentTypeInput
    charges: Decimal | DecimalJsLike | number | string
    tax?: TaxUncheckedCreateNestedManyWithoutPaymentTypeInput
    discount: Decimal | DecimalJsLike | number | string
  }

  export type PaymentTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentTypeName?: StringFieldUpdateOperationsInput | string
    payment?: PaymentUpdateManyWithoutPaymentTypeNestedInput
    charges?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: TaxUpdateManyWithoutPaymentTypeNestedInput
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentTypeName?: StringFieldUpdateOperationsInput | string
    payment?: PaymentUncheckedUpdateManyWithoutPaymentTypeNestedInput
    charges?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: TaxUncheckedUpdateManyWithoutPaymentTypeNestedInput
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentTypeCreateManyInput = {
    id?: string
    paymentTypeName: string
    charges: Decimal | DecimalJsLike | number | string
    discount: Decimal | DecimalJsLike | number | string
  }

  export type PaymentTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentTypeName?: StringFieldUpdateOperationsInput | string
    charges?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentTypeName?: StringFieldUpdateOperationsInput | string
    charges?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type TaxCreateInput = {
    id?: string
    taxName: string
    taxRate: string
    startAmount: Decimal | DecimalJsLike | number | string
    endAmount: Decimal | DecimalJsLike | number | string
    active?: boolean
    startDate: Date | string
    endDate: Date | string
    PaymentType?: PaymentTypeCreateNestedManyWithoutTaxInput
    currency?: currencyCreateNestedManyWithoutTaxInput
    product?: ProductCreateNestedManyWithoutTaxInput
    invoice?: invoiceCreateNestedManyWithoutTaxInput
    productGroup?: ProductGroupCreateNestedManyWithoutTaxInput
  }

  export type TaxUncheckedCreateInput = {
    id?: string
    taxName: string
    taxRate: string
    startAmount: Decimal | DecimalJsLike | number | string
    endAmount: Decimal | DecimalJsLike | number | string
    active?: boolean
    startDate: Date | string
    endDate: Date | string
    PaymentType?: PaymentTypeUncheckedCreateNestedManyWithoutTaxInput
    currency?: currencyUncheckedCreateNestedManyWithoutTaxInput
    product?: ProductUncheckedCreateNestedManyWithoutTaxInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutTaxInput
    productGroup?: ProductGroupUncheckedCreateNestedManyWithoutTaxInput
  }

  export type TaxUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxName?: StringFieldUpdateOperationsInput | string
    taxRate?: StringFieldUpdateOperationsInput | string
    startAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentType?: PaymentTypeUpdateManyWithoutTaxNestedInput
    currency?: currencyUpdateManyWithoutTaxNestedInput
    product?: ProductUpdateManyWithoutTaxNestedInput
    invoice?: invoiceUpdateManyWithoutTaxNestedInput
    productGroup?: ProductGroupUpdateManyWithoutTaxNestedInput
  }

  export type TaxUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxName?: StringFieldUpdateOperationsInput | string
    taxRate?: StringFieldUpdateOperationsInput | string
    startAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentType?: PaymentTypeUncheckedUpdateManyWithoutTaxNestedInput
    currency?: currencyUncheckedUpdateManyWithoutTaxNestedInput
    product?: ProductUncheckedUpdateManyWithoutTaxNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutTaxNestedInput
    productGroup?: ProductGroupUncheckedUpdateManyWithoutTaxNestedInput
  }

  export type TaxCreateManyInput = {
    id?: string
    taxName: string
    taxRate: string
    startAmount: Decimal | DecimalJsLike | number | string
    endAmount: Decimal | DecimalJsLike | number | string
    active?: boolean
    startDate: Date | string
    endDate: Date | string
  }

  export type TaxUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxName?: StringFieldUpdateOperationsInput | string
    taxRate?: StringFieldUpdateOperationsInput | string
    startAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxName?: StringFieldUpdateOperationsInput | string
    taxRate?: StringFieldUpdateOperationsInput | string
    startAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionsCreateInput = {
    id?: string
    product: ProductCreateNestedOneWithoutPromotionInput
    productGroup: ProductGroupCreateNestedOneWithoutPromotionsInput
    startDate: Date | string
    endDate: Date | string
    discountRate: Decimal | DecimalJsLike | number | string
  }

  export type PromotionsUncheckedCreateInput = {
    id?: string
    productId: string
    productGroupId: string
    startDate: Date | string
    endDate: Date | string
    discountRate: Decimal | DecimalJsLike | number | string
  }

  export type PromotionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutPromotionNestedInput
    productGroup?: ProductGroupUpdateOneRequiredWithoutPromotionsNestedInput
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PromotionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    productGroupId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PromotionsCreateManyInput = {
    id?: string
    productId: string
    productGroupId: string
    startDate: Date | string
    endDate: Date | string
    discountRate: Decimal | DecimalJsLike | number | string
  }

  export type PromotionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PromotionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    productGroupId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ProductGroupCreateInput = {
    id?: string
    product?: ProductCreateNestedManyWithoutProductGroupInput
    Tax?: TaxCreateNestedOneWithoutProductGroupInput
    Promotions?: PromotionsCreateNestedManyWithoutProductGroupInput
  }

  export type ProductGroupUncheckedCreateInput = {
    id?: string
    product?: ProductUncheckedCreateNestedManyWithoutProductGroupInput
    taxId?: string | null
    Promotions?: PromotionsUncheckedCreateNestedManyWithoutProductGroupInput
  }

  export type ProductGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateManyWithoutProductGroupNestedInput
    Tax?: TaxUpdateOneWithoutProductGroupNestedInput
    Promotions?: PromotionsUpdateManyWithoutProductGroupNestedInput
  }

  export type ProductGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    product?: ProductUncheckedUpdateManyWithoutProductGroupNestedInput
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    Promotions?: PromotionsUncheckedUpdateManyWithoutProductGroupNestedInput
  }

  export type ProductGroupCreateManyInput = {
    id?: string
    taxId?: string | null
  }

  export type ProductGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ProductGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateInput = {
    id?: string
    barcode: string
    productName: string
    measurementUnit: MeasurementUnit
    expiryDate: Date | string
    measurementAmount: number
    cost: Decimal | DecimalJsLike | number | string
    quantity: number
    tax?: TaxCreateNestedManyWithoutProductInput
    productGroup?: ProductGroupCreateNestedOneWithoutProductInput
    updatedAt?: Date | string
    createdAt?: Date | string
    depleted?: boolean
    disposed?: boolean
    supplier?: SupplierCreateNestedOneWithoutProductInput
    disposals?: disposalsCreateNestedManyWithoutProductsInput
    price?: PricesCreateNestedManyWithoutProductInput
    promotion?: PromotionsCreateNestedManyWithoutProductInput
    invoice?: invoiceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    barcode: string
    productName: string
    measurementUnit: MeasurementUnit
    expiryDate: Date | string
    measurementAmount: number
    cost: Decimal | DecimalJsLike | number | string
    quantity: number
    supplierId?: string | null
    tax?: TaxUncheckedCreateNestedManyWithoutProductInput
    productGroupId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    depleted?: boolean
    disposed?: boolean
    disposals?: disposalsUncheckedCreateNestedManyWithoutProductsInput
    price?: PricesUncheckedCreateNestedManyWithoutProductInput
    promotion?: PromotionsUncheckedCreateNestedManyWithoutProductInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    measurementUnit?: EnumMeasurementUnitFieldUpdateOperationsInput | MeasurementUnit
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementAmount?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    tax?: TaxUpdateManyWithoutProductNestedInput
    productGroup?: ProductGroupUpdateOneWithoutProductNestedInput
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depleted?: BoolFieldUpdateOperationsInput | boolean
    disposed?: BoolFieldUpdateOperationsInput | boolean
    supplier?: SupplierUpdateOneWithoutProductNestedInput
    disposals?: disposalsUpdateManyWithoutProductsNestedInput
    price?: PricesUpdateManyWithoutProductNestedInput
    promotion?: PromotionsUpdateManyWithoutProductNestedInput
    invoice?: invoiceUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    measurementUnit?: EnumMeasurementUnitFieldUpdateOperationsInput | MeasurementUnit
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementAmount?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: TaxUncheckedUpdateManyWithoutProductNestedInput
    productGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depleted?: BoolFieldUpdateOperationsInput | boolean
    disposed?: BoolFieldUpdateOperationsInput | boolean
    disposals?: disposalsUncheckedUpdateManyWithoutProductsNestedInput
    price?: PricesUncheckedUpdateManyWithoutProductNestedInput
    promotion?: PromotionsUncheckedUpdateManyWithoutProductNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    barcode: string
    productName: string
    measurementUnit: MeasurementUnit
    expiryDate: Date | string
    measurementAmount: number
    cost: Decimal | DecimalJsLike | number | string
    quantity: number
    supplierId?: string | null
    productGroupId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    depleted?: boolean
    disposed?: boolean
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    measurementUnit?: EnumMeasurementUnitFieldUpdateOperationsInput | MeasurementUnit
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementAmount?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depleted?: BoolFieldUpdateOperationsInput | boolean
    disposed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    measurementUnit?: EnumMeasurementUnitFieldUpdateOperationsInput | MeasurementUnit
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementAmount?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    productGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depleted?: BoolFieldUpdateOperationsInput | boolean
    disposed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PricesCreateInput = {
    id?: string
    barcode: string
    price: Decimal | DecimalJsLike | number | string
    active: boolean
    exchangeRates: exchangeRatesCreateNestedOneWithoutPricesInput
    Product?: ProductCreateNestedOneWithoutPriceInput
    disposals?: disposalsCreateNestedManyWithoutPricesInput
  }

  export type PricesUncheckedCreateInput = {
    id?: string
    barcode: string
    price: Decimal | DecimalJsLike | number | string
    active: boolean
    exchangeRateId: string
    productId?: string | null
    disposals?: disposalsUncheckedCreateNestedManyWithoutPricesInput
  }

  export type PricesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    exchangeRates?: exchangeRatesUpdateOneRequiredWithoutPricesNestedInput
    Product?: ProductUpdateOneWithoutPriceNestedInput
    disposals?: disposalsUpdateManyWithoutPricesNestedInput
  }

  export type PricesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    exchangeRateId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    disposals?: disposalsUncheckedUpdateManyWithoutPricesNestedInput
  }

  export type PricesCreateManyInput = {
    id?: string
    barcode: string
    price: Decimal | DecimalJsLike | number | string
    active: boolean
    exchangeRateId: string
    productId?: string | null
  }

  export type PricesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PricesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    exchangeRateId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invoiceCreateInput = {
    id?: string
    discount?: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    tax?: TaxCreateNestedManyWithoutInvoiceInput
    createdAt?: Date | string
    updatedAt?: Date | string
    cashier: UserCreateNestedOneWithoutInvoiceInput
    customer?: CustomerCreateNestedOneWithoutInvoiceInput
    product: ProductCreateNestedOneWithoutInvoiceInput
    transaction: TransactionCreateNestedOneWithoutInvoiceInput
    Supplier?: SupplierCreateNestedOneWithoutInvoiceInput
  }

  export type invoiceUncheckedCreateInput = {
    id?: string
    productId: string
    discount?: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    transactionId: number
    cashierId: number
    tax?: TaxUncheckedCreateNestedManyWithoutInvoiceInput
    customerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierId?: string | null
  }

  export type invoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    tax?: TaxUpdateManyWithoutInvoiceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashier?: UserUpdateOneRequiredWithoutInvoiceNestedInput
    customer?: CustomerUpdateOneWithoutInvoiceNestedInput
    product?: ProductUpdateOneRequiredWithoutInvoiceNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutInvoiceNestedInput
    Supplier?: SupplierUpdateOneWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    cashierId?: IntFieldUpdateOperationsInput | number
    tax?: TaxUncheckedUpdateManyWithoutInvoiceNestedInput
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invoiceCreateManyInput = {
    id?: string
    productId: string
    discount?: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    transactionId: number
    cashierId: number
    customerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierId?: string | null
  }

  export type invoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    cashierId?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplierCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
    address?: AddressCreateNestedManyWithoutSuppliersInput
    product?: ProductCreateNestedManyWithoutSupplierInput
    invoice?: invoiceCreateNestedManyWithoutSupplierInput
    transactions?: TransactionCreateNestedManyWithoutSupplierInput
    Journal?: JournalCreateNestedManyWithoutSupplierInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutSupplierInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutSupplierInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutSupplierInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutSuppliersInput
    product?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutSupplierInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSupplierInput
    Journal?: JournalUncheckedCreateNestedManyWithoutSupplierInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutSupplierInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutSupplierInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutSupplierInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutSuppliersNestedInput
    product?: ProductUpdateManyWithoutSupplierNestedInput
    invoice?: invoiceUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUpdateManyWithoutSupplierNestedInput
    Journal?: JournalUpdateManyWithoutSupplierNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutSupplierNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutSupplierNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutSupplierNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutSuppliersNestedInput
    product?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSupplierNestedInput
    Journal?: JournalUncheckedUpdateManyWithoutSupplierNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutSupplierNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutSupplierNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutSupplierNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
  }

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerCreateInput = {
    id?: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    emailAddress?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    address?: AddressCreateNestedManyWithoutCustomersInput
    invoice?: invoiceCreateNestedManyWithoutCustomerInput
    transaction?: TransactionCreateNestedManyWithoutCustomerInput
    Journal?: JournalCreateNestedManyWithoutCustomerInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutCustomerInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutCustomerInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutCustomerInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    emailAddress?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    address?: AddressUncheckedCreateNestedManyWithoutCustomersInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutCustomerInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    Journal?: JournalUncheckedCreateNestedManyWithoutCustomerInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutCustomerInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutCustomerInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutCustomerInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateManyWithoutCustomersNestedInput
    invoice?: invoiceUpdateManyWithoutCustomerNestedInput
    transaction?: TransactionUpdateManyWithoutCustomerNestedInput
    Journal?: JournalUpdateManyWithoutCustomerNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutCustomerNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutCustomerNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutCustomerNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUncheckedUpdateManyWithoutCustomersNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutCustomerNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    Journal?: JournalUncheckedUpdateManyWithoutCustomerNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutCustomerNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutCustomerNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutCustomerNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    emailAddress?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateInput = {
    id?: string
    street: string
    city: string
    country: string
    zip?: string | null
    customers?: CustomerCreateNestedOneWithoutAddressInput
    suppliers?: SupplierCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: string
    supplierId?: string | null
    customerId?: string | null
    street: string
    city: string
    country: string
    zip?: string | null
  }

  export type AddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    customers?: CustomerUpdateOneWithoutAddressNestedInput
    suppliers?: SupplierUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zip?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddressCreateManyInput = {
    id?: string
    supplierId?: string | null
    customerId?: string | null
    street: string
    city: string
    country: string
    zip?: string | null
  }

  export type AddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zip?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zip?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type baseCurrencyCreateInput = {
    id?: string
    createdAt?: Date | string
    active?: boolean
    currency: currencyCreateNestedOneWithoutBaseCurrencyInput
    exchangeRates?: exchangeRatesCreateNestedManyWithoutBaseCurrencyInput
  }

  export type baseCurrencyUncheckedCreateInput = {
    id?: string
    currencyId: string
    createdAt?: Date | string
    active?: boolean
    exchangeRates?: exchangeRatesUncheckedCreateNestedManyWithoutBaseCurrencyInput
  }

  export type baseCurrencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    currency?: currencyUpdateOneRequiredWithoutBaseCurrencyNestedInput
    exchangeRates?: exchangeRatesUpdateManyWithoutBaseCurrencyNestedInput
  }

  export type baseCurrencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    exchangeRates?: exchangeRatesUncheckedUpdateManyWithoutBaseCurrencyNestedInput
  }

  export type baseCurrencyCreateManyInput = {
    id?: string
    currencyId: string
    createdAt?: Date | string
    active?: boolean
  }

  export type baseCurrencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type baseCurrencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type currencyCreateInput = {
    id?: string
    currencyName: string
    updatedAt?: Date | string
    createdAt?: Date | string
    baseCurrency?: baseCurrencyCreateNestedManyWithoutCurrencyInput
    exchangeRates?: exchangeRatesCreateNestedManyWithoutCurrencyInput
    payments?: PaymentCreateNestedManyWithoutCurrencyInput
    tax?: TaxCreateNestedManyWithoutCurrencyInput
  }

  export type currencyUncheckedCreateInput = {
    id?: string
    currencyName: string
    updatedAt?: Date | string
    createdAt?: Date | string
    baseCurrency?: baseCurrencyUncheckedCreateNestedManyWithoutCurrencyInput
    exchangeRates?: exchangeRatesUncheckedCreateNestedManyWithoutCurrencyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCurrencyInput
    tax?: TaxUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type currencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseCurrency?: baseCurrencyUpdateManyWithoutCurrencyNestedInput
    exchangeRates?: exchangeRatesUpdateManyWithoutCurrencyNestedInput
    payments?: PaymentUpdateManyWithoutCurrencyNestedInput
    tax?: TaxUpdateManyWithoutCurrencyNestedInput
  }

  export type currencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseCurrency?: baseCurrencyUncheckedUpdateManyWithoutCurrencyNestedInput
    exchangeRates?: exchangeRatesUncheckedUpdateManyWithoutCurrencyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCurrencyNestedInput
    tax?: TaxUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type currencyCreateManyInput = {
    id?: string
    currencyName: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type currencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type currencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type disposalsCreateInput = {
    id?: string
    createdAt?: Date | string
    prices: PricesCreateNestedOneWithoutDisposalsInput
    products: ProductCreateNestedOneWithoutDisposalsInput
  }

  export type disposalsUncheckedCreateInput = {
    id?: string
    productId: string
    priceId: string
    createdAt?: Date | string
  }

  export type disposalsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: PricesUpdateOneRequiredWithoutDisposalsNestedInput
    products?: ProductUpdateOneRequiredWithoutDisposalsNestedInput
  }

  export type disposalsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    priceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type disposalsCreateManyInput = {
    id?: string
    productId: string
    priceId: string
    createdAt?: Date | string
  }

  export type disposalsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type disposalsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    priceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exchangeRatesCreateInput = {
    id?: string
    exchangeRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    active?: boolean
    baseCurrency: baseCurrencyCreateNestedOneWithoutExchangeRatesInput
    currency: currencyCreateNestedOneWithoutExchangeRatesInput
    payments?: PaymentCreateNestedManyWithoutExchangeRatesInput
    prices?: PricesCreateNestedManyWithoutExchangeRatesInput
  }

  export type exchangeRatesUncheckedCreateInput = {
    id?: string
    exchangeRate: Decimal | DecimalJsLike | number | string
    currencyId: string
    createdAt?: Date | string
    baseCurrencyId: string
    active?: boolean
    payments?: PaymentUncheckedCreateNestedManyWithoutExchangeRatesInput
    prices?: PricesUncheckedCreateNestedManyWithoutExchangeRatesInput
  }

  export type exchangeRatesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    baseCurrency?: baseCurrencyUpdateOneRequiredWithoutExchangeRatesNestedInput
    currency?: currencyUpdateOneRequiredWithoutExchangeRatesNestedInput
    payments?: PaymentUpdateManyWithoutExchangeRatesNestedInput
    prices?: PricesUpdateManyWithoutExchangeRatesNestedInput
  }

  export type exchangeRatesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseCurrencyId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentUncheckedUpdateManyWithoutExchangeRatesNestedInput
    prices?: PricesUncheckedUpdateManyWithoutExchangeRatesNestedInput
  }

  export type exchangeRatesCreateManyInput = {
    id?: string
    exchangeRate: Decimal | DecimalJsLike | number | string
    currencyId: string
    createdAt?: Date | string
    baseCurrencyId: string
    active?: boolean
  }

  export type exchangeRatesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type exchangeRatesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseCurrencyId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JournalCreateInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutJournalInput
    supplier?: SupplierCreateNestedOneWithoutJournalInput
    customer?: CustomerCreateNestedOneWithoutJournalInput
    transaction: TransactionCreateNestedOneWithoutJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type JournalUncheckedCreateInput = {
    id?: string
    recorderId: number
    supplierId?: string | null
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type JournalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutJournalNestedInput
    supplier?: SupplierUpdateOneWithoutJournalNestedInput
    customer?: CustomerUpdateOneWithoutJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type JournalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type JournalCreateManyInput = {
    id?: string
    recorderId: number
    supplierId?: string | null
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type JournalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type JournalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalCreateInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutSalesJournalInput
    supplier: SupplierCreateNestedOneWithoutSalesJournalInput
    transaction: TransactionCreateNestedOneWithoutSalesJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalUncheckedCreateInput = {
    id?: string
    recorderId: number
    supplierId: string
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutSalesJournalNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutSalesJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutSalesJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    supplierId?: StringFieldUpdateOperationsInput | string
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalCreateManyInput = {
    id?: string
    recorderId: number
    supplierId: string
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    supplierId?: StringFieldUpdateOperationsInput | string
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalCreateInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutPurchasesJournalInput
    customer?: CustomerCreateNestedOneWithoutPurchasesJournalInput
    transaction: TransactionCreateNestedOneWithoutPurchasesJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalUncheckedCreateInput = {
    id?: string
    recorderId: number
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutPurchasesJournalNestedInput
    customer?: CustomerUpdateOneWithoutPurchasesJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutPurchasesJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalCreateManyInput = {
    id?: string
    recorderId: number
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalCreateInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutCashDisbursementsJournalInput
    supplier?: SupplierCreateNestedOneWithoutCashDisbursementsJournalInput
    customer?: CustomerCreateNestedOneWithoutCashDisbursementsJournalInput
    transaction: TransactionCreateNestedOneWithoutCashDisbursementsJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalUncheckedCreateInput = {
    id?: string
    recorderId: number
    supplierId?: string | null
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutCashDisbursementsJournalNestedInput
    supplier?: SupplierUpdateOneWithoutCashDisbursementsJournalNestedInput
    customer?: CustomerUpdateOneWithoutCashDisbursementsJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutCashDisbursementsJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalCreateManyInput = {
    id?: string
    recorderId: number
    supplierId?: string | null
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalCreateInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutCashReceiptsJournalInput
    supplier?: SupplierCreateNestedOneWithoutCashReceiptsJournalInput
    customer?: CustomerCreateNestedOneWithoutCashReceiptsJournalInput
    transaction: TransactionCreateNestedOneWithoutCashReceiptsJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalUncheckedCreateInput = {
    id?: string
    recorderId: number
    supplierId?: string | null
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutCashReceiptsJournalNestedInput
    supplier?: SupplierUpdateOneWithoutCashReceiptsJournalNestedInput
    customer?: CustomerUpdateOneWithoutCashReceiptsJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutCashReceiptsJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalCreateManyInput = {
    id?: string
    recorderId: number
    supplierId?: string | null
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalCreateInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutReturnsInwardsJournalInput
    customer: CustomerCreateNestedOneWithoutReturnsInwardsJournalInput
    transaction: TransactionCreateNestedOneWithoutReturnsInwardsJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalUncheckedCreateInput = {
    id?: string
    recorderId: number
    customerId: string
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutReturnsInwardsJournalNestedInput
    customer?: CustomerUpdateOneRequiredWithoutReturnsInwardsJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutReturnsInwardsJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalCreateManyInput = {
    id?: string
    recorderId: number
    customerId: string
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalCreateInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutReturnsOutwardsJournalInput
    supplier: SupplierCreateNestedOneWithoutReturnsOutwardsJournalInput
    transaction: TransactionCreateNestedOneWithoutReturnsOutwardsJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalUncheckedCreateInput = {
    id?: string
    recorderId: number
    supplierId: string
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutReturnsOutwardsJournalNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutReturnsOutwardsJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutReturnsOutwardsJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    supplierId?: StringFieldUpdateOperationsInput | string
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalCreateManyInput = {
    id?: string
    recorderId: number
    supplierId: string
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    supplierId?: StringFieldUpdateOperationsInput | string
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type InvoiceListRelationFilter = {
    every?: invoiceWhereInput
    some?: invoiceWhereInput
    none?: invoiceWhereInput
  }

  export type JournalListRelationFilter = {
    every?: JournalWhereInput
    some?: JournalWhereInput
    none?: JournalWhereInput
  }

  export type ActionListRelationFilter = {
    every?: ActionWhereInput
    some?: ActionWhereInput
    none?: ActionWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type SalesJournalListRelationFilter = {
    every?: SalesJournalWhereInput
    some?: SalesJournalWhereInput
    none?: SalesJournalWhereInput
  }

  export type PurchasesJournalListRelationFilter = {
    every?: PurchasesJournalWhereInput
    some?: PurchasesJournalWhereInput
    none?: PurchasesJournalWhereInput
  }

  export type CashDisbursementsJournalListRelationFilter = {
    every?: CashDisbursementsJournalWhereInput
    some?: CashDisbursementsJournalWhereInput
    none?: CashDisbursementsJournalWhereInput
  }

  export type CashReceiptsJournalListRelationFilter = {
    every?: CashReceiptsJournalWhereInput
    some?: CashReceiptsJournalWhereInput
    none?: CashReceiptsJournalWhereInput
  }

  export type ReturnsInwardsJournalListRelationFilter = {
    every?: ReturnsInwardsJournalWhereInput
    some?: ReturnsInwardsJournalWhereInput
    none?: ReturnsInwardsJournalWhereInput
  }

  export type ReturnsOutwardsJournalListRelationFilter = {
    every?: ReturnsOutwardsJournalWhereInput
    some?: ReturnsOutwardsJournalWhereInput
    none?: ReturnsOutwardsJournalWhereInput
  }

  export type invoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesJournalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchasesJournalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashDisbursementsJournalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashReceiptsJournalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReturnsInwardsJournalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReturnsOutwardsJournalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
    emailAddress?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
    emailAddress?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
    emailAddress?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ActionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    description?: SortOrder
  }

  export type ActionAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type ActionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    description?: SortOrder
  }

  export type ActionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    description?: SortOrder
  }

  export type ActionSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumTransactionTypeFilter = {
    equals?: TransactionType
    in?: Enumerable<TransactionType>
    notIn?: Enumerable<TransactionType>
    not?: NestedEnumTransactionTypeFilter | TransactionType
  }

  export type EnumTransactionStatusCodesFilter = {
    equals?: TransactionStatusCodes
    in?: Enumerable<TransactionStatusCodes>
    notIn?: Enumerable<TransactionStatusCodes>
    not?: NestedEnumTransactionStatusCodesFilter | TransactionStatusCodes
  }

  export type CustomerRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type SupplierRelationFilter = {
    is?: SupplierWhereInput | null
    isNot?: SupplierWhereInput | null
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    initiatedBy?: SortOrder
    createdAt?: SortOrder
    totalPaid?: SortOrder
    totalPayable?: SortOrder
    supplierId?: SortOrder
    errorDescription?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    initiatedBy?: SortOrder
    totalPaid?: SortOrder
    totalPayable?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    initiatedBy?: SortOrder
    createdAt?: SortOrder
    totalPaid?: SortOrder
    totalPayable?: SortOrder
    supplierId?: SortOrder
    errorDescription?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    initiatedBy?: SortOrder
    createdAt?: SortOrder
    totalPaid?: SortOrder
    totalPayable?: SortOrder
    supplierId?: SortOrder
    errorDescription?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    id?: SortOrder
    initiatedBy?: SortOrder
    totalPaid?: SortOrder
    totalPayable?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type EnumTransactionTypeWithAggregatesFilter = {
    equals?: TransactionType
    in?: Enumerable<TransactionType>
    notIn?: Enumerable<TransactionType>
    not?: NestedEnumTransactionTypeWithAggregatesFilter | TransactionType
    _count?: NestedIntFilter
    _min?: NestedEnumTransactionTypeFilter
    _max?: NestedEnumTransactionTypeFilter
  }

  export type EnumTransactionStatusCodesWithAggregatesFilter = {
    equals?: TransactionStatusCodes
    in?: Enumerable<TransactionStatusCodes>
    notIn?: Enumerable<TransactionStatusCodes>
    not?: NestedEnumTransactionStatusCodesWithAggregatesFilter | TransactionStatusCodes
    _count?: NestedIntFilter
    _min?: NestedEnumTransactionStatusCodesFilter
    _max?: NestedEnumTransactionStatusCodesFilter
  }

  export type PaymentTypeRelationFilter = {
    is?: PaymentTypeWhereInput
    isNot?: PaymentTypeWhereInput
  }

  export type DecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type CurrencyRelationFilter = {
    is?: currencyWhereInput
    isNot?: currencyWhereInput
  }

  export type ExchangeRatesRelationFilter = {
    is?: exchangeRatesWhereInput
    isNot?: exchangeRatesWhereInput
  }

  export type TransactionRelationFilter = {
    is?: TransactionWhereInput
    isNot?: TransactionWhereInput
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    paymentTypeId?: SortOrder
    currencyId?: SortOrder
    exchangeRateId?: SortOrder
    transactionId?: SortOrder
    paid?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    transactionId?: SortOrder
    paid?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentTypeId?: SortOrder
    currencyId?: SortOrder
    exchangeRateId?: SortOrder
    transactionId?: SortOrder
    paid?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    paymentTypeId?: SortOrder
    currencyId?: SortOrder
    exchangeRateId?: SortOrder
    transactionId?: SortOrder
    paid?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    transactionId?: SortOrder
    paid?: SortOrder
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type TaxListRelationFilter = {
    every?: TaxWhereInput
    some?: TaxWhereInput
    none?: TaxWhereInput
  }

  export type TaxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentTypeCountOrderByAggregateInput = {
    id?: SortOrder
    paymentTypeName?: SortOrder
    charges?: SortOrder
    discount?: SortOrder
  }

  export type PaymentTypeAvgOrderByAggregateInput = {
    charges?: SortOrder
    discount?: SortOrder
  }

  export type PaymentTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentTypeName?: SortOrder
    charges?: SortOrder
    discount?: SortOrder
  }

  export type PaymentTypeMinOrderByAggregateInput = {
    id?: SortOrder
    paymentTypeName?: SortOrder
    charges?: SortOrder
    discount?: SortOrder
  }

  export type PaymentTypeSumOrderByAggregateInput = {
    charges?: SortOrder
    discount?: SortOrder
  }

  export type PaymentTypeListRelationFilter = {
    every?: PaymentTypeWhereInput
    some?: PaymentTypeWhereInput
    none?: PaymentTypeWhereInput
  }

  export type CurrencyListRelationFilter = {
    every?: currencyWhereInput
    some?: currencyWhereInput
    none?: currencyWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductGroupListRelationFilter = {
    every?: ProductGroupWhereInput
    some?: ProductGroupWhereInput
    none?: ProductGroupWhereInput
  }

  export type PaymentTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type currencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaxCountOrderByAggregateInput = {
    id?: SortOrder
    taxName?: SortOrder
    taxRate?: SortOrder
    startAmount?: SortOrder
    endAmount?: SortOrder
    active?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type TaxAvgOrderByAggregateInput = {
    startAmount?: SortOrder
    endAmount?: SortOrder
  }

  export type TaxMaxOrderByAggregateInput = {
    id?: SortOrder
    taxName?: SortOrder
    taxRate?: SortOrder
    startAmount?: SortOrder
    endAmount?: SortOrder
    active?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type TaxMinOrderByAggregateInput = {
    id?: SortOrder
    taxName?: SortOrder
    taxRate?: SortOrder
    startAmount?: SortOrder
    endAmount?: SortOrder
    active?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type TaxSumOrderByAggregateInput = {
    startAmount?: SortOrder
    endAmount?: SortOrder
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductGroupRelationFilter = {
    is?: ProductGroupWhereInput
    isNot?: ProductGroupWhereInput
  }

  export type PromotionsCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    productGroupId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    discountRate?: SortOrder
  }

  export type PromotionsAvgOrderByAggregateInput = {
    discountRate?: SortOrder
  }

  export type PromotionsMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    productGroupId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    discountRate?: SortOrder
  }

  export type PromotionsMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    productGroupId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    discountRate?: SortOrder
  }

  export type PromotionsSumOrderByAggregateInput = {
    discountRate?: SortOrder
  }

  export type TaxRelationFilter = {
    is?: TaxWhereInput | null
    isNot?: TaxWhereInput | null
  }

  export type PromotionsListRelationFilter = {
    every?: PromotionsWhereInput
    some?: PromotionsWhereInput
    none?: PromotionsWhereInput
  }

  export type PromotionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductGroupCountOrderByAggregateInput = {
    id?: SortOrder
    taxId?: SortOrder
  }

  export type ProductGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    taxId?: SortOrder
  }

  export type ProductGroupMinOrderByAggregateInput = {
    id?: SortOrder
    taxId?: SortOrder
  }

  export type EnumMeasurementUnitFilter = {
    equals?: MeasurementUnit
    in?: Enumerable<MeasurementUnit>
    notIn?: Enumerable<MeasurementUnit>
    not?: NestedEnumMeasurementUnitFilter | MeasurementUnit
  }

  export type DisposalsListRelationFilter = {
    every?: disposalsWhereInput
    some?: disposalsWhereInput
    none?: disposalsWhereInput
  }

  export type PricesListRelationFilter = {
    every?: PricesWhereInput
    some?: PricesWhereInput
    none?: PricesWhereInput
  }

  export type disposalsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PricesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    barcode?: SortOrder
    productName?: SortOrder
    measurementUnit?: SortOrder
    expiryDate?: SortOrder
    measurementAmount?: SortOrder
    cost?: SortOrder
    quantity?: SortOrder
    supplierId?: SortOrder
    productGroupId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    depleted?: SortOrder
    disposed?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    measurementAmount?: SortOrder
    cost?: SortOrder
    quantity?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    barcode?: SortOrder
    productName?: SortOrder
    measurementUnit?: SortOrder
    expiryDate?: SortOrder
    measurementAmount?: SortOrder
    cost?: SortOrder
    quantity?: SortOrder
    supplierId?: SortOrder
    productGroupId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    depleted?: SortOrder
    disposed?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    barcode?: SortOrder
    productName?: SortOrder
    measurementUnit?: SortOrder
    expiryDate?: SortOrder
    measurementAmount?: SortOrder
    cost?: SortOrder
    quantity?: SortOrder
    supplierId?: SortOrder
    productGroupId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    depleted?: SortOrder
    disposed?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    measurementAmount?: SortOrder
    cost?: SortOrder
    quantity?: SortOrder
  }

  export type EnumMeasurementUnitWithAggregatesFilter = {
    equals?: MeasurementUnit
    in?: Enumerable<MeasurementUnit>
    notIn?: Enumerable<MeasurementUnit>
    not?: NestedEnumMeasurementUnitWithAggregatesFilter | MeasurementUnit
    _count?: NestedIntFilter
    _min?: NestedEnumMeasurementUnitFilter
    _max?: NestedEnumMeasurementUnitFilter
  }

  export type PricesCountOrderByAggregateInput = {
    id?: SortOrder
    barcode?: SortOrder
    price?: SortOrder
    active?: SortOrder
    exchangeRateId?: SortOrder
    productId?: SortOrder
  }

  export type PricesAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type PricesMaxOrderByAggregateInput = {
    id?: SortOrder
    barcode?: SortOrder
    price?: SortOrder
    active?: SortOrder
    exchangeRateId?: SortOrder
    productId?: SortOrder
  }

  export type PricesMinOrderByAggregateInput = {
    id?: SortOrder
    barcode?: SortOrder
    price?: SortOrder
    active?: SortOrder
    exchangeRateId?: SortOrder
    productId?: SortOrder
  }

  export type PricesSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type invoiceCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    discount?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    transactionId?: SortOrder
    cashierId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplierId?: SortOrder
  }

  export type invoiceAvgOrderByAggregateInput = {
    discount?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    transactionId?: SortOrder
    cashierId?: SortOrder
  }

  export type invoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    discount?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    transactionId?: SortOrder
    cashierId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplierId?: SortOrder
  }

  export type invoiceMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    discount?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    transactionId?: SortOrder
    cashierId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplierId?: SortOrder
  }

  export type invoiceSumOrderByAggregateInput = {
    discount?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    transactionId?: SortOrder
    cashierId?: SortOrder
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    corporateName?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    emailAddress?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    corporateName?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    emailAddress?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    corporateName?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    emailAddress?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    emailAddress?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    emailAddress?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    emailAddress?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    customerId?: SortOrder
    street?: SortOrder
    city?: SortOrder
    country?: SortOrder
    zip?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    customerId?: SortOrder
    street?: SortOrder
    city?: SortOrder
    country?: SortOrder
    zip?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    customerId?: SortOrder
    street?: SortOrder
    city?: SortOrder
    country?: SortOrder
    zip?: SortOrder
  }

  export type ExchangeRatesListRelationFilter = {
    every?: exchangeRatesWhereInput
    some?: exchangeRatesWhereInput
    none?: exchangeRatesWhereInput
  }

  export type exchangeRatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type baseCurrencyCountOrderByAggregateInput = {
    id?: SortOrder
    currencyId?: SortOrder
    createdAt?: SortOrder
    active?: SortOrder
  }

  export type baseCurrencyMaxOrderByAggregateInput = {
    id?: SortOrder
    currencyId?: SortOrder
    createdAt?: SortOrder
    active?: SortOrder
  }

  export type baseCurrencyMinOrderByAggregateInput = {
    id?: SortOrder
    currencyId?: SortOrder
    createdAt?: SortOrder
    active?: SortOrder
  }

  export type BaseCurrencyListRelationFilter = {
    every?: baseCurrencyWhereInput
    some?: baseCurrencyWhereInput
    none?: baseCurrencyWhereInput
  }

  export type baseCurrencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type currencyCountOrderByAggregateInput = {
    id?: SortOrder
    currencyName?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type currencyMaxOrderByAggregateInput = {
    id?: SortOrder
    currencyName?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type currencyMinOrderByAggregateInput = {
    id?: SortOrder
    currencyName?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PricesRelationFilter = {
    is?: PricesWhereInput
    isNot?: PricesWhereInput
  }

  export type disposalsCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    priceId?: SortOrder
    createdAt?: SortOrder
  }

  export type disposalsMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    priceId?: SortOrder
    createdAt?: SortOrder
  }

  export type disposalsMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    priceId?: SortOrder
    createdAt?: SortOrder
  }

  export type BaseCurrencyRelationFilter = {
    is?: baseCurrencyWhereInput
    isNot?: baseCurrencyWhereInput
  }

  export type exchangeRatesCountOrderByAggregateInput = {
    id?: SortOrder
    exchangeRate?: SortOrder
    currencyId?: SortOrder
    createdAt?: SortOrder
    baseCurrencyId?: SortOrder
    active?: SortOrder
  }

  export type exchangeRatesAvgOrderByAggregateInput = {
    exchangeRate?: SortOrder
  }

  export type exchangeRatesMaxOrderByAggregateInput = {
    id?: SortOrder
    exchangeRate?: SortOrder
    currencyId?: SortOrder
    createdAt?: SortOrder
    baseCurrencyId?: SortOrder
    active?: SortOrder
  }

  export type exchangeRatesMinOrderByAggregateInput = {
    id?: SortOrder
    exchangeRate?: SortOrder
    currencyId?: SortOrder
    createdAt?: SortOrder
    baseCurrencyId?: SortOrder
    active?: SortOrder
  }

  export type exchangeRatesSumOrderByAggregateInput = {
    exchangeRate?: SortOrder
  }

  export type JournalCountOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    supplierId?: SortOrder
    customerId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type JournalAvgOrderByAggregateInput = {
    recorderId?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
  }

  export type JournalMaxOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    supplierId?: SortOrder
    customerId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type JournalMinOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    supplierId?: SortOrder
    customerId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type JournalSumOrderByAggregateInput = {
    recorderId?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
  }

  export type SalesJournalCountOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    supplierId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type SalesJournalAvgOrderByAggregateInput = {
    recorderId?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
  }

  export type SalesJournalMaxOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    supplierId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type SalesJournalMinOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    supplierId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type SalesJournalSumOrderByAggregateInput = {
    recorderId?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
  }

  export type PurchasesJournalCountOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    customerId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type PurchasesJournalAvgOrderByAggregateInput = {
    recorderId?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
  }

  export type PurchasesJournalMaxOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    customerId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type PurchasesJournalMinOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    customerId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type PurchasesJournalSumOrderByAggregateInput = {
    recorderId?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
  }

  export type CashDisbursementsJournalCountOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    supplierId?: SortOrder
    customerId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type CashDisbursementsJournalAvgOrderByAggregateInput = {
    recorderId?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
  }

  export type CashDisbursementsJournalMaxOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    supplierId?: SortOrder
    customerId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type CashDisbursementsJournalMinOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    supplierId?: SortOrder
    customerId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type CashDisbursementsJournalSumOrderByAggregateInput = {
    recorderId?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
  }

  export type CashReceiptsJournalCountOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    supplierId?: SortOrder
    customerId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type CashReceiptsJournalAvgOrderByAggregateInput = {
    recorderId?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
  }

  export type CashReceiptsJournalMaxOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    supplierId?: SortOrder
    customerId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type CashReceiptsJournalMinOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    supplierId?: SortOrder
    customerId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type CashReceiptsJournalSumOrderByAggregateInput = {
    recorderId?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
  }

  export type ReturnsInwardsJournalCountOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    customerId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type ReturnsInwardsJournalAvgOrderByAggregateInput = {
    recorderId?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
  }

  export type ReturnsInwardsJournalMaxOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    customerId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type ReturnsInwardsJournalMinOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    customerId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type ReturnsInwardsJournalSumOrderByAggregateInput = {
    recorderId?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
  }

  export type ReturnsOutwardsJournalCountOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    supplierId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type ReturnsOutwardsJournalAvgOrderByAggregateInput = {
    recorderId?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
  }

  export type ReturnsOutwardsJournalMaxOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    supplierId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type ReturnsOutwardsJournalMinOrderByAggregateInput = {
    id?: SortOrder
    recorderId?: SortOrder
    supplierId?: SortOrder
    transactionId?: SortOrder
    narration?: SortOrder
    amount?: SortOrder
  }

  export type ReturnsOutwardsJournalSumOrderByAggregateInput = {
    recorderId?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
  }

  export type invoiceCreateNestedManyWithoutCashierInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutCashierInput>, Enumerable<invoiceUncheckedCreateWithoutCashierInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutCashierInput>
    createMany?: invoiceCreateManyCashierInputEnvelope
    connect?: Enumerable<invoiceWhereUniqueInput>
  }

  export type JournalCreateNestedManyWithoutRecorderInput = {
    create?: XOR<Enumerable<JournalCreateWithoutRecorderInput>, Enumerable<JournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<JournalCreateOrConnectWithoutRecorderInput>
    createMany?: JournalCreateManyRecorderInputEnvelope
    connect?: Enumerable<JournalWhereUniqueInput>
  }

  export type ActionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ActionCreateWithoutUserInput>, Enumerable<ActionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ActionCreateOrConnectWithoutUserInput>
    createMany?: ActionCreateManyUserInputEnvelope
    connect?: Enumerable<ActionWhereUniqueInput>
  }

  export type TransactionCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutUsersInput>, Enumerable<TransactionUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutUsersInput>
    createMany?: TransactionCreateManyUsersInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type SalesJournalCreateNestedManyWithoutRecorderInput = {
    create?: XOR<Enumerable<SalesJournalCreateWithoutRecorderInput>, Enumerable<SalesJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<SalesJournalCreateOrConnectWithoutRecorderInput>
    createMany?: SalesJournalCreateManyRecorderInputEnvelope
    connect?: Enumerable<SalesJournalWhereUniqueInput>
  }

  export type PurchasesJournalCreateNestedManyWithoutRecorderInput = {
    create?: XOR<Enumerable<PurchasesJournalCreateWithoutRecorderInput>, Enumerable<PurchasesJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<PurchasesJournalCreateOrConnectWithoutRecorderInput>
    createMany?: PurchasesJournalCreateManyRecorderInputEnvelope
    connect?: Enumerable<PurchasesJournalWhereUniqueInput>
  }

  export type CashDisbursementsJournalCreateNestedManyWithoutRecorderInput = {
    create?: XOR<Enumerable<CashDisbursementsJournalCreateWithoutRecorderInput>, Enumerable<CashDisbursementsJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<CashDisbursementsJournalCreateOrConnectWithoutRecorderInput>
    createMany?: CashDisbursementsJournalCreateManyRecorderInputEnvelope
    connect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
  }

  export type CashReceiptsJournalCreateNestedManyWithoutRecorderInput = {
    create?: XOR<Enumerable<CashReceiptsJournalCreateWithoutRecorderInput>, Enumerable<CashReceiptsJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<CashReceiptsJournalCreateOrConnectWithoutRecorderInput>
    createMany?: CashReceiptsJournalCreateManyRecorderInputEnvelope
    connect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
  }

  export type ReturnsInwardsJournalCreateNestedManyWithoutRecorderInput = {
    create?: XOR<Enumerable<ReturnsInwardsJournalCreateWithoutRecorderInput>, Enumerable<ReturnsInwardsJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<ReturnsInwardsJournalCreateOrConnectWithoutRecorderInput>
    createMany?: ReturnsInwardsJournalCreateManyRecorderInputEnvelope
    connect?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
  }

  export type ReturnsOutwardsJournalCreateNestedManyWithoutRecorderInput = {
    create?: XOR<Enumerable<ReturnsOutwardsJournalCreateWithoutRecorderInput>, Enumerable<ReturnsOutwardsJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<ReturnsOutwardsJournalCreateOrConnectWithoutRecorderInput>
    createMany?: ReturnsOutwardsJournalCreateManyRecorderInputEnvelope
    connect?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
  }

  export type invoiceUncheckedCreateNestedManyWithoutCashierInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutCashierInput>, Enumerable<invoiceUncheckedCreateWithoutCashierInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutCashierInput>
    createMany?: invoiceCreateManyCashierInputEnvelope
    connect?: Enumerable<invoiceWhereUniqueInput>
  }

  export type JournalUncheckedCreateNestedManyWithoutRecorderInput = {
    create?: XOR<Enumerable<JournalCreateWithoutRecorderInput>, Enumerable<JournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<JournalCreateOrConnectWithoutRecorderInput>
    createMany?: JournalCreateManyRecorderInputEnvelope
    connect?: Enumerable<JournalWhereUniqueInput>
  }

  export type ActionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ActionCreateWithoutUserInput>, Enumerable<ActionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ActionCreateOrConnectWithoutUserInput>
    createMany?: ActionCreateManyUserInputEnvelope
    connect?: Enumerable<ActionWhereUniqueInput>
  }

  export type TransactionUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutUsersInput>, Enumerable<TransactionUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutUsersInput>
    createMany?: TransactionCreateManyUsersInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type SalesJournalUncheckedCreateNestedManyWithoutRecorderInput = {
    create?: XOR<Enumerable<SalesJournalCreateWithoutRecorderInput>, Enumerable<SalesJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<SalesJournalCreateOrConnectWithoutRecorderInput>
    createMany?: SalesJournalCreateManyRecorderInputEnvelope
    connect?: Enumerable<SalesJournalWhereUniqueInput>
  }

  export type PurchasesJournalUncheckedCreateNestedManyWithoutRecorderInput = {
    create?: XOR<Enumerable<PurchasesJournalCreateWithoutRecorderInput>, Enumerable<PurchasesJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<PurchasesJournalCreateOrConnectWithoutRecorderInput>
    createMany?: PurchasesJournalCreateManyRecorderInputEnvelope
    connect?: Enumerable<PurchasesJournalWhereUniqueInput>
  }

  export type CashDisbursementsJournalUncheckedCreateNestedManyWithoutRecorderInput = {
    create?: XOR<Enumerable<CashDisbursementsJournalCreateWithoutRecorderInput>, Enumerable<CashDisbursementsJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<CashDisbursementsJournalCreateOrConnectWithoutRecorderInput>
    createMany?: CashDisbursementsJournalCreateManyRecorderInputEnvelope
    connect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
  }

  export type CashReceiptsJournalUncheckedCreateNestedManyWithoutRecorderInput = {
    create?: XOR<Enumerable<CashReceiptsJournalCreateWithoutRecorderInput>, Enumerable<CashReceiptsJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<CashReceiptsJournalCreateOrConnectWithoutRecorderInput>
    createMany?: CashReceiptsJournalCreateManyRecorderInputEnvelope
    connect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
  }

  export type ReturnsInwardsJournalUncheckedCreateNestedManyWithoutRecorderInput = {
    create?: XOR<Enumerable<ReturnsInwardsJournalCreateWithoutRecorderInput>, Enumerable<ReturnsInwardsJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<ReturnsInwardsJournalCreateOrConnectWithoutRecorderInput>
    createMany?: ReturnsInwardsJournalCreateManyRecorderInputEnvelope
    connect?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
  }

  export type ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutRecorderInput = {
    create?: XOR<Enumerable<ReturnsOutwardsJournalCreateWithoutRecorderInput>, Enumerable<ReturnsOutwardsJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<ReturnsOutwardsJournalCreateOrConnectWithoutRecorderInput>
    createMany?: ReturnsOutwardsJournalCreateManyRecorderInputEnvelope
    connect?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type invoiceUpdateManyWithoutCashierNestedInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutCashierInput>, Enumerable<invoiceUncheckedCreateWithoutCashierInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutCashierInput>
    upsert?: Enumerable<invoiceUpsertWithWhereUniqueWithoutCashierInput>
    createMany?: invoiceCreateManyCashierInputEnvelope
    set?: Enumerable<invoiceWhereUniqueInput>
    disconnect?: Enumerable<invoiceWhereUniqueInput>
    delete?: Enumerable<invoiceWhereUniqueInput>
    connect?: Enumerable<invoiceWhereUniqueInput>
    update?: Enumerable<invoiceUpdateWithWhereUniqueWithoutCashierInput>
    updateMany?: Enumerable<invoiceUpdateManyWithWhereWithoutCashierInput>
    deleteMany?: Enumerable<invoiceScalarWhereInput>
  }

  export type JournalUpdateManyWithoutRecorderNestedInput = {
    create?: XOR<Enumerable<JournalCreateWithoutRecorderInput>, Enumerable<JournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<JournalCreateOrConnectWithoutRecorderInput>
    upsert?: Enumerable<JournalUpsertWithWhereUniqueWithoutRecorderInput>
    createMany?: JournalCreateManyRecorderInputEnvelope
    set?: Enumerable<JournalWhereUniqueInput>
    disconnect?: Enumerable<JournalWhereUniqueInput>
    delete?: Enumerable<JournalWhereUniqueInput>
    connect?: Enumerable<JournalWhereUniqueInput>
    update?: Enumerable<JournalUpdateWithWhereUniqueWithoutRecorderInput>
    updateMany?: Enumerable<JournalUpdateManyWithWhereWithoutRecorderInput>
    deleteMany?: Enumerable<JournalScalarWhereInput>
  }

  export type ActionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ActionCreateWithoutUserInput>, Enumerable<ActionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ActionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ActionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ActionCreateManyUserInputEnvelope
    set?: Enumerable<ActionWhereUniqueInput>
    disconnect?: Enumerable<ActionWhereUniqueInput>
    delete?: Enumerable<ActionWhereUniqueInput>
    connect?: Enumerable<ActionWhereUniqueInput>
    update?: Enumerable<ActionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ActionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ActionScalarWhereInput>
  }

  export type TransactionUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutUsersInput>, Enumerable<TransactionUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: TransactionCreateManyUsersInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type SalesJournalUpdateManyWithoutRecorderNestedInput = {
    create?: XOR<Enumerable<SalesJournalCreateWithoutRecorderInput>, Enumerable<SalesJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<SalesJournalCreateOrConnectWithoutRecorderInput>
    upsert?: Enumerable<SalesJournalUpsertWithWhereUniqueWithoutRecorderInput>
    createMany?: SalesJournalCreateManyRecorderInputEnvelope
    set?: Enumerable<SalesJournalWhereUniqueInput>
    disconnect?: Enumerable<SalesJournalWhereUniqueInput>
    delete?: Enumerable<SalesJournalWhereUniqueInput>
    connect?: Enumerable<SalesJournalWhereUniqueInput>
    update?: Enumerable<SalesJournalUpdateWithWhereUniqueWithoutRecorderInput>
    updateMany?: Enumerable<SalesJournalUpdateManyWithWhereWithoutRecorderInput>
    deleteMany?: Enumerable<SalesJournalScalarWhereInput>
  }

  export type PurchasesJournalUpdateManyWithoutRecorderNestedInput = {
    create?: XOR<Enumerable<PurchasesJournalCreateWithoutRecorderInput>, Enumerable<PurchasesJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<PurchasesJournalCreateOrConnectWithoutRecorderInput>
    upsert?: Enumerable<PurchasesJournalUpsertWithWhereUniqueWithoutRecorderInput>
    createMany?: PurchasesJournalCreateManyRecorderInputEnvelope
    set?: Enumerable<PurchasesJournalWhereUniqueInput>
    disconnect?: Enumerable<PurchasesJournalWhereUniqueInput>
    delete?: Enumerable<PurchasesJournalWhereUniqueInput>
    connect?: Enumerable<PurchasesJournalWhereUniqueInput>
    update?: Enumerable<PurchasesJournalUpdateWithWhereUniqueWithoutRecorderInput>
    updateMany?: Enumerable<PurchasesJournalUpdateManyWithWhereWithoutRecorderInput>
    deleteMany?: Enumerable<PurchasesJournalScalarWhereInput>
  }

  export type CashDisbursementsJournalUpdateManyWithoutRecorderNestedInput = {
    create?: XOR<Enumerable<CashDisbursementsJournalCreateWithoutRecorderInput>, Enumerable<CashDisbursementsJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<CashDisbursementsJournalCreateOrConnectWithoutRecorderInput>
    upsert?: Enumerable<CashDisbursementsJournalUpsertWithWhereUniqueWithoutRecorderInput>
    createMany?: CashDisbursementsJournalCreateManyRecorderInputEnvelope
    set?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    disconnect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    delete?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    connect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    update?: Enumerable<CashDisbursementsJournalUpdateWithWhereUniqueWithoutRecorderInput>
    updateMany?: Enumerable<CashDisbursementsJournalUpdateManyWithWhereWithoutRecorderInput>
    deleteMany?: Enumerable<CashDisbursementsJournalScalarWhereInput>
  }

  export type CashReceiptsJournalUpdateManyWithoutRecorderNestedInput = {
    create?: XOR<Enumerable<CashReceiptsJournalCreateWithoutRecorderInput>, Enumerable<CashReceiptsJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<CashReceiptsJournalCreateOrConnectWithoutRecorderInput>
    upsert?: Enumerable<CashReceiptsJournalUpsertWithWhereUniqueWithoutRecorderInput>
    createMany?: CashReceiptsJournalCreateManyRecorderInputEnvelope
    set?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    disconnect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    delete?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    connect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    update?: Enumerable<CashReceiptsJournalUpdateWithWhereUniqueWithoutRecorderInput>
    updateMany?: Enumerable<CashReceiptsJournalUpdateManyWithWhereWithoutRecorderInput>
    deleteMany?: Enumerable<CashReceiptsJournalScalarWhereInput>
  }

  export type ReturnsInwardsJournalUpdateManyWithoutRecorderNestedInput = {
    create?: XOR<Enumerable<ReturnsInwardsJournalCreateWithoutRecorderInput>, Enumerable<ReturnsInwardsJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<ReturnsInwardsJournalCreateOrConnectWithoutRecorderInput>
    upsert?: Enumerable<ReturnsInwardsJournalUpsertWithWhereUniqueWithoutRecorderInput>
    createMany?: ReturnsInwardsJournalCreateManyRecorderInputEnvelope
    set?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    disconnect?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    delete?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    connect?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    update?: Enumerable<ReturnsInwardsJournalUpdateWithWhereUniqueWithoutRecorderInput>
    updateMany?: Enumerable<ReturnsInwardsJournalUpdateManyWithWhereWithoutRecorderInput>
    deleteMany?: Enumerable<ReturnsInwardsJournalScalarWhereInput>
  }

  export type ReturnsOutwardsJournalUpdateManyWithoutRecorderNestedInput = {
    create?: XOR<Enumerable<ReturnsOutwardsJournalCreateWithoutRecorderInput>, Enumerable<ReturnsOutwardsJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<ReturnsOutwardsJournalCreateOrConnectWithoutRecorderInput>
    upsert?: Enumerable<ReturnsOutwardsJournalUpsertWithWhereUniqueWithoutRecorderInput>
    createMany?: ReturnsOutwardsJournalCreateManyRecorderInputEnvelope
    set?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    disconnect?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    delete?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    connect?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    update?: Enumerable<ReturnsOutwardsJournalUpdateWithWhereUniqueWithoutRecorderInput>
    updateMany?: Enumerable<ReturnsOutwardsJournalUpdateManyWithWhereWithoutRecorderInput>
    deleteMany?: Enumerable<ReturnsOutwardsJournalScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type invoiceUncheckedUpdateManyWithoutCashierNestedInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutCashierInput>, Enumerable<invoiceUncheckedCreateWithoutCashierInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutCashierInput>
    upsert?: Enumerable<invoiceUpsertWithWhereUniqueWithoutCashierInput>
    createMany?: invoiceCreateManyCashierInputEnvelope
    set?: Enumerable<invoiceWhereUniqueInput>
    disconnect?: Enumerable<invoiceWhereUniqueInput>
    delete?: Enumerable<invoiceWhereUniqueInput>
    connect?: Enumerable<invoiceWhereUniqueInput>
    update?: Enumerable<invoiceUpdateWithWhereUniqueWithoutCashierInput>
    updateMany?: Enumerable<invoiceUpdateManyWithWhereWithoutCashierInput>
    deleteMany?: Enumerable<invoiceScalarWhereInput>
  }

  export type JournalUncheckedUpdateManyWithoutRecorderNestedInput = {
    create?: XOR<Enumerable<JournalCreateWithoutRecorderInput>, Enumerable<JournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<JournalCreateOrConnectWithoutRecorderInput>
    upsert?: Enumerable<JournalUpsertWithWhereUniqueWithoutRecorderInput>
    createMany?: JournalCreateManyRecorderInputEnvelope
    set?: Enumerable<JournalWhereUniqueInput>
    disconnect?: Enumerable<JournalWhereUniqueInput>
    delete?: Enumerable<JournalWhereUniqueInput>
    connect?: Enumerable<JournalWhereUniqueInput>
    update?: Enumerable<JournalUpdateWithWhereUniqueWithoutRecorderInput>
    updateMany?: Enumerable<JournalUpdateManyWithWhereWithoutRecorderInput>
    deleteMany?: Enumerable<JournalScalarWhereInput>
  }

  export type ActionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ActionCreateWithoutUserInput>, Enumerable<ActionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ActionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ActionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ActionCreateManyUserInputEnvelope
    set?: Enumerable<ActionWhereUniqueInput>
    disconnect?: Enumerable<ActionWhereUniqueInput>
    delete?: Enumerable<ActionWhereUniqueInput>
    connect?: Enumerable<ActionWhereUniqueInput>
    update?: Enumerable<ActionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ActionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ActionScalarWhereInput>
  }

  export type TransactionUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutUsersInput>, Enumerable<TransactionUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: TransactionCreateManyUsersInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type SalesJournalUncheckedUpdateManyWithoutRecorderNestedInput = {
    create?: XOR<Enumerable<SalesJournalCreateWithoutRecorderInput>, Enumerable<SalesJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<SalesJournalCreateOrConnectWithoutRecorderInput>
    upsert?: Enumerable<SalesJournalUpsertWithWhereUniqueWithoutRecorderInput>
    createMany?: SalesJournalCreateManyRecorderInputEnvelope
    set?: Enumerable<SalesJournalWhereUniqueInput>
    disconnect?: Enumerable<SalesJournalWhereUniqueInput>
    delete?: Enumerable<SalesJournalWhereUniqueInput>
    connect?: Enumerable<SalesJournalWhereUniqueInput>
    update?: Enumerable<SalesJournalUpdateWithWhereUniqueWithoutRecorderInput>
    updateMany?: Enumerable<SalesJournalUpdateManyWithWhereWithoutRecorderInput>
    deleteMany?: Enumerable<SalesJournalScalarWhereInput>
  }

  export type PurchasesJournalUncheckedUpdateManyWithoutRecorderNestedInput = {
    create?: XOR<Enumerable<PurchasesJournalCreateWithoutRecorderInput>, Enumerable<PurchasesJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<PurchasesJournalCreateOrConnectWithoutRecorderInput>
    upsert?: Enumerable<PurchasesJournalUpsertWithWhereUniqueWithoutRecorderInput>
    createMany?: PurchasesJournalCreateManyRecorderInputEnvelope
    set?: Enumerable<PurchasesJournalWhereUniqueInput>
    disconnect?: Enumerable<PurchasesJournalWhereUniqueInput>
    delete?: Enumerable<PurchasesJournalWhereUniqueInput>
    connect?: Enumerable<PurchasesJournalWhereUniqueInput>
    update?: Enumerable<PurchasesJournalUpdateWithWhereUniqueWithoutRecorderInput>
    updateMany?: Enumerable<PurchasesJournalUpdateManyWithWhereWithoutRecorderInput>
    deleteMany?: Enumerable<PurchasesJournalScalarWhereInput>
  }

  export type CashDisbursementsJournalUncheckedUpdateManyWithoutRecorderNestedInput = {
    create?: XOR<Enumerable<CashDisbursementsJournalCreateWithoutRecorderInput>, Enumerable<CashDisbursementsJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<CashDisbursementsJournalCreateOrConnectWithoutRecorderInput>
    upsert?: Enumerable<CashDisbursementsJournalUpsertWithWhereUniqueWithoutRecorderInput>
    createMany?: CashDisbursementsJournalCreateManyRecorderInputEnvelope
    set?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    disconnect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    delete?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    connect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    update?: Enumerable<CashDisbursementsJournalUpdateWithWhereUniqueWithoutRecorderInput>
    updateMany?: Enumerable<CashDisbursementsJournalUpdateManyWithWhereWithoutRecorderInput>
    deleteMany?: Enumerable<CashDisbursementsJournalScalarWhereInput>
  }

  export type CashReceiptsJournalUncheckedUpdateManyWithoutRecorderNestedInput = {
    create?: XOR<Enumerable<CashReceiptsJournalCreateWithoutRecorderInput>, Enumerable<CashReceiptsJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<CashReceiptsJournalCreateOrConnectWithoutRecorderInput>
    upsert?: Enumerable<CashReceiptsJournalUpsertWithWhereUniqueWithoutRecorderInput>
    createMany?: CashReceiptsJournalCreateManyRecorderInputEnvelope
    set?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    disconnect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    delete?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    connect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    update?: Enumerable<CashReceiptsJournalUpdateWithWhereUniqueWithoutRecorderInput>
    updateMany?: Enumerable<CashReceiptsJournalUpdateManyWithWhereWithoutRecorderInput>
    deleteMany?: Enumerable<CashReceiptsJournalScalarWhereInput>
  }

  export type ReturnsInwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput = {
    create?: XOR<Enumerable<ReturnsInwardsJournalCreateWithoutRecorderInput>, Enumerable<ReturnsInwardsJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<ReturnsInwardsJournalCreateOrConnectWithoutRecorderInput>
    upsert?: Enumerable<ReturnsInwardsJournalUpsertWithWhereUniqueWithoutRecorderInput>
    createMany?: ReturnsInwardsJournalCreateManyRecorderInputEnvelope
    set?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    disconnect?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    delete?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    connect?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    update?: Enumerable<ReturnsInwardsJournalUpdateWithWhereUniqueWithoutRecorderInput>
    updateMany?: Enumerable<ReturnsInwardsJournalUpdateManyWithWhereWithoutRecorderInput>
    deleteMany?: Enumerable<ReturnsInwardsJournalScalarWhereInput>
  }

  export type ReturnsOutwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput = {
    create?: XOR<Enumerable<ReturnsOutwardsJournalCreateWithoutRecorderInput>, Enumerable<ReturnsOutwardsJournalUncheckedCreateWithoutRecorderInput>>
    connectOrCreate?: Enumerable<ReturnsOutwardsJournalCreateOrConnectWithoutRecorderInput>
    upsert?: Enumerable<ReturnsOutwardsJournalUpsertWithWhereUniqueWithoutRecorderInput>
    createMany?: ReturnsOutwardsJournalCreateManyRecorderInputEnvelope
    set?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    disconnect?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    delete?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    connect?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    update?: Enumerable<ReturnsOutwardsJournalUpdateWithWhereUniqueWithoutRecorderInput>
    updateMany?: Enumerable<ReturnsOutwardsJournalUpdateManyWithWhereWithoutRecorderInput>
    deleteMany?: Enumerable<ReturnsOutwardsJournalScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutActionInput = {
    create?: XOR<UserCreateWithoutActionInput, UserUncheckedCreateWithoutActionInput>
    connectOrCreate?: UserCreateOrConnectWithoutActionInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutActionNestedInput = {
    create?: XOR<UserCreateWithoutActionInput, UserUncheckedCreateWithoutActionInput>
    connectOrCreate?: UserCreateOrConnectWithoutActionInput
    upsert?: UserUpsertWithoutActionInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutActionInput, UserUncheckedUpdateWithoutActionInput>
  }

  export type UserCreateNestedOneWithoutTransactionInput = {
    create?: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutTransactionInput = {
    create?: XOR<CustomerCreateWithoutTransactionInput, CustomerUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTransactionInput
    connect?: CustomerWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<SupplierCreateWithoutTransactionsInput, SupplierUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutTransactionsInput
    connect?: SupplierWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutTransactionInput>, Enumerable<PaymentUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutTransactionInput>
    createMany?: PaymentCreateManyTransactionInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type invoiceCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutTransactionInput>, Enumerable<invoiceUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutTransactionInput>
    createMany?: invoiceCreateManyTransactionInputEnvelope
    connect?: Enumerable<invoiceWhereUniqueInput>
  }

  export type JournalCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Enumerable<JournalCreateWithoutTransactionInput>, Enumerable<JournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<JournalCreateOrConnectWithoutTransactionInput>
    createMany?: JournalCreateManyTransactionInputEnvelope
    connect?: Enumerable<JournalWhereUniqueInput>
  }

  export type SalesJournalCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Enumerable<SalesJournalCreateWithoutTransactionInput>, Enumerable<SalesJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<SalesJournalCreateOrConnectWithoutTransactionInput>
    createMany?: SalesJournalCreateManyTransactionInputEnvelope
    connect?: Enumerable<SalesJournalWhereUniqueInput>
  }

  export type PurchasesJournalCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Enumerable<PurchasesJournalCreateWithoutTransactionInput>, Enumerable<PurchasesJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<PurchasesJournalCreateOrConnectWithoutTransactionInput>
    createMany?: PurchasesJournalCreateManyTransactionInputEnvelope
    connect?: Enumerable<PurchasesJournalWhereUniqueInput>
  }

  export type CashDisbursementsJournalCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Enumerable<CashDisbursementsJournalCreateWithoutTransactionInput>, Enumerable<CashDisbursementsJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<CashDisbursementsJournalCreateOrConnectWithoutTransactionInput>
    createMany?: CashDisbursementsJournalCreateManyTransactionInputEnvelope
    connect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
  }

  export type CashReceiptsJournalCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Enumerable<CashReceiptsJournalCreateWithoutTransactionInput>, Enumerable<CashReceiptsJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<CashReceiptsJournalCreateOrConnectWithoutTransactionInput>
    createMany?: CashReceiptsJournalCreateManyTransactionInputEnvelope
    connect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
  }

  export type ReturnsInwardsJournalCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Enumerable<ReturnsInwardsJournalCreateWithoutTransactionInput>, Enumerable<ReturnsInwardsJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<ReturnsInwardsJournalCreateOrConnectWithoutTransactionInput>
    createMany?: ReturnsInwardsJournalCreateManyTransactionInputEnvelope
    connect?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
  }

  export type ReturnsOutwardsJournalCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Enumerable<ReturnsOutwardsJournalCreateWithoutTransactionInput>, Enumerable<ReturnsOutwardsJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<ReturnsOutwardsJournalCreateOrConnectWithoutTransactionInput>
    createMany?: ReturnsOutwardsJournalCreateManyTransactionInputEnvelope
    connect?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
  }

  export type PaymentUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutTransactionInput>, Enumerable<PaymentUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutTransactionInput>
    createMany?: PaymentCreateManyTransactionInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type invoiceUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutTransactionInput>, Enumerable<invoiceUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutTransactionInput>
    createMany?: invoiceCreateManyTransactionInputEnvelope
    connect?: Enumerable<invoiceWhereUniqueInput>
  }

  export type JournalUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Enumerable<JournalCreateWithoutTransactionInput>, Enumerable<JournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<JournalCreateOrConnectWithoutTransactionInput>
    createMany?: JournalCreateManyTransactionInputEnvelope
    connect?: Enumerable<JournalWhereUniqueInput>
  }

  export type SalesJournalUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Enumerable<SalesJournalCreateWithoutTransactionInput>, Enumerable<SalesJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<SalesJournalCreateOrConnectWithoutTransactionInput>
    createMany?: SalesJournalCreateManyTransactionInputEnvelope
    connect?: Enumerable<SalesJournalWhereUniqueInput>
  }

  export type PurchasesJournalUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Enumerable<PurchasesJournalCreateWithoutTransactionInput>, Enumerable<PurchasesJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<PurchasesJournalCreateOrConnectWithoutTransactionInput>
    createMany?: PurchasesJournalCreateManyTransactionInputEnvelope
    connect?: Enumerable<PurchasesJournalWhereUniqueInput>
  }

  export type CashDisbursementsJournalUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Enumerable<CashDisbursementsJournalCreateWithoutTransactionInput>, Enumerable<CashDisbursementsJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<CashDisbursementsJournalCreateOrConnectWithoutTransactionInput>
    createMany?: CashDisbursementsJournalCreateManyTransactionInputEnvelope
    connect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
  }

  export type CashReceiptsJournalUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Enumerable<CashReceiptsJournalCreateWithoutTransactionInput>, Enumerable<CashReceiptsJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<CashReceiptsJournalCreateOrConnectWithoutTransactionInput>
    createMany?: CashReceiptsJournalCreateManyTransactionInputEnvelope
    connect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
  }

  export type ReturnsInwardsJournalUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Enumerable<ReturnsInwardsJournalCreateWithoutTransactionInput>, Enumerable<ReturnsInwardsJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<ReturnsInwardsJournalCreateOrConnectWithoutTransactionInput>
    createMany?: ReturnsInwardsJournalCreateManyTransactionInputEnvelope
    connect?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
  }

  export type ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Enumerable<ReturnsOutwardsJournalCreateWithoutTransactionInput>, Enumerable<ReturnsOutwardsJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<ReturnsOutwardsJournalCreateOrConnectWithoutTransactionInput>
    createMany?: ReturnsOutwardsJournalCreateManyTransactionInputEnvelope
    connect?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: TransactionType
  }

  export type EnumTransactionStatusCodesFieldUpdateOperationsInput = {
    set?: TransactionStatusCodes
  }

  export type UserUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionInput
    upsert?: UserUpsertWithoutTransactionInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTransactionInput, UserUncheckedUpdateWithoutTransactionInput>
  }

  export type CustomerUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<CustomerCreateWithoutTransactionInput, CustomerUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTransactionInput
    upsert?: CustomerUpsertWithoutTransactionInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutTransactionInput, CustomerUncheckedUpdateWithoutTransactionInput>
  }

  export type SupplierUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<SupplierCreateWithoutTransactionsInput, SupplierUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutTransactionsInput
    upsert?: SupplierUpsertWithoutTransactionsInput
    disconnect?: boolean
    delete?: boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<SupplierUpdateWithoutTransactionsInput, SupplierUncheckedUpdateWithoutTransactionsInput>
  }

  export type PaymentUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutTransactionInput>, Enumerable<PaymentUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutTransactionInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutTransactionInput>
    createMany?: PaymentCreateManyTransactionInputEnvelope
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    connect?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutTransactionInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutTransactionInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type invoiceUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutTransactionInput>, Enumerable<invoiceUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutTransactionInput>
    upsert?: Enumerable<invoiceUpsertWithWhereUniqueWithoutTransactionInput>
    createMany?: invoiceCreateManyTransactionInputEnvelope
    set?: Enumerable<invoiceWhereUniqueInput>
    disconnect?: Enumerable<invoiceWhereUniqueInput>
    delete?: Enumerable<invoiceWhereUniqueInput>
    connect?: Enumerable<invoiceWhereUniqueInput>
    update?: Enumerable<invoiceUpdateWithWhereUniqueWithoutTransactionInput>
    updateMany?: Enumerable<invoiceUpdateManyWithWhereWithoutTransactionInput>
    deleteMany?: Enumerable<invoiceScalarWhereInput>
  }

  export type JournalUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Enumerable<JournalCreateWithoutTransactionInput>, Enumerable<JournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<JournalCreateOrConnectWithoutTransactionInput>
    upsert?: Enumerable<JournalUpsertWithWhereUniqueWithoutTransactionInput>
    createMany?: JournalCreateManyTransactionInputEnvelope
    set?: Enumerable<JournalWhereUniqueInput>
    disconnect?: Enumerable<JournalWhereUniqueInput>
    delete?: Enumerable<JournalWhereUniqueInput>
    connect?: Enumerable<JournalWhereUniqueInput>
    update?: Enumerable<JournalUpdateWithWhereUniqueWithoutTransactionInput>
    updateMany?: Enumerable<JournalUpdateManyWithWhereWithoutTransactionInput>
    deleteMany?: Enumerable<JournalScalarWhereInput>
  }

  export type SalesJournalUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Enumerable<SalesJournalCreateWithoutTransactionInput>, Enumerable<SalesJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<SalesJournalCreateOrConnectWithoutTransactionInput>
    upsert?: Enumerable<SalesJournalUpsertWithWhereUniqueWithoutTransactionInput>
    createMany?: SalesJournalCreateManyTransactionInputEnvelope
    set?: Enumerable<SalesJournalWhereUniqueInput>
    disconnect?: Enumerable<SalesJournalWhereUniqueInput>
    delete?: Enumerable<SalesJournalWhereUniqueInput>
    connect?: Enumerable<SalesJournalWhereUniqueInput>
    update?: Enumerable<SalesJournalUpdateWithWhereUniqueWithoutTransactionInput>
    updateMany?: Enumerable<SalesJournalUpdateManyWithWhereWithoutTransactionInput>
    deleteMany?: Enumerable<SalesJournalScalarWhereInput>
  }

  export type PurchasesJournalUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Enumerable<PurchasesJournalCreateWithoutTransactionInput>, Enumerable<PurchasesJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<PurchasesJournalCreateOrConnectWithoutTransactionInput>
    upsert?: Enumerable<PurchasesJournalUpsertWithWhereUniqueWithoutTransactionInput>
    createMany?: PurchasesJournalCreateManyTransactionInputEnvelope
    set?: Enumerable<PurchasesJournalWhereUniqueInput>
    disconnect?: Enumerable<PurchasesJournalWhereUniqueInput>
    delete?: Enumerable<PurchasesJournalWhereUniqueInput>
    connect?: Enumerable<PurchasesJournalWhereUniqueInput>
    update?: Enumerable<PurchasesJournalUpdateWithWhereUniqueWithoutTransactionInput>
    updateMany?: Enumerable<PurchasesJournalUpdateManyWithWhereWithoutTransactionInput>
    deleteMany?: Enumerable<PurchasesJournalScalarWhereInput>
  }

  export type CashDisbursementsJournalUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Enumerable<CashDisbursementsJournalCreateWithoutTransactionInput>, Enumerable<CashDisbursementsJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<CashDisbursementsJournalCreateOrConnectWithoutTransactionInput>
    upsert?: Enumerable<CashDisbursementsJournalUpsertWithWhereUniqueWithoutTransactionInput>
    createMany?: CashDisbursementsJournalCreateManyTransactionInputEnvelope
    set?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    disconnect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    delete?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    connect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    update?: Enumerable<CashDisbursementsJournalUpdateWithWhereUniqueWithoutTransactionInput>
    updateMany?: Enumerable<CashDisbursementsJournalUpdateManyWithWhereWithoutTransactionInput>
    deleteMany?: Enumerable<CashDisbursementsJournalScalarWhereInput>
  }

  export type CashReceiptsJournalUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Enumerable<CashReceiptsJournalCreateWithoutTransactionInput>, Enumerable<CashReceiptsJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<CashReceiptsJournalCreateOrConnectWithoutTransactionInput>
    upsert?: Enumerable<CashReceiptsJournalUpsertWithWhereUniqueWithoutTransactionInput>
    createMany?: CashReceiptsJournalCreateManyTransactionInputEnvelope
    set?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    disconnect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    delete?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    connect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    update?: Enumerable<CashReceiptsJournalUpdateWithWhereUniqueWithoutTransactionInput>
    updateMany?: Enumerable<CashReceiptsJournalUpdateManyWithWhereWithoutTransactionInput>
    deleteMany?: Enumerable<CashReceiptsJournalScalarWhereInput>
  }

  export type ReturnsInwardsJournalUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Enumerable<ReturnsInwardsJournalCreateWithoutTransactionInput>, Enumerable<ReturnsInwardsJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<ReturnsInwardsJournalCreateOrConnectWithoutTransactionInput>
    upsert?: Enumerable<ReturnsInwardsJournalUpsertWithWhereUniqueWithoutTransactionInput>
    createMany?: ReturnsInwardsJournalCreateManyTransactionInputEnvelope
    set?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    disconnect?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    delete?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    connect?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    update?: Enumerable<ReturnsInwardsJournalUpdateWithWhereUniqueWithoutTransactionInput>
    updateMany?: Enumerable<ReturnsInwardsJournalUpdateManyWithWhereWithoutTransactionInput>
    deleteMany?: Enumerable<ReturnsInwardsJournalScalarWhereInput>
  }

  export type ReturnsOutwardsJournalUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Enumerable<ReturnsOutwardsJournalCreateWithoutTransactionInput>, Enumerable<ReturnsOutwardsJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<ReturnsOutwardsJournalCreateOrConnectWithoutTransactionInput>
    upsert?: Enumerable<ReturnsOutwardsJournalUpsertWithWhereUniqueWithoutTransactionInput>
    createMany?: ReturnsOutwardsJournalCreateManyTransactionInputEnvelope
    set?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    disconnect?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    delete?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    connect?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    update?: Enumerable<ReturnsOutwardsJournalUpdateWithWhereUniqueWithoutTransactionInput>
    updateMany?: Enumerable<ReturnsOutwardsJournalUpdateManyWithWhereWithoutTransactionInput>
    deleteMany?: Enumerable<ReturnsOutwardsJournalScalarWhereInput>
  }

  export type PaymentUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutTransactionInput>, Enumerable<PaymentUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutTransactionInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutTransactionInput>
    createMany?: PaymentCreateManyTransactionInputEnvelope
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    connect?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutTransactionInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutTransactionInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type invoiceUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutTransactionInput>, Enumerable<invoiceUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutTransactionInput>
    upsert?: Enumerable<invoiceUpsertWithWhereUniqueWithoutTransactionInput>
    createMany?: invoiceCreateManyTransactionInputEnvelope
    set?: Enumerable<invoiceWhereUniqueInput>
    disconnect?: Enumerable<invoiceWhereUniqueInput>
    delete?: Enumerable<invoiceWhereUniqueInput>
    connect?: Enumerable<invoiceWhereUniqueInput>
    update?: Enumerable<invoiceUpdateWithWhereUniqueWithoutTransactionInput>
    updateMany?: Enumerable<invoiceUpdateManyWithWhereWithoutTransactionInput>
    deleteMany?: Enumerable<invoiceScalarWhereInput>
  }

  export type JournalUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Enumerable<JournalCreateWithoutTransactionInput>, Enumerable<JournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<JournalCreateOrConnectWithoutTransactionInput>
    upsert?: Enumerable<JournalUpsertWithWhereUniqueWithoutTransactionInput>
    createMany?: JournalCreateManyTransactionInputEnvelope
    set?: Enumerable<JournalWhereUniqueInput>
    disconnect?: Enumerable<JournalWhereUniqueInput>
    delete?: Enumerable<JournalWhereUniqueInput>
    connect?: Enumerable<JournalWhereUniqueInput>
    update?: Enumerable<JournalUpdateWithWhereUniqueWithoutTransactionInput>
    updateMany?: Enumerable<JournalUpdateManyWithWhereWithoutTransactionInput>
    deleteMany?: Enumerable<JournalScalarWhereInput>
  }

  export type SalesJournalUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Enumerable<SalesJournalCreateWithoutTransactionInput>, Enumerable<SalesJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<SalesJournalCreateOrConnectWithoutTransactionInput>
    upsert?: Enumerable<SalesJournalUpsertWithWhereUniqueWithoutTransactionInput>
    createMany?: SalesJournalCreateManyTransactionInputEnvelope
    set?: Enumerable<SalesJournalWhereUniqueInput>
    disconnect?: Enumerable<SalesJournalWhereUniqueInput>
    delete?: Enumerable<SalesJournalWhereUniqueInput>
    connect?: Enumerable<SalesJournalWhereUniqueInput>
    update?: Enumerable<SalesJournalUpdateWithWhereUniqueWithoutTransactionInput>
    updateMany?: Enumerable<SalesJournalUpdateManyWithWhereWithoutTransactionInput>
    deleteMany?: Enumerable<SalesJournalScalarWhereInput>
  }

  export type PurchasesJournalUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Enumerable<PurchasesJournalCreateWithoutTransactionInput>, Enumerable<PurchasesJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<PurchasesJournalCreateOrConnectWithoutTransactionInput>
    upsert?: Enumerable<PurchasesJournalUpsertWithWhereUniqueWithoutTransactionInput>
    createMany?: PurchasesJournalCreateManyTransactionInputEnvelope
    set?: Enumerable<PurchasesJournalWhereUniqueInput>
    disconnect?: Enumerable<PurchasesJournalWhereUniqueInput>
    delete?: Enumerable<PurchasesJournalWhereUniqueInput>
    connect?: Enumerable<PurchasesJournalWhereUniqueInput>
    update?: Enumerable<PurchasesJournalUpdateWithWhereUniqueWithoutTransactionInput>
    updateMany?: Enumerable<PurchasesJournalUpdateManyWithWhereWithoutTransactionInput>
    deleteMany?: Enumerable<PurchasesJournalScalarWhereInput>
  }

  export type CashDisbursementsJournalUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Enumerable<CashDisbursementsJournalCreateWithoutTransactionInput>, Enumerable<CashDisbursementsJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<CashDisbursementsJournalCreateOrConnectWithoutTransactionInput>
    upsert?: Enumerable<CashDisbursementsJournalUpsertWithWhereUniqueWithoutTransactionInput>
    createMany?: CashDisbursementsJournalCreateManyTransactionInputEnvelope
    set?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    disconnect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    delete?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    connect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    update?: Enumerable<CashDisbursementsJournalUpdateWithWhereUniqueWithoutTransactionInput>
    updateMany?: Enumerable<CashDisbursementsJournalUpdateManyWithWhereWithoutTransactionInput>
    deleteMany?: Enumerable<CashDisbursementsJournalScalarWhereInput>
  }

  export type CashReceiptsJournalUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Enumerable<CashReceiptsJournalCreateWithoutTransactionInput>, Enumerable<CashReceiptsJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<CashReceiptsJournalCreateOrConnectWithoutTransactionInput>
    upsert?: Enumerable<CashReceiptsJournalUpsertWithWhereUniqueWithoutTransactionInput>
    createMany?: CashReceiptsJournalCreateManyTransactionInputEnvelope
    set?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    disconnect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    delete?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    connect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    update?: Enumerable<CashReceiptsJournalUpdateWithWhereUniqueWithoutTransactionInput>
    updateMany?: Enumerable<CashReceiptsJournalUpdateManyWithWhereWithoutTransactionInput>
    deleteMany?: Enumerable<CashReceiptsJournalScalarWhereInput>
  }

  export type ReturnsInwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Enumerable<ReturnsInwardsJournalCreateWithoutTransactionInput>, Enumerable<ReturnsInwardsJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<ReturnsInwardsJournalCreateOrConnectWithoutTransactionInput>
    upsert?: Enumerable<ReturnsInwardsJournalUpsertWithWhereUniqueWithoutTransactionInput>
    createMany?: ReturnsInwardsJournalCreateManyTransactionInputEnvelope
    set?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    disconnect?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    delete?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    connect?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    update?: Enumerable<ReturnsInwardsJournalUpdateWithWhereUniqueWithoutTransactionInput>
    updateMany?: Enumerable<ReturnsInwardsJournalUpdateManyWithWhereWithoutTransactionInput>
    deleteMany?: Enumerable<ReturnsInwardsJournalScalarWhereInput>
  }

  export type ReturnsOutwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Enumerable<ReturnsOutwardsJournalCreateWithoutTransactionInput>, Enumerable<ReturnsOutwardsJournalUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<ReturnsOutwardsJournalCreateOrConnectWithoutTransactionInput>
    upsert?: Enumerable<ReturnsOutwardsJournalUpsertWithWhereUniqueWithoutTransactionInput>
    createMany?: ReturnsOutwardsJournalCreateManyTransactionInputEnvelope
    set?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    disconnect?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    delete?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    connect?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    update?: Enumerable<ReturnsOutwardsJournalUpdateWithWhereUniqueWithoutTransactionInput>
    updateMany?: Enumerable<ReturnsOutwardsJournalUpdateManyWithWhereWithoutTransactionInput>
    deleteMany?: Enumerable<ReturnsOutwardsJournalScalarWhereInput>
  }

  export type PaymentTypeCreateNestedOneWithoutPaymentInput = {
    create?: XOR<PaymentTypeCreateWithoutPaymentInput, PaymentTypeUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: PaymentTypeCreateOrConnectWithoutPaymentInput
    connect?: PaymentTypeWhereUniqueInput
  }

  export type currencyCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<currencyCreateWithoutPaymentsInput, currencyUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: currencyCreateOrConnectWithoutPaymentsInput
    connect?: currencyWhereUniqueInput
  }

  export type exchangeRatesCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<exchangeRatesCreateWithoutPaymentsInput, exchangeRatesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: exchangeRatesCreateOrConnectWithoutPaymentsInput
    connect?: exchangeRatesWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<TransactionCreateWithoutPaymentsInput, TransactionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentsInput
    connect?: TransactionWhereUniqueInput
  }

  export type PaymentTypeUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<PaymentTypeCreateWithoutPaymentInput, PaymentTypeUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: PaymentTypeCreateOrConnectWithoutPaymentInput
    upsert?: PaymentTypeUpsertWithoutPaymentInput
    connect?: PaymentTypeWhereUniqueInput
    update?: XOR<PaymentTypeUpdateWithoutPaymentInput, PaymentTypeUncheckedUpdateWithoutPaymentInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type currencyUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<currencyCreateWithoutPaymentsInput, currencyUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: currencyCreateOrConnectWithoutPaymentsInput
    upsert?: currencyUpsertWithoutPaymentsInput
    connect?: currencyWhereUniqueInput
    update?: XOR<currencyUpdateWithoutPaymentsInput, currencyUncheckedUpdateWithoutPaymentsInput>
  }

  export type exchangeRatesUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<exchangeRatesCreateWithoutPaymentsInput, exchangeRatesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: exchangeRatesCreateOrConnectWithoutPaymentsInput
    upsert?: exchangeRatesUpsertWithoutPaymentsInput
    connect?: exchangeRatesWhereUniqueInput
    update?: XOR<exchangeRatesUpdateWithoutPaymentsInput, exchangeRatesUncheckedUpdateWithoutPaymentsInput>
  }

  export type TransactionUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<TransactionCreateWithoutPaymentsInput, TransactionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentsInput
    upsert?: TransactionUpsertWithoutPaymentsInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<TransactionUpdateWithoutPaymentsInput, TransactionUncheckedUpdateWithoutPaymentsInput>
  }

  export type PaymentCreateNestedManyWithoutPaymentTypeInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutPaymentTypeInput>, Enumerable<PaymentUncheckedCreateWithoutPaymentTypeInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutPaymentTypeInput>
    createMany?: PaymentCreateManyPaymentTypeInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type TaxCreateNestedManyWithoutPaymentTypeInput = {
    create?: XOR<Enumerable<TaxCreateWithoutPaymentTypeInput>, Enumerable<TaxUncheckedCreateWithoutPaymentTypeInput>>
    connectOrCreate?: Enumerable<TaxCreateOrConnectWithoutPaymentTypeInput>
    connect?: Enumerable<TaxWhereUniqueInput>
  }

  export type PaymentUncheckedCreateNestedManyWithoutPaymentTypeInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutPaymentTypeInput>, Enumerable<PaymentUncheckedCreateWithoutPaymentTypeInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutPaymentTypeInput>
    createMany?: PaymentCreateManyPaymentTypeInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type TaxUncheckedCreateNestedManyWithoutPaymentTypeInput = {
    create?: XOR<Enumerable<TaxCreateWithoutPaymentTypeInput>, Enumerable<TaxUncheckedCreateWithoutPaymentTypeInput>>
    connectOrCreate?: Enumerable<TaxCreateOrConnectWithoutPaymentTypeInput>
    connect?: Enumerable<TaxWhereUniqueInput>
  }

  export type PaymentUpdateManyWithoutPaymentTypeNestedInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutPaymentTypeInput>, Enumerable<PaymentUncheckedCreateWithoutPaymentTypeInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutPaymentTypeInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutPaymentTypeInput>
    createMany?: PaymentCreateManyPaymentTypeInputEnvelope
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    connect?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutPaymentTypeInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutPaymentTypeInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type TaxUpdateManyWithoutPaymentTypeNestedInput = {
    create?: XOR<Enumerable<TaxCreateWithoutPaymentTypeInput>, Enumerable<TaxUncheckedCreateWithoutPaymentTypeInput>>
    connectOrCreate?: Enumerable<TaxCreateOrConnectWithoutPaymentTypeInput>
    upsert?: Enumerable<TaxUpsertWithWhereUniqueWithoutPaymentTypeInput>
    set?: Enumerable<TaxWhereUniqueInput>
    disconnect?: Enumerable<TaxWhereUniqueInput>
    delete?: Enumerable<TaxWhereUniqueInput>
    connect?: Enumerable<TaxWhereUniqueInput>
    update?: Enumerable<TaxUpdateWithWhereUniqueWithoutPaymentTypeInput>
    updateMany?: Enumerable<TaxUpdateManyWithWhereWithoutPaymentTypeInput>
    deleteMany?: Enumerable<TaxScalarWhereInput>
  }

  export type PaymentUncheckedUpdateManyWithoutPaymentTypeNestedInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutPaymentTypeInput>, Enumerable<PaymentUncheckedCreateWithoutPaymentTypeInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutPaymentTypeInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutPaymentTypeInput>
    createMany?: PaymentCreateManyPaymentTypeInputEnvelope
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    connect?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutPaymentTypeInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutPaymentTypeInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type TaxUncheckedUpdateManyWithoutPaymentTypeNestedInput = {
    create?: XOR<Enumerable<TaxCreateWithoutPaymentTypeInput>, Enumerable<TaxUncheckedCreateWithoutPaymentTypeInput>>
    connectOrCreate?: Enumerable<TaxCreateOrConnectWithoutPaymentTypeInput>
    upsert?: Enumerable<TaxUpsertWithWhereUniqueWithoutPaymentTypeInput>
    set?: Enumerable<TaxWhereUniqueInput>
    disconnect?: Enumerable<TaxWhereUniqueInput>
    delete?: Enumerable<TaxWhereUniqueInput>
    connect?: Enumerable<TaxWhereUniqueInput>
    update?: Enumerable<TaxUpdateWithWhereUniqueWithoutPaymentTypeInput>
    updateMany?: Enumerable<TaxUpdateManyWithWhereWithoutPaymentTypeInput>
    deleteMany?: Enumerable<TaxScalarWhereInput>
  }

  export type PaymentTypeCreateNestedManyWithoutTaxInput = {
    create?: XOR<Enumerable<PaymentTypeCreateWithoutTaxInput>, Enumerable<PaymentTypeUncheckedCreateWithoutTaxInput>>
    connectOrCreate?: Enumerable<PaymentTypeCreateOrConnectWithoutTaxInput>
    connect?: Enumerable<PaymentTypeWhereUniqueInput>
  }

  export type currencyCreateNestedManyWithoutTaxInput = {
    create?: XOR<Enumerable<currencyCreateWithoutTaxInput>, Enumerable<currencyUncheckedCreateWithoutTaxInput>>
    connectOrCreate?: Enumerable<currencyCreateOrConnectWithoutTaxInput>
    connect?: Enumerable<currencyWhereUniqueInput>
  }

  export type ProductCreateNestedManyWithoutTaxInput = {
    create?: XOR<Enumerable<ProductCreateWithoutTaxInput>, Enumerable<ProductUncheckedCreateWithoutTaxInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutTaxInput>
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type invoiceCreateNestedManyWithoutTaxInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutTaxInput>, Enumerable<invoiceUncheckedCreateWithoutTaxInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutTaxInput>
    connect?: Enumerable<invoiceWhereUniqueInput>
  }

  export type ProductGroupCreateNestedManyWithoutTaxInput = {
    create?: XOR<Enumerable<ProductGroupCreateWithoutTaxInput>, Enumerable<ProductGroupUncheckedCreateWithoutTaxInput>>
    connectOrCreate?: Enumerable<ProductGroupCreateOrConnectWithoutTaxInput>
    createMany?: ProductGroupCreateManyTaxInputEnvelope
    connect?: Enumerable<ProductGroupWhereUniqueInput>
  }

  export type PaymentTypeUncheckedCreateNestedManyWithoutTaxInput = {
    create?: XOR<Enumerable<PaymentTypeCreateWithoutTaxInput>, Enumerable<PaymentTypeUncheckedCreateWithoutTaxInput>>
    connectOrCreate?: Enumerable<PaymentTypeCreateOrConnectWithoutTaxInput>
    connect?: Enumerable<PaymentTypeWhereUniqueInput>
  }

  export type currencyUncheckedCreateNestedManyWithoutTaxInput = {
    create?: XOR<Enumerable<currencyCreateWithoutTaxInput>, Enumerable<currencyUncheckedCreateWithoutTaxInput>>
    connectOrCreate?: Enumerable<currencyCreateOrConnectWithoutTaxInput>
    connect?: Enumerable<currencyWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutTaxInput = {
    create?: XOR<Enumerable<ProductCreateWithoutTaxInput>, Enumerable<ProductUncheckedCreateWithoutTaxInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutTaxInput>
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type invoiceUncheckedCreateNestedManyWithoutTaxInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutTaxInput>, Enumerable<invoiceUncheckedCreateWithoutTaxInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutTaxInput>
    connect?: Enumerable<invoiceWhereUniqueInput>
  }

  export type ProductGroupUncheckedCreateNestedManyWithoutTaxInput = {
    create?: XOR<Enumerable<ProductGroupCreateWithoutTaxInput>, Enumerable<ProductGroupUncheckedCreateWithoutTaxInput>>
    connectOrCreate?: Enumerable<ProductGroupCreateOrConnectWithoutTaxInput>
    createMany?: ProductGroupCreateManyTaxInputEnvelope
    connect?: Enumerable<ProductGroupWhereUniqueInput>
  }

  export type PaymentTypeUpdateManyWithoutTaxNestedInput = {
    create?: XOR<Enumerable<PaymentTypeCreateWithoutTaxInput>, Enumerable<PaymentTypeUncheckedCreateWithoutTaxInput>>
    connectOrCreate?: Enumerable<PaymentTypeCreateOrConnectWithoutTaxInput>
    upsert?: Enumerable<PaymentTypeUpsertWithWhereUniqueWithoutTaxInput>
    set?: Enumerable<PaymentTypeWhereUniqueInput>
    disconnect?: Enumerable<PaymentTypeWhereUniqueInput>
    delete?: Enumerable<PaymentTypeWhereUniqueInput>
    connect?: Enumerable<PaymentTypeWhereUniqueInput>
    update?: Enumerable<PaymentTypeUpdateWithWhereUniqueWithoutTaxInput>
    updateMany?: Enumerable<PaymentTypeUpdateManyWithWhereWithoutTaxInput>
    deleteMany?: Enumerable<PaymentTypeScalarWhereInput>
  }

  export type currencyUpdateManyWithoutTaxNestedInput = {
    create?: XOR<Enumerable<currencyCreateWithoutTaxInput>, Enumerable<currencyUncheckedCreateWithoutTaxInput>>
    connectOrCreate?: Enumerable<currencyCreateOrConnectWithoutTaxInput>
    upsert?: Enumerable<currencyUpsertWithWhereUniqueWithoutTaxInput>
    set?: Enumerable<currencyWhereUniqueInput>
    disconnect?: Enumerable<currencyWhereUniqueInput>
    delete?: Enumerable<currencyWhereUniqueInput>
    connect?: Enumerable<currencyWhereUniqueInput>
    update?: Enumerable<currencyUpdateWithWhereUniqueWithoutTaxInput>
    updateMany?: Enumerable<currencyUpdateManyWithWhereWithoutTaxInput>
    deleteMany?: Enumerable<currencyScalarWhereInput>
  }

  export type ProductUpdateManyWithoutTaxNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutTaxInput>, Enumerable<ProductUncheckedCreateWithoutTaxInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutTaxInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutTaxInput>
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutTaxInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutTaxInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type invoiceUpdateManyWithoutTaxNestedInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutTaxInput>, Enumerable<invoiceUncheckedCreateWithoutTaxInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutTaxInput>
    upsert?: Enumerable<invoiceUpsertWithWhereUniqueWithoutTaxInput>
    set?: Enumerable<invoiceWhereUniqueInput>
    disconnect?: Enumerable<invoiceWhereUniqueInput>
    delete?: Enumerable<invoiceWhereUniqueInput>
    connect?: Enumerable<invoiceWhereUniqueInput>
    update?: Enumerable<invoiceUpdateWithWhereUniqueWithoutTaxInput>
    updateMany?: Enumerable<invoiceUpdateManyWithWhereWithoutTaxInput>
    deleteMany?: Enumerable<invoiceScalarWhereInput>
  }

  export type ProductGroupUpdateManyWithoutTaxNestedInput = {
    create?: XOR<Enumerable<ProductGroupCreateWithoutTaxInput>, Enumerable<ProductGroupUncheckedCreateWithoutTaxInput>>
    connectOrCreate?: Enumerable<ProductGroupCreateOrConnectWithoutTaxInput>
    upsert?: Enumerable<ProductGroupUpsertWithWhereUniqueWithoutTaxInput>
    createMany?: ProductGroupCreateManyTaxInputEnvelope
    set?: Enumerable<ProductGroupWhereUniqueInput>
    disconnect?: Enumerable<ProductGroupWhereUniqueInput>
    delete?: Enumerable<ProductGroupWhereUniqueInput>
    connect?: Enumerable<ProductGroupWhereUniqueInput>
    update?: Enumerable<ProductGroupUpdateWithWhereUniqueWithoutTaxInput>
    updateMany?: Enumerable<ProductGroupUpdateManyWithWhereWithoutTaxInput>
    deleteMany?: Enumerable<ProductGroupScalarWhereInput>
  }

  export type PaymentTypeUncheckedUpdateManyWithoutTaxNestedInput = {
    create?: XOR<Enumerable<PaymentTypeCreateWithoutTaxInput>, Enumerable<PaymentTypeUncheckedCreateWithoutTaxInput>>
    connectOrCreate?: Enumerable<PaymentTypeCreateOrConnectWithoutTaxInput>
    upsert?: Enumerable<PaymentTypeUpsertWithWhereUniqueWithoutTaxInput>
    set?: Enumerable<PaymentTypeWhereUniqueInput>
    disconnect?: Enumerable<PaymentTypeWhereUniqueInput>
    delete?: Enumerable<PaymentTypeWhereUniqueInput>
    connect?: Enumerable<PaymentTypeWhereUniqueInput>
    update?: Enumerable<PaymentTypeUpdateWithWhereUniqueWithoutTaxInput>
    updateMany?: Enumerable<PaymentTypeUpdateManyWithWhereWithoutTaxInput>
    deleteMany?: Enumerable<PaymentTypeScalarWhereInput>
  }

  export type currencyUncheckedUpdateManyWithoutTaxNestedInput = {
    create?: XOR<Enumerable<currencyCreateWithoutTaxInput>, Enumerable<currencyUncheckedCreateWithoutTaxInput>>
    connectOrCreate?: Enumerable<currencyCreateOrConnectWithoutTaxInput>
    upsert?: Enumerable<currencyUpsertWithWhereUniqueWithoutTaxInput>
    set?: Enumerable<currencyWhereUniqueInput>
    disconnect?: Enumerable<currencyWhereUniqueInput>
    delete?: Enumerable<currencyWhereUniqueInput>
    connect?: Enumerable<currencyWhereUniqueInput>
    update?: Enumerable<currencyUpdateWithWhereUniqueWithoutTaxInput>
    updateMany?: Enumerable<currencyUpdateManyWithWhereWithoutTaxInput>
    deleteMany?: Enumerable<currencyScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutTaxNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutTaxInput>, Enumerable<ProductUncheckedCreateWithoutTaxInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutTaxInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutTaxInput>
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutTaxInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutTaxInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type invoiceUncheckedUpdateManyWithoutTaxNestedInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutTaxInput>, Enumerable<invoiceUncheckedCreateWithoutTaxInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutTaxInput>
    upsert?: Enumerable<invoiceUpsertWithWhereUniqueWithoutTaxInput>
    set?: Enumerable<invoiceWhereUniqueInput>
    disconnect?: Enumerable<invoiceWhereUniqueInput>
    delete?: Enumerable<invoiceWhereUniqueInput>
    connect?: Enumerable<invoiceWhereUniqueInput>
    update?: Enumerable<invoiceUpdateWithWhereUniqueWithoutTaxInput>
    updateMany?: Enumerable<invoiceUpdateManyWithWhereWithoutTaxInput>
    deleteMany?: Enumerable<invoiceScalarWhereInput>
  }

  export type ProductGroupUncheckedUpdateManyWithoutTaxNestedInput = {
    create?: XOR<Enumerable<ProductGroupCreateWithoutTaxInput>, Enumerable<ProductGroupUncheckedCreateWithoutTaxInput>>
    connectOrCreate?: Enumerable<ProductGroupCreateOrConnectWithoutTaxInput>
    upsert?: Enumerable<ProductGroupUpsertWithWhereUniqueWithoutTaxInput>
    createMany?: ProductGroupCreateManyTaxInputEnvelope
    set?: Enumerable<ProductGroupWhereUniqueInput>
    disconnect?: Enumerable<ProductGroupWhereUniqueInput>
    delete?: Enumerable<ProductGroupWhereUniqueInput>
    connect?: Enumerable<ProductGroupWhereUniqueInput>
    update?: Enumerable<ProductGroupUpdateWithWhereUniqueWithoutTaxInput>
    updateMany?: Enumerable<ProductGroupUpdateManyWithWhereWithoutTaxInput>
    deleteMany?: Enumerable<ProductGroupScalarWhereInput>
  }

  export type ProductCreateNestedOneWithoutPromotionInput = {
    create?: XOR<ProductCreateWithoutPromotionInput, ProductUncheckedCreateWithoutPromotionInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPromotionInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductGroupCreateNestedOneWithoutPromotionsInput = {
    create?: XOR<ProductGroupCreateWithoutPromotionsInput, ProductGroupUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: ProductGroupCreateOrConnectWithoutPromotionsInput
    connect?: ProductGroupWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutPromotionNestedInput = {
    create?: XOR<ProductCreateWithoutPromotionInput, ProductUncheckedCreateWithoutPromotionInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPromotionInput
    upsert?: ProductUpsertWithoutPromotionInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutPromotionInput, ProductUncheckedUpdateWithoutPromotionInput>
  }

  export type ProductGroupUpdateOneRequiredWithoutPromotionsNestedInput = {
    create?: XOR<ProductGroupCreateWithoutPromotionsInput, ProductGroupUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: ProductGroupCreateOrConnectWithoutPromotionsInput
    upsert?: ProductGroupUpsertWithoutPromotionsInput
    connect?: ProductGroupWhereUniqueInput
    update?: XOR<ProductGroupUpdateWithoutPromotionsInput, ProductGroupUncheckedUpdateWithoutPromotionsInput>
  }

  export type ProductCreateNestedManyWithoutProductGroupInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductGroupInput>, Enumerable<ProductUncheckedCreateWithoutProductGroupInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductGroupInput>
    createMany?: ProductCreateManyProductGroupInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type TaxCreateNestedOneWithoutProductGroupInput = {
    create?: XOR<TaxCreateWithoutProductGroupInput, TaxUncheckedCreateWithoutProductGroupInput>
    connectOrCreate?: TaxCreateOrConnectWithoutProductGroupInput
    connect?: TaxWhereUniqueInput
  }

  export type PromotionsCreateNestedManyWithoutProductGroupInput = {
    create?: XOR<Enumerable<PromotionsCreateWithoutProductGroupInput>, Enumerable<PromotionsUncheckedCreateWithoutProductGroupInput>>
    connectOrCreate?: Enumerable<PromotionsCreateOrConnectWithoutProductGroupInput>
    createMany?: PromotionsCreateManyProductGroupInputEnvelope
    connect?: Enumerable<PromotionsWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutProductGroupInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductGroupInput>, Enumerable<ProductUncheckedCreateWithoutProductGroupInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductGroupInput>
    createMany?: ProductCreateManyProductGroupInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type PromotionsUncheckedCreateNestedManyWithoutProductGroupInput = {
    create?: XOR<Enumerable<PromotionsCreateWithoutProductGroupInput>, Enumerable<PromotionsUncheckedCreateWithoutProductGroupInput>>
    connectOrCreate?: Enumerable<PromotionsCreateOrConnectWithoutProductGroupInput>
    createMany?: PromotionsCreateManyProductGroupInputEnvelope
    connect?: Enumerable<PromotionsWhereUniqueInput>
  }

  export type ProductUpdateManyWithoutProductGroupNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductGroupInput>, Enumerable<ProductUncheckedCreateWithoutProductGroupInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductGroupInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutProductGroupInput>
    createMany?: ProductCreateManyProductGroupInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutProductGroupInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutProductGroupInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type TaxUpdateOneWithoutProductGroupNestedInput = {
    create?: XOR<TaxCreateWithoutProductGroupInput, TaxUncheckedCreateWithoutProductGroupInput>
    connectOrCreate?: TaxCreateOrConnectWithoutProductGroupInput
    upsert?: TaxUpsertWithoutProductGroupInput
    disconnect?: boolean
    delete?: boolean
    connect?: TaxWhereUniqueInput
    update?: XOR<TaxUpdateWithoutProductGroupInput, TaxUncheckedUpdateWithoutProductGroupInput>
  }

  export type PromotionsUpdateManyWithoutProductGroupNestedInput = {
    create?: XOR<Enumerable<PromotionsCreateWithoutProductGroupInput>, Enumerable<PromotionsUncheckedCreateWithoutProductGroupInput>>
    connectOrCreate?: Enumerable<PromotionsCreateOrConnectWithoutProductGroupInput>
    upsert?: Enumerable<PromotionsUpsertWithWhereUniqueWithoutProductGroupInput>
    createMany?: PromotionsCreateManyProductGroupInputEnvelope
    set?: Enumerable<PromotionsWhereUniqueInput>
    disconnect?: Enumerable<PromotionsWhereUniqueInput>
    delete?: Enumerable<PromotionsWhereUniqueInput>
    connect?: Enumerable<PromotionsWhereUniqueInput>
    update?: Enumerable<PromotionsUpdateWithWhereUniqueWithoutProductGroupInput>
    updateMany?: Enumerable<PromotionsUpdateManyWithWhereWithoutProductGroupInput>
    deleteMany?: Enumerable<PromotionsScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutProductGroupNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductGroupInput>, Enumerable<ProductUncheckedCreateWithoutProductGroupInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductGroupInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutProductGroupInput>
    createMany?: ProductCreateManyProductGroupInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutProductGroupInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutProductGroupInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type PromotionsUncheckedUpdateManyWithoutProductGroupNestedInput = {
    create?: XOR<Enumerable<PromotionsCreateWithoutProductGroupInput>, Enumerable<PromotionsUncheckedCreateWithoutProductGroupInput>>
    connectOrCreate?: Enumerable<PromotionsCreateOrConnectWithoutProductGroupInput>
    upsert?: Enumerable<PromotionsUpsertWithWhereUniqueWithoutProductGroupInput>
    createMany?: PromotionsCreateManyProductGroupInputEnvelope
    set?: Enumerable<PromotionsWhereUniqueInput>
    disconnect?: Enumerable<PromotionsWhereUniqueInput>
    delete?: Enumerable<PromotionsWhereUniqueInput>
    connect?: Enumerable<PromotionsWhereUniqueInput>
    update?: Enumerable<PromotionsUpdateWithWhereUniqueWithoutProductGroupInput>
    updateMany?: Enumerable<PromotionsUpdateManyWithWhereWithoutProductGroupInput>
    deleteMany?: Enumerable<PromotionsScalarWhereInput>
  }

  export type TaxCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<TaxCreateWithoutProductInput>, Enumerable<TaxUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<TaxCreateOrConnectWithoutProductInput>
    connect?: Enumerable<TaxWhereUniqueInput>
  }

  export type ProductGroupCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductGroupCreateWithoutProductInput, ProductGroupUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductGroupCreateOrConnectWithoutProductInput
    connect?: ProductGroupWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutProductInput = {
    create?: XOR<SupplierCreateWithoutProductInput, SupplierUncheckedCreateWithoutProductInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutProductInput
    connect?: SupplierWhereUniqueInput
  }

  export type disposalsCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<disposalsCreateWithoutProductsInput>, Enumerable<disposalsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<disposalsCreateOrConnectWithoutProductsInput>
    createMany?: disposalsCreateManyProductsInputEnvelope
    connect?: Enumerable<disposalsWhereUniqueInput>
  }

  export type PricesCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<PricesCreateWithoutProductInput>, Enumerable<PricesUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PricesCreateOrConnectWithoutProductInput>
    createMany?: PricesCreateManyProductInputEnvelope
    connect?: Enumerable<PricesWhereUniqueInput>
  }

  export type PromotionsCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<PromotionsCreateWithoutProductInput>, Enumerable<PromotionsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PromotionsCreateOrConnectWithoutProductInput>
    createMany?: PromotionsCreateManyProductInputEnvelope
    connect?: Enumerable<PromotionsWhereUniqueInput>
  }

  export type invoiceCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutProductInput>, Enumerable<invoiceUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutProductInput>
    createMany?: invoiceCreateManyProductInputEnvelope
    connect?: Enumerable<invoiceWhereUniqueInput>
  }

  export type TaxUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<TaxCreateWithoutProductInput>, Enumerable<TaxUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<TaxCreateOrConnectWithoutProductInput>
    connect?: Enumerable<TaxWhereUniqueInput>
  }

  export type disposalsUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<disposalsCreateWithoutProductsInput>, Enumerable<disposalsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<disposalsCreateOrConnectWithoutProductsInput>
    createMany?: disposalsCreateManyProductsInputEnvelope
    connect?: Enumerable<disposalsWhereUniqueInput>
  }

  export type PricesUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<PricesCreateWithoutProductInput>, Enumerable<PricesUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PricesCreateOrConnectWithoutProductInput>
    createMany?: PricesCreateManyProductInputEnvelope
    connect?: Enumerable<PricesWhereUniqueInput>
  }

  export type PromotionsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<PromotionsCreateWithoutProductInput>, Enumerable<PromotionsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PromotionsCreateOrConnectWithoutProductInput>
    createMany?: PromotionsCreateManyProductInputEnvelope
    connect?: Enumerable<PromotionsWhereUniqueInput>
  }

  export type invoiceUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutProductInput>, Enumerable<invoiceUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutProductInput>
    createMany?: invoiceCreateManyProductInputEnvelope
    connect?: Enumerable<invoiceWhereUniqueInput>
  }

  export type EnumMeasurementUnitFieldUpdateOperationsInput = {
    set?: MeasurementUnit
  }

  export type TaxUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<TaxCreateWithoutProductInput>, Enumerable<TaxUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<TaxCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<TaxUpsertWithWhereUniqueWithoutProductInput>
    set?: Enumerable<TaxWhereUniqueInput>
    disconnect?: Enumerable<TaxWhereUniqueInput>
    delete?: Enumerable<TaxWhereUniqueInput>
    connect?: Enumerable<TaxWhereUniqueInput>
    update?: Enumerable<TaxUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<TaxUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<TaxScalarWhereInput>
  }

  export type ProductGroupUpdateOneWithoutProductNestedInput = {
    create?: XOR<ProductGroupCreateWithoutProductInput, ProductGroupUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductGroupCreateOrConnectWithoutProductInput
    upsert?: ProductGroupUpsertWithoutProductInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductGroupWhereUniqueInput
    update?: XOR<ProductGroupUpdateWithoutProductInput, ProductGroupUncheckedUpdateWithoutProductInput>
  }

  export type SupplierUpdateOneWithoutProductNestedInput = {
    create?: XOR<SupplierCreateWithoutProductInput, SupplierUncheckedCreateWithoutProductInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutProductInput
    upsert?: SupplierUpsertWithoutProductInput
    disconnect?: boolean
    delete?: boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<SupplierUpdateWithoutProductInput, SupplierUncheckedUpdateWithoutProductInput>
  }

  export type disposalsUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Enumerable<disposalsCreateWithoutProductsInput>, Enumerable<disposalsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<disposalsCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<disposalsUpsertWithWhereUniqueWithoutProductsInput>
    createMany?: disposalsCreateManyProductsInputEnvelope
    set?: Enumerable<disposalsWhereUniqueInput>
    disconnect?: Enumerable<disposalsWhereUniqueInput>
    delete?: Enumerable<disposalsWhereUniqueInput>
    connect?: Enumerable<disposalsWhereUniqueInput>
    update?: Enumerable<disposalsUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<disposalsUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<disposalsScalarWhereInput>
  }

  export type PricesUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<PricesCreateWithoutProductInput>, Enumerable<PricesUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PricesCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<PricesUpsertWithWhereUniqueWithoutProductInput>
    createMany?: PricesCreateManyProductInputEnvelope
    set?: Enumerable<PricesWhereUniqueInput>
    disconnect?: Enumerable<PricesWhereUniqueInput>
    delete?: Enumerable<PricesWhereUniqueInput>
    connect?: Enumerable<PricesWhereUniqueInput>
    update?: Enumerable<PricesUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<PricesUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<PricesScalarWhereInput>
  }

  export type PromotionsUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<PromotionsCreateWithoutProductInput>, Enumerable<PromotionsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PromotionsCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<PromotionsUpsertWithWhereUniqueWithoutProductInput>
    createMany?: PromotionsCreateManyProductInputEnvelope
    set?: Enumerable<PromotionsWhereUniqueInput>
    disconnect?: Enumerable<PromotionsWhereUniqueInput>
    delete?: Enumerable<PromotionsWhereUniqueInput>
    connect?: Enumerable<PromotionsWhereUniqueInput>
    update?: Enumerable<PromotionsUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<PromotionsUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<PromotionsScalarWhereInput>
  }

  export type invoiceUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutProductInput>, Enumerable<invoiceUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<invoiceUpsertWithWhereUniqueWithoutProductInput>
    createMany?: invoiceCreateManyProductInputEnvelope
    set?: Enumerable<invoiceWhereUniqueInput>
    disconnect?: Enumerable<invoiceWhereUniqueInput>
    delete?: Enumerable<invoiceWhereUniqueInput>
    connect?: Enumerable<invoiceWhereUniqueInput>
    update?: Enumerable<invoiceUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<invoiceUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<invoiceScalarWhereInput>
  }

  export type TaxUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<TaxCreateWithoutProductInput>, Enumerable<TaxUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<TaxCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<TaxUpsertWithWhereUniqueWithoutProductInput>
    set?: Enumerable<TaxWhereUniqueInput>
    disconnect?: Enumerable<TaxWhereUniqueInput>
    delete?: Enumerable<TaxWhereUniqueInput>
    connect?: Enumerable<TaxWhereUniqueInput>
    update?: Enumerable<TaxUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<TaxUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<TaxScalarWhereInput>
  }

  export type disposalsUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Enumerable<disposalsCreateWithoutProductsInput>, Enumerable<disposalsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<disposalsCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<disposalsUpsertWithWhereUniqueWithoutProductsInput>
    createMany?: disposalsCreateManyProductsInputEnvelope
    set?: Enumerable<disposalsWhereUniqueInput>
    disconnect?: Enumerable<disposalsWhereUniqueInput>
    delete?: Enumerable<disposalsWhereUniqueInput>
    connect?: Enumerable<disposalsWhereUniqueInput>
    update?: Enumerable<disposalsUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<disposalsUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<disposalsScalarWhereInput>
  }

  export type PricesUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<PricesCreateWithoutProductInput>, Enumerable<PricesUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PricesCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<PricesUpsertWithWhereUniqueWithoutProductInput>
    createMany?: PricesCreateManyProductInputEnvelope
    set?: Enumerable<PricesWhereUniqueInput>
    disconnect?: Enumerable<PricesWhereUniqueInput>
    delete?: Enumerable<PricesWhereUniqueInput>
    connect?: Enumerable<PricesWhereUniqueInput>
    update?: Enumerable<PricesUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<PricesUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<PricesScalarWhereInput>
  }

  export type PromotionsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<PromotionsCreateWithoutProductInput>, Enumerable<PromotionsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PromotionsCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<PromotionsUpsertWithWhereUniqueWithoutProductInput>
    createMany?: PromotionsCreateManyProductInputEnvelope
    set?: Enumerable<PromotionsWhereUniqueInput>
    disconnect?: Enumerable<PromotionsWhereUniqueInput>
    delete?: Enumerable<PromotionsWhereUniqueInput>
    connect?: Enumerable<PromotionsWhereUniqueInput>
    update?: Enumerable<PromotionsUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<PromotionsUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<PromotionsScalarWhereInput>
  }

  export type invoiceUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutProductInput>, Enumerable<invoiceUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<invoiceUpsertWithWhereUniqueWithoutProductInput>
    createMany?: invoiceCreateManyProductInputEnvelope
    set?: Enumerable<invoiceWhereUniqueInput>
    disconnect?: Enumerable<invoiceWhereUniqueInput>
    delete?: Enumerable<invoiceWhereUniqueInput>
    connect?: Enumerable<invoiceWhereUniqueInput>
    update?: Enumerable<invoiceUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<invoiceUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<invoiceScalarWhereInput>
  }

  export type exchangeRatesCreateNestedOneWithoutPricesInput = {
    create?: XOR<exchangeRatesCreateWithoutPricesInput, exchangeRatesUncheckedCreateWithoutPricesInput>
    connectOrCreate?: exchangeRatesCreateOrConnectWithoutPricesInput
    connect?: exchangeRatesWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutPriceInput = {
    create?: XOR<ProductCreateWithoutPriceInput, ProductUncheckedCreateWithoutPriceInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPriceInput
    connect?: ProductWhereUniqueInput
  }

  export type disposalsCreateNestedManyWithoutPricesInput = {
    create?: XOR<Enumerable<disposalsCreateWithoutPricesInput>, Enumerable<disposalsUncheckedCreateWithoutPricesInput>>
    connectOrCreate?: Enumerable<disposalsCreateOrConnectWithoutPricesInput>
    createMany?: disposalsCreateManyPricesInputEnvelope
    connect?: Enumerable<disposalsWhereUniqueInput>
  }

  export type disposalsUncheckedCreateNestedManyWithoutPricesInput = {
    create?: XOR<Enumerable<disposalsCreateWithoutPricesInput>, Enumerable<disposalsUncheckedCreateWithoutPricesInput>>
    connectOrCreate?: Enumerable<disposalsCreateOrConnectWithoutPricesInput>
    createMany?: disposalsCreateManyPricesInputEnvelope
    connect?: Enumerable<disposalsWhereUniqueInput>
  }

  export type exchangeRatesUpdateOneRequiredWithoutPricesNestedInput = {
    create?: XOR<exchangeRatesCreateWithoutPricesInput, exchangeRatesUncheckedCreateWithoutPricesInput>
    connectOrCreate?: exchangeRatesCreateOrConnectWithoutPricesInput
    upsert?: exchangeRatesUpsertWithoutPricesInput
    connect?: exchangeRatesWhereUniqueInput
    update?: XOR<exchangeRatesUpdateWithoutPricesInput, exchangeRatesUncheckedUpdateWithoutPricesInput>
  }

  export type ProductUpdateOneWithoutPriceNestedInput = {
    create?: XOR<ProductCreateWithoutPriceInput, ProductUncheckedCreateWithoutPriceInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPriceInput
    upsert?: ProductUpsertWithoutPriceInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutPriceInput, ProductUncheckedUpdateWithoutPriceInput>
  }

  export type disposalsUpdateManyWithoutPricesNestedInput = {
    create?: XOR<Enumerable<disposalsCreateWithoutPricesInput>, Enumerable<disposalsUncheckedCreateWithoutPricesInput>>
    connectOrCreate?: Enumerable<disposalsCreateOrConnectWithoutPricesInput>
    upsert?: Enumerable<disposalsUpsertWithWhereUniqueWithoutPricesInput>
    createMany?: disposalsCreateManyPricesInputEnvelope
    set?: Enumerable<disposalsWhereUniqueInput>
    disconnect?: Enumerable<disposalsWhereUniqueInput>
    delete?: Enumerable<disposalsWhereUniqueInput>
    connect?: Enumerable<disposalsWhereUniqueInput>
    update?: Enumerable<disposalsUpdateWithWhereUniqueWithoutPricesInput>
    updateMany?: Enumerable<disposalsUpdateManyWithWhereWithoutPricesInput>
    deleteMany?: Enumerable<disposalsScalarWhereInput>
  }

  export type disposalsUncheckedUpdateManyWithoutPricesNestedInput = {
    create?: XOR<Enumerable<disposalsCreateWithoutPricesInput>, Enumerable<disposalsUncheckedCreateWithoutPricesInput>>
    connectOrCreate?: Enumerable<disposalsCreateOrConnectWithoutPricesInput>
    upsert?: Enumerable<disposalsUpsertWithWhereUniqueWithoutPricesInput>
    createMany?: disposalsCreateManyPricesInputEnvelope
    set?: Enumerable<disposalsWhereUniqueInput>
    disconnect?: Enumerable<disposalsWhereUniqueInput>
    delete?: Enumerable<disposalsWhereUniqueInput>
    connect?: Enumerable<disposalsWhereUniqueInput>
    update?: Enumerable<disposalsUpdateWithWhereUniqueWithoutPricesInput>
    updateMany?: Enumerable<disposalsUpdateManyWithWhereWithoutPricesInput>
    deleteMany?: Enumerable<disposalsScalarWhereInput>
  }

  export type TaxCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<Enumerable<TaxCreateWithoutInvoiceInput>, Enumerable<TaxUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<TaxCreateOrConnectWithoutInvoiceInput>
    connect?: Enumerable<TaxWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<UserCreateWithoutInvoiceInput, UserUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoiceInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<CustomerCreateWithoutInvoiceInput, CustomerUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvoiceInput
    connect?: CustomerWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<ProductCreateWithoutInvoiceInput, ProductUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInvoiceInput
    connect?: ProductWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput
    connect?: TransactionWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<SupplierCreateWithoutInvoiceInput, SupplierUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutInvoiceInput
    connect?: SupplierWhereUniqueInput
  }

  export type TaxUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<Enumerable<TaxCreateWithoutInvoiceInput>, Enumerable<TaxUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<TaxCreateOrConnectWithoutInvoiceInput>
    connect?: Enumerable<TaxWhereUniqueInput>
  }

  export type TaxUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<Enumerable<TaxCreateWithoutInvoiceInput>, Enumerable<TaxUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<TaxCreateOrConnectWithoutInvoiceInput>
    upsert?: Enumerable<TaxUpsertWithWhereUniqueWithoutInvoiceInput>
    set?: Enumerable<TaxWhereUniqueInput>
    disconnect?: Enumerable<TaxWhereUniqueInput>
    delete?: Enumerable<TaxWhereUniqueInput>
    connect?: Enumerable<TaxWhereUniqueInput>
    update?: Enumerable<TaxUpdateWithWhereUniqueWithoutInvoiceInput>
    updateMany?: Enumerable<TaxUpdateManyWithWhereWithoutInvoiceInput>
    deleteMany?: Enumerable<TaxScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<UserCreateWithoutInvoiceInput, UserUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoiceInput
    upsert?: UserUpsertWithoutInvoiceInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutInvoiceInput, UserUncheckedUpdateWithoutInvoiceInput>
  }

  export type CustomerUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<CustomerCreateWithoutInvoiceInput, CustomerUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvoiceInput
    upsert?: CustomerUpsertWithoutInvoiceInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutInvoiceInput, CustomerUncheckedUpdateWithoutInvoiceInput>
  }

  export type ProductUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<ProductCreateWithoutInvoiceInput, ProductUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInvoiceInput
    upsert?: ProductUpsertWithoutInvoiceInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutInvoiceInput, ProductUncheckedUpdateWithoutInvoiceInput>
  }

  export type TransactionUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput
    upsert?: TransactionUpsertWithoutInvoiceInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<TransactionUpdateWithoutInvoiceInput, TransactionUncheckedUpdateWithoutInvoiceInput>
  }

  export type SupplierUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<SupplierCreateWithoutInvoiceInput, SupplierUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutInvoiceInput
    upsert?: SupplierUpsertWithoutInvoiceInput
    disconnect?: boolean
    delete?: boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<SupplierUpdateWithoutInvoiceInput, SupplierUncheckedUpdateWithoutInvoiceInput>
  }

  export type TaxUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<Enumerable<TaxCreateWithoutInvoiceInput>, Enumerable<TaxUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<TaxCreateOrConnectWithoutInvoiceInput>
    upsert?: Enumerable<TaxUpsertWithWhereUniqueWithoutInvoiceInput>
    set?: Enumerable<TaxWhereUniqueInput>
    disconnect?: Enumerable<TaxWhereUniqueInput>
    delete?: Enumerable<TaxWhereUniqueInput>
    connect?: Enumerable<TaxWhereUniqueInput>
    update?: Enumerable<TaxUpdateWithWhereUniqueWithoutInvoiceInput>
    updateMany?: Enumerable<TaxUpdateManyWithWhereWithoutInvoiceInput>
    deleteMany?: Enumerable<TaxScalarWhereInput>
  }

  export type AddressCreateNestedManyWithoutSuppliersInput = {
    create?: XOR<Enumerable<AddressCreateWithoutSuppliersInput>, Enumerable<AddressUncheckedCreateWithoutSuppliersInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutSuppliersInput>
    createMany?: AddressCreateManySuppliersInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type ProductCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<ProductCreateWithoutSupplierInput>, Enumerable<ProductUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutSupplierInput>
    createMany?: ProductCreateManySupplierInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type invoiceCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutSupplierInput>, Enumerable<invoiceUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutSupplierInput>
    createMany?: invoiceCreateManySupplierInputEnvelope
    connect?: Enumerable<invoiceWhereUniqueInput>
  }

  export type TransactionCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutSupplierInput>, Enumerable<TransactionUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutSupplierInput>
    createMany?: TransactionCreateManySupplierInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type JournalCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<JournalCreateWithoutSupplierInput>, Enumerable<JournalUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<JournalCreateOrConnectWithoutSupplierInput>
    createMany?: JournalCreateManySupplierInputEnvelope
    connect?: Enumerable<JournalWhereUniqueInput>
  }

  export type SalesJournalCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<SalesJournalCreateWithoutSupplierInput>, Enumerable<SalesJournalUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<SalesJournalCreateOrConnectWithoutSupplierInput>
    createMany?: SalesJournalCreateManySupplierInputEnvelope
    connect?: Enumerable<SalesJournalWhereUniqueInput>
  }

  export type CashDisbursementsJournalCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<CashDisbursementsJournalCreateWithoutSupplierInput>, Enumerable<CashDisbursementsJournalUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<CashDisbursementsJournalCreateOrConnectWithoutSupplierInput>
    createMany?: CashDisbursementsJournalCreateManySupplierInputEnvelope
    connect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
  }

  export type CashReceiptsJournalCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<CashReceiptsJournalCreateWithoutSupplierInput>, Enumerable<CashReceiptsJournalUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<CashReceiptsJournalCreateOrConnectWithoutSupplierInput>
    createMany?: CashReceiptsJournalCreateManySupplierInputEnvelope
    connect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
  }

  export type ReturnsOutwardsJournalCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<ReturnsOutwardsJournalCreateWithoutSupplierInput>, Enumerable<ReturnsOutwardsJournalUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<ReturnsOutwardsJournalCreateOrConnectWithoutSupplierInput>
    createMany?: ReturnsOutwardsJournalCreateManySupplierInputEnvelope
    connect?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
  }

  export type AddressUncheckedCreateNestedManyWithoutSuppliersInput = {
    create?: XOR<Enumerable<AddressCreateWithoutSuppliersInput>, Enumerable<AddressUncheckedCreateWithoutSuppliersInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutSuppliersInput>
    createMany?: AddressCreateManySuppliersInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<ProductCreateWithoutSupplierInput>, Enumerable<ProductUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutSupplierInput>
    createMany?: ProductCreateManySupplierInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type invoiceUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutSupplierInput>, Enumerable<invoiceUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutSupplierInput>
    createMany?: invoiceCreateManySupplierInputEnvelope
    connect?: Enumerable<invoiceWhereUniqueInput>
  }

  export type TransactionUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutSupplierInput>, Enumerable<TransactionUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutSupplierInput>
    createMany?: TransactionCreateManySupplierInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type JournalUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<JournalCreateWithoutSupplierInput>, Enumerable<JournalUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<JournalCreateOrConnectWithoutSupplierInput>
    createMany?: JournalCreateManySupplierInputEnvelope
    connect?: Enumerable<JournalWhereUniqueInput>
  }

  export type SalesJournalUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<SalesJournalCreateWithoutSupplierInput>, Enumerable<SalesJournalUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<SalesJournalCreateOrConnectWithoutSupplierInput>
    createMany?: SalesJournalCreateManySupplierInputEnvelope
    connect?: Enumerable<SalesJournalWhereUniqueInput>
  }

  export type CashDisbursementsJournalUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<CashDisbursementsJournalCreateWithoutSupplierInput>, Enumerable<CashDisbursementsJournalUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<CashDisbursementsJournalCreateOrConnectWithoutSupplierInput>
    createMany?: CashDisbursementsJournalCreateManySupplierInputEnvelope
    connect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
  }

  export type CashReceiptsJournalUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<CashReceiptsJournalCreateWithoutSupplierInput>, Enumerable<CashReceiptsJournalUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<CashReceiptsJournalCreateOrConnectWithoutSupplierInput>
    createMany?: CashReceiptsJournalCreateManySupplierInputEnvelope
    connect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
  }

  export type ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<ReturnsOutwardsJournalCreateWithoutSupplierInput>, Enumerable<ReturnsOutwardsJournalUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<ReturnsOutwardsJournalCreateOrConnectWithoutSupplierInput>
    createMany?: ReturnsOutwardsJournalCreateManySupplierInputEnvelope
    connect?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
  }

  export type AddressUpdateManyWithoutSuppliersNestedInput = {
    create?: XOR<Enumerable<AddressCreateWithoutSuppliersInput>, Enumerable<AddressUncheckedCreateWithoutSuppliersInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutSuppliersInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutSuppliersInput>
    createMany?: AddressCreateManySuppliersInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutSuppliersInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutSuppliersInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type ProductUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutSupplierInput>, Enumerable<ProductUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: ProductCreateManySupplierInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type invoiceUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutSupplierInput>, Enumerable<invoiceUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<invoiceUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: invoiceCreateManySupplierInputEnvelope
    set?: Enumerable<invoiceWhereUniqueInput>
    disconnect?: Enumerable<invoiceWhereUniqueInput>
    delete?: Enumerable<invoiceWhereUniqueInput>
    connect?: Enumerable<invoiceWhereUniqueInput>
    update?: Enumerable<invoiceUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<invoiceUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<invoiceScalarWhereInput>
  }

  export type TransactionUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutSupplierInput>, Enumerable<TransactionUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: TransactionCreateManySupplierInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type JournalUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<Enumerable<JournalCreateWithoutSupplierInput>, Enumerable<JournalUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<JournalCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<JournalUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: JournalCreateManySupplierInputEnvelope
    set?: Enumerable<JournalWhereUniqueInput>
    disconnect?: Enumerable<JournalWhereUniqueInput>
    delete?: Enumerable<JournalWhereUniqueInput>
    connect?: Enumerable<JournalWhereUniqueInput>
    update?: Enumerable<JournalUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<JournalUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<JournalScalarWhereInput>
  }

  export type SalesJournalUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<Enumerable<SalesJournalCreateWithoutSupplierInput>, Enumerable<SalesJournalUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<SalesJournalCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<SalesJournalUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: SalesJournalCreateManySupplierInputEnvelope
    set?: Enumerable<SalesJournalWhereUniqueInput>
    disconnect?: Enumerable<SalesJournalWhereUniqueInput>
    delete?: Enumerable<SalesJournalWhereUniqueInput>
    connect?: Enumerable<SalesJournalWhereUniqueInput>
    update?: Enumerable<SalesJournalUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<SalesJournalUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<SalesJournalScalarWhereInput>
  }

  export type CashDisbursementsJournalUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<Enumerable<CashDisbursementsJournalCreateWithoutSupplierInput>, Enumerable<CashDisbursementsJournalUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<CashDisbursementsJournalCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<CashDisbursementsJournalUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: CashDisbursementsJournalCreateManySupplierInputEnvelope
    set?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    disconnect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    delete?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    connect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    update?: Enumerable<CashDisbursementsJournalUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<CashDisbursementsJournalUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<CashDisbursementsJournalScalarWhereInput>
  }

  export type CashReceiptsJournalUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<Enumerable<CashReceiptsJournalCreateWithoutSupplierInput>, Enumerable<CashReceiptsJournalUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<CashReceiptsJournalCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<CashReceiptsJournalUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: CashReceiptsJournalCreateManySupplierInputEnvelope
    set?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    disconnect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    delete?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    connect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    update?: Enumerable<CashReceiptsJournalUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<CashReceiptsJournalUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<CashReceiptsJournalScalarWhereInput>
  }

  export type ReturnsOutwardsJournalUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<Enumerable<ReturnsOutwardsJournalCreateWithoutSupplierInput>, Enumerable<ReturnsOutwardsJournalUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<ReturnsOutwardsJournalCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<ReturnsOutwardsJournalUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: ReturnsOutwardsJournalCreateManySupplierInputEnvelope
    set?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    disconnect?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    delete?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    connect?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    update?: Enumerable<ReturnsOutwardsJournalUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<ReturnsOutwardsJournalUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<ReturnsOutwardsJournalScalarWhereInput>
  }

  export type AddressUncheckedUpdateManyWithoutSuppliersNestedInput = {
    create?: XOR<Enumerable<AddressCreateWithoutSuppliersInput>, Enumerable<AddressUncheckedCreateWithoutSuppliersInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutSuppliersInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutSuppliersInput>
    createMany?: AddressCreateManySuppliersInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutSuppliersInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutSuppliersInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutSupplierInput>, Enumerable<ProductUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: ProductCreateManySupplierInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type invoiceUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutSupplierInput>, Enumerable<invoiceUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<invoiceUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: invoiceCreateManySupplierInputEnvelope
    set?: Enumerable<invoiceWhereUniqueInput>
    disconnect?: Enumerable<invoiceWhereUniqueInput>
    delete?: Enumerable<invoiceWhereUniqueInput>
    connect?: Enumerable<invoiceWhereUniqueInput>
    update?: Enumerable<invoiceUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<invoiceUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<invoiceScalarWhereInput>
  }

  export type TransactionUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutSupplierInput>, Enumerable<TransactionUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: TransactionCreateManySupplierInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type JournalUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<Enumerable<JournalCreateWithoutSupplierInput>, Enumerable<JournalUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<JournalCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<JournalUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: JournalCreateManySupplierInputEnvelope
    set?: Enumerable<JournalWhereUniqueInput>
    disconnect?: Enumerable<JournalWhereUniqueInput>
    delete?: Enumerable<JournalWhereUniqueInput>
    connect?: Enumerable<JournalWhereUniqueInput>
    update?: Enumerable<JournalUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<JournalUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<JournalScalarWhereInput>
  }

  export type SalesJournalUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<Enumerable<SalesJournalCreateWithoutSupplierInput>, Enumerable<SalesJournalUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<SalesJournalCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<SalesJournalUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: SalesJournalCreateManySupplierInputEnvelope
    set?: Enumerable<SalesJournalWhereUniqueInput>
    disconnect?: Enumerable<SalesJournalWhereUniqueInput>
    delete?: Enumerable<SalesJournalWhereUniqueInput>
    connect?: Enumerable<SalesJournalWhereUniqueInput>
    update?: Enumerable<SalesJournalUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<SalesJournalUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<SalesJournalScalarWhereInput>
  }

  export type CashDisbursementsJournalUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<Enumerable<CashDisbursementsJournalCreateWithoutSupplierInput>, Enumerable<CashDisbursementsJournalUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<CashDisbursementsJournalCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<CashDisbursementsJournalUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: CashDisbursementsJournalCreateManySupplierInputEnvelope
    set?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    disconnect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    delete?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    connect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    update?: Enumerable<CashDisbursementsJournalUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<CashDisbursementsJournalUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<CashDisbursementsJournalScalarWhereInput>
  }

  export type CashReceiptsJournalUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<Enumerable<CashReceiptsJournalCreateWithoutSupplierInput>, Enumerable<CashReceiptsJournalUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<CashReceiptsJournalCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<CashReceiptsJournalUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: CashReceiptsJournalCreateManySupplierInputEnvelope
    set?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    disconnect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    delete?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    connect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    update?: Enumerable<CashReceiptsJournalUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<CashReceiptsJournalUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<CashReceiptsJournalScalarWhereInput>
  }

  export type ReturnsOutwardsJournalUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<Enumerable<ReturnsOutwardsJournalCreateWithoutSupplierInput>, Enumerable<ReturnsOutwardsJournalUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<ReturnsOutwardsJournalCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<ReturnsOutwardsJournalUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: ReturnsOutwardsJournalCreateManySupplierInputEnvelope
    set?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    disconnect?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    delete?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    connect?: Enumerable<ReturnsOutwardsJournalWhereUniqueInput>
    update?: Enumerable<ReturnsOutwardsJournalUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<ReturnsOutwardsJournalUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<ReturnsOutwardsJournalScalarWhereInput>
  }

  export type AddressCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<AddressCreateWithoutCustomersInput>, Enumerable<AddressUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutCustomersInput>
    createMany?: AddressCreateManyCustomersInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type invoiceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutCustomerInput>, Enumerable<invoiceUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutCustomerInput>
    createMany?: invoiceCreateManyCustomerInputEnvelope
    connect?: Enumerable<invoiceWhereUniqueInput>
  }

  export type TransactionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutCustomerInput>, Enumerable<TransactionUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutCustomerInput>
    createMany?: TransactionCreateManyCustomerInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type JournalCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<JournalCreateWithoutCustomerInput>, Enumerable<JournalUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<JournalCreateOrConnectWithoutCustomerInput>
    createMany?: JournalCreateManyCustomerInputEnvelope
    connect?: Enumerable<JournalWhereUniqueInput>
  }

  export type PurchasesJournalCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<PurchasesJournalCreateWithoutCustomerInput>, Enumerable<PurchasesJournalUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<PurchasesJournalCreateOrConnectWithoutCustomerInput>
    createMany?: PurchasesJournalCreateManyCustomerInputEnvelope
    connect?: Enumerable<PurchasesJournalWhereUniqueInput>
  }

  export type CashDisbursementsJournalCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CashDisbursementsJournalCreateWithoutCustomerInput>, Enumerable<CashDisbursementsJournalUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CashDisbursementsJournalCreateOrConnectWithoutCustomerInput>
    createMany?: CashDisbursementsJournalCreateManyCustomerInputEnvelope
    connect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
  }

  export type CashReceiptsJournalCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CashReceiptsJournalCreateWithoutCustomerInput>, Enumerable<CashReceiptsJournalUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CashReceiptsJournalCreateOrConnectWithoutCustomerInput>
    createMany?: CashReceiptsJournalCreateManyCustomerInputEnvelope
    connect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
  }

  export type ReturnsInwardsJournalCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<ReturnsInwardsJournalCreateWithoutCustomerInput>, Enumerable<ReturnsInwardsJournalUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<ReturnsInwardsJournalCreateOrConnectWithoutCustomerInput>
    createMany?: ReturnsInwardsJournalCreateManyCustomerInputEnvelope
    connect?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
  }

  export type AddressUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<AddressCreateWithoutCustomersInput>, Enumerable<AddressUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutCustomersInput>
    createMany?: AddressCreateManyCustomersInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type invoiceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutCustomerInput>, Enumerable<invoiceUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutCustomerInput>
    createMany?: invoiceCreateManyCustomerInputEnvelope
    connect?: Enumerable<invoiceWhereUniqueInput>
  }

  export type TransactionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutCustomerInput>, Enumerable<TransactionUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutCustomerInput>
    createMany?: TransactionCreateManyCustomerInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type JournalUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<JournalCreateWithoutCustomerInput>, Enumerable<JournalUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<JournalCreateOrConnectWithoutCustomerInput>
    createMany?: JournalCreateManyCustomerInputEnvelope
    connect?: Enumerable<JournalWhereUniqueInput>
  }

  export type PurchasesJournalUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<PurchasesJournalCreateWithoutCustomerInput>, Enumerable<PurchasesJournalUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<PurchasesJournalCreateOrConnectWithoutCustomerInput>
    createMany?: PurchasesJournalCreateManyCustomerInputEnvelope
    connect?: Enumerable<PurchasesJournalWhereUniqueInput>
  }

  export type CashDisbursementsJournalUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CashDisbursementsJournalCreateWithoutCustomerInput>, Enumerable<CashDisbursementsJournalUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CashDisbursementsJournalCreateOrConnectWithoutCustomerInput>
    createMany?: CashDisbursementsJournalCreateManyCustomerInputEnvelope
    connect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
  }

  export type CashReceiptsJournalUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CashReceiptsJournalCreateWithoutCustomerInput>, Enumerable<CashReceiptsJournalUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CashReceiptsJournalCreateOrConnectWithoutCustomerInput>
    createMany?: CashReceiptsJournalCreateManyCustomerInputEnvelope
    connect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
  }

  export type ReturnsInwardsJournalUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<ReturnsInwardsJournalCreateWithoutCustomerInput>, Enumerable<ReturnsInwardsJournalUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<ReturnsInwardsJournalCreateOrConnectWithoutCustomerInput>
    createMany?: ReturnsInwardsJournalCreateManyCustomerInputEnvelope
    connect?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
  }

  export type AddressUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Enumerable<AddressCreateWithoutCustomersInput>, Enumerable<AddressUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutCustomersInput>
    createMany?: AddressCreateManyCustomersInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type invoiceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutCustomerInput>, Enumerable<invoiceUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<invoiceUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: invoiceCreateManyCustomerInputEnvelope
    set?: Enumerable<invoiceWhereUniqueInput>
    disconnect?: Enumerable<invoiceWhereUniqueInput>
    delete?: Enumerable<invoiceWhereUniqueInput>
    connect?: Enumerable<invoiceWhereUniqueInput>
    update?: Enumerable<invoiceUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<invoiceUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<invoiceScalarWhereInput>
  }

  export type TransactionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutCustomerInput>, Enumerable<TransactionUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: TransactionCreateManyCustomerInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type JournalUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<JournalCreateWithoutCustomerInput>, Enumerable<JournalUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<JournalCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<JournalUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: JournalCreateManyCustomerInputEnvelope
    set?: Enumerable<JournalWhereUniqueInput>
    disconnect?: Enumerable<JournalWhereUniqueInput>
    delete?: Enumerable<JournalWhereUniqueInput>
    connect?: Enumerable<JournalWhereUniqueInput>
    update?: Enumerable<JournalUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<JournalUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<JournalScalarWhereInput>
  }

  export type PurchasesJournalUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<PurchasesJournalCreateWithoutCustomerInput>, Enumerable<PurchasesJournalUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<PurchasesJournalCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<PurchasesJournalUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: PurchasesJournalCreateManyCustomerInputEnvelope
    set?: Enumerable<PurchasesJournalWhereUniqueInput>
    disconnect?: Enumerable<PurchasesJournalWhereUniqueInput>
    delete?: Enumerable<PurchasesJournalWhereUniqueInput>
    connect?: Enumerable<PurchasesJournalWhereUniqueInput>
    update?: Enumerable<PurchasesJournalUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<PurchasesJournalUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<PurchasesJournalScalarWhereInput>
  }

  export type CashDisbursementsJournalUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<CashDisbursementsJournalCreateWithoutCustomerInput>, Enumerable<CashDisbursementsJournalUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CashDisbursementsJournalCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CashDisbursementsJournalUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CashDisbursementsJournalCreateManyCustomerInputEnvelope
    set?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    disconnect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    delete?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    connect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    update?: Enumerable<CashDisbursementsJournalUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CashDisbursementsJournalUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CashDisbursementsJournalScalarWhereInput>
  }

  export type CashReceiptsJournalUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<CashReceiptsJournalCreateWithoutCustomerInput>, Enumerable<CashReceiptsJournalUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CashReceiptsJournalCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CashReceiptsJournalUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CashReceiptsJournalCreateManyCustomerInputEnvelope
    set?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    disconnect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    delete?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    connect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    update?: Enumerable<CashReceiptsJournalUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CashReceiptsJournalUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CashReceiptsJournalScalarWhereInput>
  }

  export type ReturnsInwardsJournalUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<ReturnsInwardsJournalCreateWithoutCustomerInput>, Enumerable<ReturnsInwardsJournalUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<ReturnsInwardsJournalCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<ReturnsInwardsJournalUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: ReturnsInwardsJournalCreateManyCustomerInputEnvelope
    set?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    disconnect?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    delete?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    connect?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    update?: Enumerable<ReturnsInwardsJournalUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<ReturnsInwardsJournalUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<ReturnsInwardsJournalScalarWhereInput>
  }

  export type AddressUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Enumerable<AddressCreateWithoutCustomersInput>, Enumerable<AddressUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutCustomersInput>
    createMany?: AddressCreateManyCustomersInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type invoiceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<invoiceCreateWithoutCustomerInput>, Enumerable<invoiceUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<invoiceCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<invoiceUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: invoiceCreateManyCustomerInputEnvelope
    set?: Enumerable<invoiceWhereUniqueInput>
    disconnect?: Enumerable<invoiceWhereUniqueInput>
    delete?: Enumerable<invoiceWhereUniqueInput>
    connect?: Enumerable<invoiceWhereUniqueInput>
    update?: Enumerable<invoiceUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<invoiceUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<invoiceScalarWhereInput>
  }

  export type TransactionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutCustomerInput>, Enumerable<TransactionUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: TransactionCreateManyCustomerInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type JournalUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<JournalCreateWithoutCustomerInput>, Enumerable<JournalUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<JournalCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<JournalUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: JournalCreateManyCustomerInputEnvelope
    set?: Enumerable<JournalWhereUniqueInput>
    disconnect?: Enumerable<JournalWhereUniqueInput>
    delete?: Enumerable<JournalWhereUniqueInput>
    connect?: Enumerable<JournalWhereUniqueInput>
    update?: Enumerable<JournalUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<JournalUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<JournalScalarWhereInput>
  }

  export type PurchasesJournalUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<PurchasesJournalCreateWithoutCustomerInput>, Enumerable<PurchasesJournalUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<PurchasesJournalCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<PurchasesJournalUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: PurchasesJournalCreateManyCustomerInputEnvelope
    set?: Enumerable<PurchasesJournalWhereUniqueInput>
    disconnect?: Enumerable<PurchasesJournalWhereUniqueInput>
    delete?: Enumerable<PurchasesJournalWhereUniqueInput>
    connect?: Enumerable<PurchasesJournalWhereUniqueInput>
    update?: Enumerable<PurchasesJournalUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<PurchasesJournalUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<PurchasesJournalScalarWhereInput>
  }

  export type CashDisbursementsJournalUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<CashDisbursementsJournalCreateWithoutCustomerInput>, Enumerable<CashDisbursementsJournalUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CashDisbursementsJournalCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CashDisbursementsJournalUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CashDisbursementsJournalCreateManyCustomerInputEnvelope
    set?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    disconnect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    delete?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    connect?: Enumerable<CashDisbursementsJournalWhereUniqueInput>
    update?: Enumerable<CashDisbursementsJournalUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CashDisbursementsJournalUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CashDisbursementsJournalScalarWhereInput>
  }

  export type CashReceiptsJournalUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<CashReceiptsJournalCreateWithoutCustomerInput>, Enumerable<CashReceiptsJournalUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CashReceiptsJournalCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CashReceiptsJournalUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CashReceiptsJournalCreateManyCustomerInputEnvelope
    set?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    disconnect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    delete?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    connect?: Enumerable<CashReceiptsJournalWhereUniqueInput>
    update?: Enumerable<CashReceiptsJournalUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CashReceiptsJournalUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CashReceiptsJournalScalarWhereInput>
  }

  export type ReturnsInwardsJournalUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<ReturnsInwardsJournalCreateWithoutCustomerInput>, Enumerable<ReturnsInwardsJournalUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<ReturnsInwardsJournalCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<ReturnsInwardsJournalUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: ReturnsInwardsJournalCreateManyCustomerInputEnvelope
    set?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    disconnect?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    delete?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    connect?: Enumerable<ReturnsInwardsJournalWhereUniqueInput>
    update?: Enumerable<ReturnsInwardsJournalUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<ReturnsInwardsJournalUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<ReturnsInwardsJournalScalarWhereInput>
  }

  export type CustomerCreateNestedOneWithoutAddressInput = {
    create?: XOR<CustomerCreateWithoutAddressInput, CustomerUncheckedCreateWithoutAddressInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAddressInput
    connect?: CustomerWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutAddressInput = {
    create?: XOR<SupplierCreateWithoutAddressInput, SupplierUncheckedCreateWithoutAddressInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutAddressInput
    connect?: SupplierWhereUniqueInput
  }

  export type CustomerUpdateOneWithoutAddressNestedInput = {
    create?: XOR<CustomerCreateWithoutAddressInput, CustomerUncheckedCreateWithoutAddressInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAddressInput
    upsert?: CustomerUpsertWithoutAddressInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutAddressInput, CustomerUncheckedUpdateWithoutAddressInput>
  }

  export type SupplierUpdateOneWithoutAddressNestedInput = {
    create?: XOR<SupplierCreateWithoutAddressInput, SupplierUncheckedCreateWithoutAddressInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutAddressInput
    upsert?: SupplierUpsertWithoutAddressInput
    disconnect?: boolean
    delete?: boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<SupplierUpdateWithoutAddressInput, SupplierUncheckedUpdateWithoutAddressInput>
  }

  export type currencyCreateNestedOneWithoutBaseCurrencyInput = {
    create?: XOR<currencyCreateWithoutBaseCurrencyInput, currencyUncheckedCreateWithoutBaseCurrencyInput>
    connectOrCreate?: currencyCreateOrConnectWithoutBaseCurrencyInput
    connect?: currencyWhereUniqueInput
  }

  export type exchangeRatesCreateNestedManyWithoutBaseCurrencyInput = {
    create?: XOR<Enumerable<exchangeRatesCreateWithoutBaseCurrencyInput>, Enumerable<exchangeRatesUncheckedCreateWithoutBaseCurrencyInput>>
    connectOrCreate?: Enumerable<exchangeRatesCreateOrConnectWithoutBaseCurrencyInput>
    createMany?: exchangeRatesCreateManyBaseCurrencyInputEnvelope
    connect?: Enumerable<exchangeRatesWhereUniqueInput>
  }

  export type exchangeRatesUncheckedCreateNestedManyWithoutBaseCurrencyInput = {
    create?: XOR<Enumerable<exchangeRatesCreateWithoutBaseCurrencyInput>, Enumerable<exchangeRatesUncheckedCreateWithoutBaseCurrencyInput>>
    connectOrCreate?: Enumerable<exchangeRatesCreateOrConnectWithoutBaseCurrencyInput>
    createMany?: exchangeRatesCreateManyBaseCurrencyInputEnvelope
    connect?: Enumerable<exchangeRatesWhereUniqueInput>
  }

  export type currencyUpdateOneRequiredWithoutBaseCurrencyNestedInput = {
    create?: XOR<currencyCreateWithoutBaseCurrencyInput, currencyUncheckedCreateWithoutBaseCurrencyInput>
    connectOrCreate?: currencyCreateOrConnectWithoutBaseCurrencyInput
    upsert?: currencyUpsertWithoutBaseCurrencyInput
    connect?: currencyWhereUniqueInput
    update?: XOR<currencyUpdateWithoutBaseCurrencyInput, currencyUncheckedUpdateWithoutBaseCurrencyInput>
  }

  export type exchangeRatesUpdateManyWithoutBaseCurrencyNestedInput = {
    create?: XOR<Enumerable<exchangeRatesCreateWithoutBaseCurrencyInput>, Enumerable<exchangeRatesUncheckedCreateWithoutBaseCurrencyInput>>
    connectOrCreate?: Enumerable<exchangeRatesCreateOrConnectWithoutBaseCurrencyInput>
    upsert?: Enumerable<exchangeRatesUpsertWithWhereUniqueWithoutBaseCurrencyInput>
    createMany?: exchangeRatesCreateManyBaseCurrencyInputEnvelope
    set?: Enumerable<exchangeRatesWhereUniqueInput>
    disconnect?: Enumerable<exchangeRatesWhereUniqueInput>
    delete?: Enumerable<exchangeRatesWhereUniqueInput>
    connect?: Enumerable<exchangeRatesWhereUniqueInput>
    update?: Enumerable<exchangeRatesUpdateWithWhereUniqueWithoutBaseCurrencyInput>
    updateMany?: Enumerable<exchangeRatesUpdateManyWithWhereWithoutBaseCurrencyInput>
    deleteMany?: Enumerable<exchangeRatesScalarWhereInput>
  }

  export type exchangeRatesUncheckedUpdateManyWithoutBaseCurrencyNestedInput = {
    create?: XOR<Enumerable<exchangeRatesCreateWithoutBaseCurrencyInput>, Enumerable<exchangeRatesUncheckedCreateWithoutBaseCurrencyInput>>
    connectOrCreate?: Enumerable<exchangeRatesCreateOrConnectWithoutBaseCurrencyInput>
    upsert?: Enumerable<exchangeRatesUpsertWithWhereUniqueWithoutBaseCurrencyInput>
    createMany?: exchangeRatesCreateManyBaseCurrencyInputEnvelope
    set?: Enumerable<exchangeRatesWhereUniqueInput>
    disconnect?: Enumerable<exchangeRatesWhereUniqueInput>
    delete?: Enumerable<exchangeRatesWhereUniqueInput>
    connect?: Enumerable<exchangeRatesWhereUniqueInput>
    update?: Enumerable<exchangeRatesUpdateWithWhereUniqueWithoutBaseCurrencyInput>
    updateMany?: Enumerable<exchangeRatesUpdateManyWithWhereWithoutBaseCurrencyInput>
    deleteMany?: Enumerable<exchangeRatesScalarWhereInput>
  }

  export type baseCurrencyCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<Enumerable<baseCurrencyCreateWithoutCurrencyInput>, Enumerable<baseCurrencyUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<baseCurrencyCreateOrConnectWithoutCurrencyInput>
    createMany?: baseCurrencyCreateManyCurrencyInputEnvelope
    connect?: Enumerable<baseCurrencyWhereUniqueInput>
  }

  export type exchangeRatesCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<Enumerable<exchangeRatesCreateWithoutCurrencyInput>, Enumerable<exchangeRatesUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<exchangeRatesCreateOrConnectWithoutCurrencyInput>
    createMany?: exchangeRatesCreateManyCurrencyInputEnvelope
    connect?: Enumerable<exchangeRatesWhereUniqueInput>
  }

  export type PaymentCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutCurrencyInput>, Enumerable<PaymentUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutCurrencyInput>
    createMany?: PaymentCreateManyCurrencyInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type TaxCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<Enumerable<TaxCreateWithoutCurrencyInput>, Enumerable<TaxUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<TaxCreateOrConnectWithoutCurrencyInput>
    connect?: Enumerable<TaxWhereUniqueInput>
  }

  export type baseCurrencyUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<Enumerable<baseCurrencyCreateWithoutCurrencyInput>, Enumerable<baseCurrencyUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<baseCurrencyCreateOrConnectWithoutCurrencyInput>
    createMany?: baseCurrencyCreateManyCurrencyInputEnvelope
    connect?: Enumerable<baseCurrencyWhereUniqueInput>
  }

  export type exchangeRatesUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<Enumerable<exchangeRatesCreateWithoutCurrencyInput>, Enumerable<exchangeRatesUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<exchangeRatesCreateOrConnectWithoutCurrencyInput>
    createMany?: exchangeRatesCreateManyCurrencyInputEnvelope
    connect?: Enumerable<exchangeRatesWhereUniqueInput>
  }

  export type PaymentUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutCurrencyInput>, Enumerable<PaymentUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutCurrencyInput>
    createMany?: PaymentCreateManyCurrencyInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type TaxUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<Enumerable<TaxCreateWithoutCurrencyInput>, Enumerable<TaxUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<TaxCreateOrConnectWithoutCurrencyInput>
    connect?: Enumerable<TaxWhereUniqueInput>
  }

  export type baseCurrencyUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<Enumerable<baseCurrencyCreateWithoutCurrencyInput>, Enumerable<baseCurrencyUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<baseCurrencyCreateOrConnectWithoutCurrencyInput>
    upsert?: Enumerable<baseCurrencyUpsertWithWhereUniqueWithoutCurrencyInput>
    createMany?: baseCurrencyCreateManyCurrencyInputEnvelope
    set?: Enumerable<baseCurrencyWhereUniqueInput>
    disconnect?: Enumerable<baseCurrencyWhereUniqueInput>
    delete?: Enumerable<baseCurrencyWhereUniqueInput>
    connect?: Enumerable<baseCurrencyWhereUniqueInput>
    update?: Enumerable<baseCurrencyUpdateWithWhereUniqueWithoutCurrencyInput>
    updateMany?: Enumerable<baseCurrencyUpdateManyWithWhereWithoutCurrencyInput>
    deleteMany?: Enumerable<baseCurrencyScalarWhereInput>
  }

  export type exchangeRatesUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<Enumerable<exchangeRatesCreateWithoutCurrencyInput>, Enumerable<exchangeRatesUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<exchangeRatesCreateOrConnectWithoutCurrencyInput>
    upsert?: Enumerable<exchangeRatesUpsertWithWhereUniqueWithoutCurrencyInput>
    createMany?: exchangeRatesCreateManyCurrencyInputEnvelope
    set?: Enumerable<exchangeRatesWhereUniqueInput>
    disconnect?: Enumerable<exchangeRatesWhereUniqueInput>
    delete?: Enumerable<exchangeRatesWhereUniqueInput>
    connect?: Enumerable<exchangeRatesWhereUniqueInput>
    update?: Enumerable<exchangeRatesUpdateWithWhereUniqueWithoutCurrencyInput>
    updateMany?: Enumerable<exchangeRatesUpdateManyWithWhereWithoutCurrencyInput>
    deleteMany?: Enumerable<exchangeRatesScalarWhereInput>
  }

  export type PaymentUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutCurrencyInput>, Enumerable<PaymentUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutCurrencyInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutCurrencyInput>
    createMany?: PaymentCreateManyCurrencyInputEnvelope
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    connect?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutCurrencyInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutCurrencyInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type TaxUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<Enumerable<TaxCreateWithoutCurrencyInput>, Enumerable<TaxUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<TaxCreateOrConnectWithoutCurrencyInput>
    upsert?: Enumerable<TaxUpsertWithWhereUniqueWithoutCurrencyInput>
    set?: Enumerable<TaxWhereUniqueInput>
    disconnect?: Enumerable<TaxWhereUniqueInput>
    delete?: Enumerable<TaxWhereUniqueInput>
    connect?: Enumerable<TaxWhereUniqueInput>
    update?: Enumerable<TaxUpdateWithWhereUniqueWithoutCurrencyInput>
    updateMany?: Enumerable<TaxUpdateManyWithWhereWithoutCurrencyInput>
    deleteMany?: Enumerable<TaxScalarWhereInput>
  }

  export type baseCurrencyUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<Enumerable<baseCurrencyCreateWithoutCurrencyInput>, Enumerable<baseCurrencyUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<baseCurrencyCreateOrConnectWithoutCurrencyInput>
    upsert?: Enumerable<baseCurrencyUpsertWithWhereUniqueWithoutCurrencyInput>
    createMany?: baseCurrencyCreateManyCurrencyInputEnvelope
    set?: Enumerable<baseCurrencyWhereUniqueInput>
    disconnect?: Enumerable<baseCurrencyWhereUniqueInput>
    delete?: Enumerable<baseCurrencyWhereUniqueInput>
    connect?: Enumerable<baseCurrencyWhereUniqueInput>
    update?: Enumerable<baseCurrencyUpdateWithWhereUniqueWithoutCurrencyInput>
    updateMany?: Enumerable<baseCurrencyUpdateManyWithWhereWithoutCurrencyInput>
    deleteMany?: Enumerable<baseCurrencyScalarWhereInput>
  }

  export type exchangeRatesUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<Enumerable<exchangeRatesCreateWithoutCurrencyInput>, Enumerable<exchangeRatesUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<exchangeRatesCreateOrConnectWithoutCurrencyInput>
    upsert?: Enumerable<exchangeRatesUpsertWithWhereUniqueWithoutCurrencyInput>
    createMany?: exchangeRatesCreateManyCurrencyInputEnvelope
    set?: Enumerable<exchangeRatesWhereUniqueInput>
    disconnect?: Enumerable<exchangeRatesWhereUniqueInput>
    delete?: Enumerable<exchangeRatesWhereUniqueInput>
    connect?: Enumerable<exchangeRatesWhereUniqueInput>
    update?: Enumerable<exchangeRatesUpdateWithWhereUniqueWithoutCurrencyInput>
    updateMany?: Enumerable<exchangeRatesUpdateManyWithWhereWithoutCurrencyInput>
    deleteMany?: Enumerable<exchangeRatesScalarWhereInput>
  }

  export type PaymentUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutCurrencyInput>, Enumerable<PaymentUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutCurrencyInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutCurrencyInput>
    createMany?: PaymentCreateManyCurrencyInputEnvelope
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    connect?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutCurrencyInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutCurrencyInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type TaxUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<Enumerable<TaxCreateWithoutCurrencyInput>, Enumerable<TaxUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<TaxCreateOrConnectWithoutCurrencyInput>
    upsert?: Enumerable<TaxUpsertWithWhereUniqueWithoutCurrencyInput>
    set?: Enumerable<TaxWhereUniqueInput>
    disconnect?: Enumerable<TaxWhereUniqueInput>
    delete?: Enumerable<TaxWhereUniqueInput>
    connect?: Enumerable<TaxWhereUniqueInput>
    update?: Enumerable<TaxUpdateWithWhereUniqueWithoutCurrencyInput>
    updateMany?: Enumerable<TaxUpdateManyWithWhereWithoutCurrencyInput>
    deleteMany?: Enumerable<TaxScalarWhereInput>
  }

  export type PricesCreateNestedOneWithoutDisposalsInput = {
    create?: XOR<PricesCreateWithoutDisposalsInput, PricesUncheckedCreateWithoutDisposalsInput>
    connectOrCreate?: PricesCreateOrConnectWithoutDisposalsInput
    connect?: PricesWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutDisposalsInput = {
    create?: XOR<ProductCreateWithoutDisposalsInput, ProductUncheckedCreateWithoutDisposalsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutDisposalsInput
    connect?: ProductWhereUniqueInput
  }

  export type PricesUpdateOneRequiredWithoutDisposalsNestedInput = {
    create?: XOR<PricesCreateWithoutDisposalsInput, PricesUncheckedCreateWithoutDisposalsInput>
    connectOrCreate?: PricesCreateOrConnectWithoutDisposalsInput
    upsert?: PricesUpsertWithoutDisposalsInput
    connect?: PricesWhereUniqueInput
    update?: XOR<PricesUpdateWithoutDisposalsInput, PricesUncheckedUpdateWithoutDisposalsInput>
  }

  export type ProductUpdateOneRequiredWithoutDisposalsNestedInput = {
    create?: XOR<ProductCreateWithoutDisposalsInput, ProductUncheckedCreateWithoutDisposalsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutDisposalsInput
    upsert?: ProductUpsertWithoutDisposalsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutDisposalsInput, ProductUncheckedUpdateWithoutDisposalsInput>
  }

  export type baseCurrencyCreateNestedOneWithoutExchangeRatesInput = {
    create?: XOR<baseCurrencyCreateWithoutExchangeRatesInput, baseCurrencyUncheckedCreateWithoutExchangeRatesInput>
    connectOrCreate?: baseCurrencyCreateOrConnectWithoutExchangeRatesInput
    connect?: baseCurrencyWhereUniqueInput
  }

  export type currencyCreateNestedOneWithoutExchangeRatesInput = {
    create?: XOR<currencyCreateWithoutExchangeRatesInput, currencyUncheckedCreateWithoutExchangeRatesInput>
    connectOrCreate?: currencyCreateOrConnectWithoutExchangeRatesInput
    connect?: currencyWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutExchangeRatesInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutExchangeRatesInput>, Enumerable<PaymentUncheckedCreateWithoutExchangeRatesInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutExchangeRatesInput>
    createMany?: PaymentCreateManyExchangeRatesInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type PricesCreateNestedManyWithoutExchangeRatesInput = {
    create?: XOR<Enumerable<PricesCreateWithoutExchangeRatesInput>, Enumerable<PricesUncheckedCreateWithoutExchangeRatesInput>>
    connectOrCreate?: Enumerable<PricesCreateOrConnectWithoutExchangeRatesInput>
    createMany?: PricesCreateManyExchangeRatesInputEnvelope
    connect?: Enumerable<PricesWhereUniqueInput>
  }

  export type PaymentUncheckedCreateNestedManyWithoutExchangeRatesInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutExchangeRatesInput>, Enumerable<PaymentUncheckedCreateWithoutExchangeRatesInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutExchangeRatesInput>
    createMany?: PaymentCreateManyExchangeRatesInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type PricesUncheckedCreateNestedManyWithoutExchangeRatesInput = {
    create?: XOR<Enumerable<PricesCreateWithoutExchangeRatesInput>, Enumerable<PricesUncheckedCreateWithoutExchangeRatesInput>>
    connectOrCreate?: Enumerable<PricesCreateOrConnectWithoutExchangeRatesInput>
    createMany?: PricesCreateManyExchangeRatesInputEnvelope
    connect?: Enumerable<PricesWhereUniqueInput>
  }

  export type baseCurrencyUpdateOneRequiredWithoutExchangeRatesNestedInput = {
    create?: XOR<baseCurrencyCreateWithoutExchangeRatesInput, baseCurrencyUncheckedCreateWithoutExchangeRatesInput>
    connectOrCreate?: baseCurrencyCreateOrConnectWithoutExchangeRatesInput
    upsert?: baseCurrencyUpsertWithoutExchangeRatesInput
    connect?: baseCurrencyWhereUniqueInput
    update?: XOR<baseCurrencyUpdateWithoutExchangeRatesInput, baseCurrencyUncheckedUpdateWithoutExchangeRatesInput>
  }

  export type currencyUpdateOneRequiredWithoutExchangeRatesNestedInput = {
    create?: XOR<currencyCreateWithoutExchangeRatesInput, currencyUncheckedCreateWithoutExchangeRatesInput>
    connectOrCreate?: currencyCreateOrConnectWithoutExchangeRatesInput
    upsert?: currencyUpsertWithoutExchangeRatesInput
    connect?: currencyWhereUniqueInput
    update?: XOR<currencyUpdateWithoutExchangeRatesInput, currencyUncheckedUpdateWithoutExchangeRatesInput>
  }

  export type PaymentUpdateManyWithoutExchangeRatesNestedInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutExchangeRatesInput>, Enumerable<PaymentUncheckedCreateWithoutExchangeRatesInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutExchangeRatesInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutExchangeRatesInput>
    createMany?: PaymentCreateManyExchangeRatesInputEnvelope
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    connect?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutExchangeRatesInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutExchangeRatesInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type PricesUpdateManyWithoutExchangeRatesNestedInput = {
    create?: XOR<Enumerable<PricesCreateWithoutExchangeRatesInput>, Enumerable<PricesUncheckedCreateWithoutExchangeRatesInput>>
    connectOrCreate?: Enumerable<PricesCreateOrConnectWithoutExchangeRatesInput>
    upsert?: Enumerable<PricesUpsertWithWhereUniqueWithoutExchangeRatesInput>
    createMany?: PricesCreateManyExchangeRatesInputEnvelope
    set?: Enumerable<PricesWhereUniqueInput>
    disconnect?: Enumerable<PricesWhereUniqueInput>
    delete?: Enumerable<PricesWhereUniqueInput>
    connect?: Enumerable<PricesWhereUniqueInput>
    update?: Enumerable<PricesUpdateWithWhereUniqueWithoutExchangeRatesInput>
    updateMany?: Enumerable<PricesUpdateManyWithWhereWithoutExchangeRatesInput>
    deleteMany?: Enumerable<PricesScalarWhereInput>
  }

  export type PaymentUncheckedUpdateManyWithoutExchangeRatesNestedInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutExchangeRatesInput>, Enumerable<PaymentUncheckedCreateWithoutExchangeRatesInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutExchangeRatesInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutExchangeRatesInput>
    createMany?: PaymentCreateManyExchangeRatesInputEnvelope
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    connect?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutExchangeRatesInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutExchangeRatesInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type PricesUncheckedUpdateManyWithoutExchangeRatesNestedInput = {
    create?: XOR<Enumerable<PricesCreateWithoutExchangeRatesInput>, Enumerable<PricesUncheckedCreateWithoutExchangeRatesInput>>
    connectOrCreate?: Enumerable<PricesCreateOrConnectWithoutExchangeRatesInput>
    upsert?: Enumerable<PricesUpsertWithWhereUniqueWithoutExchangeRatesInput>
    createMany?: PricesCreateManyExchangeRatesInputEnvelope
    set?: Enumerable<PricesWhereUniqueInput>
    disconnect?: Enumerable<PricesWhereUniqueInput>
    delete?: Enumerable<PricesWhereUniqueInput>
    connect?: Enumerable<PricesWhereUniqueInput>
    update?: Enumerable<PricesUpdateWithWhereUniqueWithoutExchangeRatesInput>
    updateMany?: Enumerable<PricesUpdateManyWithWhereWithoutExchangeRatesInput>
    deleteMany?: Enumerable<PricesScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutJournalInput = {
    create?: XOR<UserCreateWithoutJournalInput, UserUncheckedCreateWithoutJournalInput>
    connectOrCreate?: UserCreateOrConnectWithoutJournalInput
    connect?: UserWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutJournalInput = {
    create?: XOR<SupplierCreateWithoutJournalInput, SupplierUncheckedCreateWithoutJournalInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutJournalInput
    connect?: SupplierWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutJournalInput = {
    create?: XOR<CustomerCreateWithoutJournalInput, CustomerUncheckedCreateWithoutJournalInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutJournalInput
    connect?: CustomerWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutJournalInput = {
    create?: XOR<TransactionCreateWithoutJournalInput, TransactionUncheckedCreateWithoutJournalInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutJournalInput
    connect?: TransactionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutJournalNestedInput = {
    create?: XOR<UserCreateWithoutJournalInput, UserUncheckedCreateWithoutJournalInput>
    connectOrCreate?: UserCreateOrConnectWithoutJournalInput
    upsert?: UserUpsertWithoutJournalInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutJournalInput, UserUncheckedUpdateWithoutJournalInput>
  }

  export type SupplierUpdateOneWithoutJournalNestedInput = {
    create?: XOR<SupplierCreateWithoutJournalInput, SupplierUncheckedCreateWithoutJournalInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutJournalInput
    upsert?: SupplierUpsertWithoutJournalInput
    disconnect?: boolean
    delete?: boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<SupplierUpdateWithoutJournalInput, SupplierUncheckedUpdateWithoutJournalInput>
  }

  export type CustomerUpdateOneWithoutJournalNestedInput = {
    create?: XOR<CustomerCreateWithoutJournalInput, CustomerUncheckedCreateWithoutJournalInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutJournalInput
    upsert?: CustomerUpsertWithoutJournalInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutJournalInput, CustomerUncheckedUpdateWithoutJournalInput>
  }

  export type TransactionUpdateOneRequiredWithoutJournalNestedInput = {
    create?: XOR<TransactionCreateWithoutJournalInput, TransactionUncheckedCreateWithoutJournalInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutJournalInput
    upsert?: TransactionUpsertWithoutJournalInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<TransactionUpdateWithoutJournalInput, TransactionUncheckedUpdateWithoutJournalInput>
  }

  export type UserCreateNestedOneWithoutSalesJournalInput = {
    create?: XOR<UserCreateWithoutSalesJournalInput, UserUncheckedCreateWithoutSalesJournalInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesJournalInput
    connect?: UserWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutSalesJournalInput = {
    create?: XOR<SupplierCreateWithoutSalesJournalInput, SupplierUncheckedCreateWithoutSalesJournalInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutSalesJournalInput
    connect?: SupplierWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutSalesJournalInput = {
    create?: XOR<TransactionCreateWithoutSalesJournalInput, TransactionUncheckedCreateWithoutSalesJournalInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutSalesJournalInput
    connect?: TransactionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSalesJournalNestedInput = {
    create?: XOR<UserCreateWithoutSalesJournalInput, UserUncheckedCreateWithoutSalesJournalInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesJournalInput
    upsert?: UserUpsertWithoutSalesJournalInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSalesJournalInput, UserUncheckedUpdateWithoutSalesJournalInput>
  }

  export type SupplierUpdateOneRequiredWithoutSalesJournalNestedInput = {
    create?: XOR<SupplierCreateWithoutSalesJournalInput, SupplierUncheckedCreateWithoutSalesJournalInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutSalesJournalInput
    upsert?: SupplierUpsertWithoutSalesJournalInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<SupplierUpdateWithoutSalesJournalInput, SupplierUncheckedUpdateWithoutSalesJournalInput>
  }

  export type TransactionUpdateOneRequiredWithoutSalesJournalNestedInput = {
    create?: XOR<TransactionCreateWithoutSalesJournalInput, TransactionUncheckedCreateWithoutSalesJournalInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutSalesJournalInput
    upsert?: TransactionUpsertWithoutSalesJournalInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<TransactionUpdateWithoutSalesJournalInput, TransactionUncheckedUpdateWithoutSalesJournalInput>
  }

  export type UserCreateNestedOneWithoutPurchasesJournalInput = {
    create?: XOR<UserCreateWithoutPurchasesJournalInput, UserUncheckedCreateWithoutPurchasesJournalInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasesJournalInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutPurchasesJournalInput = {
    create?: XOR<CustomerCreateWithoutPurchasesJournalInput, CustomerUncheckedCreateWithoutPurchasesJournalInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPurchasesJournalInput
    connect?: CustomerWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutPurchasesJournalInput = {
    create?: XOR<TransactionCreateWithoutPurchasesJournalInput, TransactionUncheckedCreateWithoutPurchasesJournalInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPurchasesJournalInput
    connect?: TransactionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPurchasesJournalNestedInput = {
    create?: XOR<UserCreateWithoutPurchasesJournalInput, UserUncheckedCreateWithoutPurchasesJournalInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasesJournalInput
    upsert?: UserUpsertWithoutPurchasesJournalInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPurchasesJournalInput, UserUncheckedUpdateWithoutPurchasesJournalInput>
  }

  export type CustomerUpdateOneWithoutPurchasesJournalNestedInput = {
    create?: XOR<CustomerCreateWithoutPurchasesJournalInput, CustomerUncheckedCreateWithoutPurchasesJournalInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPurchasesJournalInput
    upsert?: CustomerUpsertWithoutPurchasesJournalInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutPurchasesJournalInput, CustomerUncheckedUpdateWithoutPurchasesJournalInput>
  }

  export type TransactionUpdateOneRequiredWithoutPurchasesJournalNestedInput = {
    create?: XOR<TransactionCreateWithoutPurchasesJournalInput, TransactionUncheckedCreateWithoutPurchasesJournalInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPurchasesJournalInput
    upsert?: TransactionUpsertWithoutPurchasesJournalInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<TransactionUpdateWithoutPurchasesJournalInput, TransactionUncheckedUpdateWithoutPurchasesJournalInput>
  }

  export type UserCreateNestedOneWithoutCashDisbursementsJournalInput = {
    create?: XOR<UserCreateWithoutCashDisbursementsJournalInput, UserUncheckedCreateWithoutCashDisbursementsJournalInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashDisbursementsJournalInput
    connect?: UserWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutCashDisbursementsJournalInput = {
    create?: XOR<SupplierCreateWithoutCashDisbursementsJournalInput, SupplierUncheckedCreateWithoutCashDisbursementsJournalInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutCashDisbursementsJournalInput
    connect?: SupplierWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutCashDisbursementsJournalInput = {
    create?: XOR<CustomerCreateWithoutCashDisbursementsJournalInput, CustomerUncheckedCreateWithoutCashDisbursementsJournalInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCashDisbursementsJournalInput
    connect?: CustomerWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutCashDisbursementsJournalInput = {
    create?: XOR<TransactionCreateWithoutCashDisbursementsJournalInput, TransactionUncheckedCreateWithoutCashDisbursementsJournalInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutCashDisbursementsJournalInput
    connect?: TransactionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCashDisbursementsJournalNestedInput = {
    create?: XOR<UserCreateWithoutCashDisbursementsJournalInput, UserUncheckedCreateWithoutCashDisbursementsJournalInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashDisbursementsJournalInput
    upsert?: UserUpsertWithoutCashDisbursementsJournalInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCashDisbursementsJournalInput, UserUncheckedUpdateWithoutCashDisbursementsJournalInput>
  }

  export type SupplierUpdateOneWithoutCashDisbursementsJournalNestedInput = {
    create?: XOR<SupplierCreateWithoutCashDisbursementsJournalInput, SupplierUncheckedCreateWithoutCashDisbursementsJournalInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutCashDisbursementsJournalInput
    upsert?: SupplierUpsertWithoutCashDisbursementsJournalInput
    disconnect?: boolean
    delete?: boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<SupplierUpdateWithoutCashDisbursementsJournalInput, SupplierUncheckedUpdateWithoutCashDisbursementsJournalInput>
  }

  export type CustomerUpdateOneWithoutCashDisbursementsJournalNestedInput = {
    create?: XOR<CustomerCreateWithoutCashDisbursementsJournalInput, CustomerUncheckedCreateWithoutCashDisbursementsJournalInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCashDisbursementsJournalInput
    upsert?: CustomerUpsertWithoutCashDisbursementsJournalInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutCashDisbursementsJournalInput, CustomerUncheckedUpdateWithoutCashDisbursementsJournalInput>
  }

  export type TransactionUpdateOneRequiredWithoutCashDisbursementsJournalNestedInput = {
    create?: XOR<TransactionCreateWithoutCashDisbursementsJournalInput, TransactionUncheckedCreateWithoutCashDisbursementsJournalInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutCashDisbursementsJournalInput
    upsert?: TransactionUpsertWithoutCashDisbursementsJournalInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<TransactionUpdateWithoutCashDisbursementsJournalInput, TransactionUncheckedUpdateWithoutCashDisbursementsJournalInput>
  }

  export type UserCreateNestedOneWithoutCashReceiptsJournalInput = {
    create?: XOR<UserCreateWithoutCashReceiptsJournalInput, UserUncheckedCreateWithoutCashReceiptsJournalInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashReceiptsJournalInput
    connect?: UserWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutCashReceiptsJournalInput = {
    create?: XOR<SupplierCreateWithoutCashReceiptsJournalInput, SupplierUncheckedCreateWithoutCashReceiptsJournalInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutCashReceiptsJournalInput
    connect?: SupplierWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutCashReceiptsJournalInput = {
    create?: XOR<CustomerCreateWithoutCashReceiptsJournalInput, CustomerUncheckedCreateWithoutCashReceiptsJournalInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCashReceiptsJournalInput
    connect?: CustomerWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutCashReceiptsJournalInput = {
    create?: XOR<TransactionCreateWithoutCashReceiptsJournalInput, TransactionUncheckedCreateWithoutCashReceiptsJournalInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutCashReceiptsJournalInput
    connect?: TransactionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCashReceiptsJournalNestedInput = {
    create?: XOR<UserCreateWithoutCashReceiptsJournalInput, UserUncheckedCreateWithoutCashReceiptsJournalInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashReceiptsJournalInput
    upsert?: UserUpsertWithoutCashReceiptsJournalInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCashReceiptsJournalInput, UserUncheckedUpdateWithoutCashReceiptsJournalInput>
  }

  export type SupplierUpdateOneWithoutCashReceiptsJournalNestedInput = {
    create?: XOR<SupplierCreateWithoutCashReceiptsJournalInput, SupplierUncheckedCreateWithoutCashReceiptsJournalInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutCashReceiptsJournalInput
    upsert?: SupplierUpsertWithoutCashReceiptsJournalInput
    disconnect?: boolean
    delete?: boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<SupplierUpdateWithoutCashReceiptsJournalInput, SupplierUncheckedUpdateWithoutCashReceiptsJournalInput>
  }

  export type CustomerUpdateOneWithoutCashReceiptsJournalNestedInput = {
    create?: XOR<CustomerCreateWithoutCashReceiptsJournalInput, CustomerUncheckedCreateWithoutCashReceiptsJournalInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCashReceiptsJournalInput
    upsert?: CustomerUpsertWithoutCashReceiptsJournalInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutCashReceiptsJournalInput, CustomerUncheckedUpdateWithoutCashReceiptsJournalInput>
  }

  export type TransactionUpdateOneRequiredWithoutCashReceiptsJournalNestedInput = {
    create?: XOR<TransactionCreateWithoutCashReceiptsJournalInput, TransactionUncheckedCreateWithoutCashReceiptsJournalInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutCashReceiptsJournalInput
    upsert?: TransactionUpsertWithoutCashReceiptsJournalInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<TransactionUpdateWithoutCashReceiptsJournalInput, TransactionUncheckedUpdateWithoutCashReceiptsJournalInput>
  }

  export type UserCreateNestedOneWithoutReturnsInwardsJournalInput = {
    create?: XOR<UserCreateWithoutReturnsInwardsJournalInput, UserUncheckedCreateWithoutReturnsInwardsJournalInput>
    connectOrCreate?: UserCreateOrConnectWithoutReturnsInwardsJournalInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutReturnsInwardsJournalInput = {
    create?: XOR<CustomerCreateWithoutReturnsInwardsJournalInput, CustomerUncheckedCreateWithoutReturnsInwardsJournalInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutReturnsInwardsJournalInput
    connect?: CustomerWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutReturnsInwardsJournalInput = {
    create?: XOR<TransactionCreateWithoutReturnsInwardsJournalInput, TransactionUncheckedCreateWithoutReturnsInwardsJournalInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutReturnsInwardsJournalInput
    connect?: TransactionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReturnsInwardsJournalNestedInput = {
    create?: XOR<UserCreateWithoutReturnsInwardsJournalInput, UserUncheckedCreateWithoutReturnsInwardsJournalInput>
    connectOrCreate?: UserCreateOrConnectWithoutReturnsInwardsJournalInput
    upsert?: UserUpsertWithoutReturnsInwardsJournalInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutReturnsInwardsJournalInput, UserUncheckedUpdateWithoutReturnsInwardsJournalInput>
  }

  export type CustomerUpdateOneRequiredWithoutReturnsInwardsJournalNestedInput = {
    create?: XOR<CustomerCreateWithoutReturnsInwardsJournalInput, CustomerUncheckedCreateWithoutReturnsInwardsJournalInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutReturnsInwardsJournalInput
    upsert?: CustomerUpsertWithoutReturnsInwardsJournalInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutReturnsInwardsJournalInput, CustomerUncheckedUpdateWithoutReturnsInwardsJournalInput>
  }

  export type TransactionUpdateOneRequiredWithoutReturnsInwardsJournalNestedInput = {
    create?: XOR<TransactionCreateWithoutReturnsInwardsJournalInput, TransactionUncheckedCreateWithoutReturnsInwardsJournalInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutReturnsInwardsJournalInput
    upsert?: TransactionUpsertWithoutReturnsInwardsJournalInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<TransactionUpdateWithoutReturnsInwardsJournalInput, TransactionUncheckedUpdateWithoutReturnsInwardsJournalInput>
  }

  export type UserCreateNestedOneWithoutReturnsOutwardsJournalInput = {
    create?: XOR<UserCreateWithoutReturnsOutwardsJournalInput, UserUncheckedCreateWithoutReturnsOutwardsJournalInput>
    connectOrCreate?: UserCreateOrConnectWithoutReturnsOutwardsJournalInput
    connect?: UserWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutReturnsOutwardsJournalInput = {
    create?: XOR<SupplierCreateWithoutReturnsOutwardsJournalInput, SupplierUncheckedCreateWithoutReturnsOutwardsJournalInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutReturnsOutwardsJournalInput
    connect?: SupplierWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutReturnsOutwardsJournalInput = {
    create?: XOR<TransactionCreateWithoutReturnsOutwardsJournalInput, TransactionUncheckedCreateWithoutReturnsOutwardsJournalInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutReturnsOutwardsJournalInput
    connect?: TransactionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReturnsOutwardsJournalNestedInput = {
    create?: XOR<UserCreateWithoutReturnsOutwardsJournalInput, UserUncheckedCreateWithoutReturnsOutwardsJournalInput>
    connectOrCreate?: UserCreateOrConnectWithoutReturnsOutwardsJournalInput
    upsert?: UserUpsertWithoutReturnsOutwardsJournalInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutReturnsOutwardsJournalInput, UserUncheckedUpdateWithoutReturnsOutwardsJournalInput>
  }

  export type SupplierUpdateOneRequiredWithoutReturnsOutwardsJournalNestedInput = {
    create?: XOR<SupplierCreateWithoutReturnsOutwardsJournalInput, SupplierUncheckedCreateWithoutReturnsOutwardsJournalInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutReturnsOutwardsJournalInput
    upsert?: SupplierUpsertWithoutReturnsOutwardsJournalInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<SupplierUpdateWithoutReturnsOutwardsJournalInput, SupplierUncheckedUpdateWithoutReturnsOutwardsJournalInput>
  }

  export type TransactionUpdateOneRequiredWithoutReturnsOutwardsJournalNestedInput = {
    create?: XOR<TransactionCreateWithoutReturnsOutwardsJournalInput, TransactionUncheckedCreateWithoutReturnsOutwardsJournalInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutReturnsOutwardsJournalInput
    upsert?: TransactionUpsertWithoutReturnsOutwardsJournalInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<TransactionUpdateWithoutReturnsOutwardsJournalInput, TransactionUncheckedUpdateWithoutReturnsOutwardsJournalInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumTransactionTypeFilter = {
    equals?: TransactionType
    in?: Enumerable<TransactionType>
    notIn?: Enumerable<TransactionType>
    not?: NestedEnumTransactionTypeFilter | TransactionType
  }

  export type NestedEnumTransactionStatusCodesFilter = {
    equals?: TransactionStatusCodes
    in?: Enumerable<TransactionStatusCodes>
    notIn?: Enumerable<TransactionStatusCodes>
    not?: NestedEnumTransactionStatusCodesFilter | TransactionStatusCodes
  }

  export type NestedDecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter = {
    equals?: TransactionType
    in?: Enumerable<TransactionType>
    notIn?: Enumerable<TransactionType>
    not?: NestedEnumTransactionTypeWithAggregatesFilter | TransactionType
    _count?: NestedIntFilter
    _min?: NestedEnumTransactionTypeFilter
    _max?: NestedEnumTransactionTypeFilter
  }

  export type NestedEnumTransactionStatusCodesWithAggregatesFilter = {
    equals?: TransactionStatusCodes
    in?: Enumerable<TransactionStatusCodes>
    notIn?: Enumerable<TransactionStatusCodes>
    not?: NestedEnumTransactionStatusCodesWithAggregatesFilter | TransactionStatusCodes
    _count?: NestedIntFilter
    _min?: NestedEnumTransactionStatusCodesFilter
    _max?: NestedEnumTransactionStatusCodesFilter
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedEnumMeasurementUnitFilter = {
    equals?: MeasurementUnit
    in?: Enumerable<MeasurementUnit>
    notIn?: Enumerable<MeasurementUnit>
    not?: NestedEnumMeasurementUnitFilter | MeasurementUnit
  }

  export type NestedEnumMeasurementUnitWithAggregatesFilter = {
    equals?: MeasurementUnit
    in?: Enumerable<MeasurementUnit>
    notIn?: Enumerable<MeasurementUnit>
    not?: NestedEnumMeasurementUnitWithAggregatesFilter | MeasurementUnit
    _count?: NestedIntFilter
    _min?: NestedEnumMeasurementUnitFilter
    _max?: NestedEnumMeasurementUnitFilter
  }

  export type invoiceCreateWithoutCashierInput = {
    id?: string
    discount?: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    tax?: TaxCreateNestedManyWithoutInvoiceInput
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutInvoiceInput
    product: ProductCreateNestedOneWithoutInvoiceInput
    transaction: TransactionCreateNestedOneWithoutInvoiceInput
    Supplier?: SupplierCreateNestedOneWithoutInvoiceInput
  }

  export type invoiceUncheckedCreateWithoutCashierInput = {
    id?: string
    productId: string
    discount?: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    transactionId: number
    tax?: TaxUncheckedCreateNestedManyWithoutInvoiceInput
    customerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierId?: string | null
  }

  export type invoiceCreateOrConnectWithoutCashierInput = {
    where: invoiceWhereUniqueInput
    create: XOR<invoiceCreateWithoutCashierInput, invoiceUncheckedCreateWithoutCashierInput>
  }

  export type invoiceCreateManyCashierInputEnvelope = {
    data: Enumerable<invoiceCreateManyCashierInput>
    skipDuplicates?: boolean
  }

  export type JournalCreateWithoutRecorderInput = {
    id?: string
    supplier?: SupplierCreateNestedOneWithoutJournalInput
    customer?: CustomerCreateNestedOneWithoutJournalInput
    transaction: TransactionCreateNestedOneWithoutJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type JournalUncheckedCreateWithoutRecorderInput = {
    id?: string
    supplierId?: string | null
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type JournalCreateOrConnectWithoutRecorderInput = {
    where: JournalWhereUniqueInput
    create: XOR<JournalCreateWithoutRecorderInput, JournalUncheckedCreateWithoutRecorderInput>
  }

  export type JournalCreateManyRecorderInputEnvelope = {
    data: Enumerable<JournalCreateManyRecorderInput>
    skipDuplicates?: boolean
  }

  export type ActionCreateWithoutUserInput = {
    id?: string
    actionType: boolean
    description: string
  }

  export type ActionUncheckedCreateWithoutUserInput = {
    id?: string
    actionType: boolean
    description: string
  }

  export type ActionCreateOrConnectWithoutUserInput = {
    where: ActionWhereUniqueInput
    create: XOR<ActionCreateWithoutUserInput, ActionUncheckedCreateWithoutUserInput>
  }

  export type ActionCreateManyUserInputEnvelope = {
    data: Enumerable<ActionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUsersInput = {
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    errorDescription?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    customer?: CustomerCreateNestedOneWithoutTransactionInput
    supplier?: SupplierCreateNestedOneWithoutTransactionsInput
    payments?: PaymentCreateNestedManyWithoutTransactionInput
    invoice?: invoiceCreateNestedManyWithoutTransactionInput
    journal?: JournalCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutUsersInput = {
    id?: number
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    supplierId?: string | null
    errorDescription?: string | null
    customerId?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    payments?: PaymentUncheckedCreateNestedManyWithoutTransactionInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutTransactionInput
    journal?: JournalUncheckedCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutUsersInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUsersInput, TransactionUncheckedCreateWithoutUsersInput>
  }

  export type TransactionCreateManyUsersInputEnvelope = {
    data: Enumerable<TransactionCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type SalesJournalCreateWithoutRecorderInput = {
    id?: string
    supplier: SupplierCreateNestedOneWithoutSalesJournalInput
    transaction: TransactionCreateNestedOneWithoutSalesJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalUncheckedCreateWithoutRecorderInput = {
    id?: string
    supplierId: string
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalCreateOrConnectWithoutRecorderInput = {
    where: SalesJournalWhereUniqueInput
    create: XOR<SalesJournalCreateWithoutRecorderInput, SalesJournalUncheckedCreateWithoutRecorderInput>
  }

  export type SalesJournalCreateManyRecorderInputEnvelope = {
    data: Enumerable<SalesJournalCreateManyRecorderInput>
    skipDuplicates?: boolean
  }

  export type PurchasesJournalCreateWithoutRecorderInput = {
    id?: string
    customer?: CustomerCreateNestedOneWithoutPurchasesJournalInput
    transaction: TransactionCreateNestedOneWithoutPurchasesJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalUncheckedCreateWithoutRecorderInput = {
    id?: string
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalCreateOrConnectWithoutRecorderInput = {
    where: PurchasesJournalWhereUniqueInput
    create: XOR<PurchasesJournalCreateWithoutRecorderInput, PurchasesJournalUncheckedCreateWithoutRecorderInput>
  }

  export type PurchasesJournalCreateManyRecorderInputEnvelope = {
    data: Enumerable<PurchasesJournalCreateManyRecorderInput>
    skipDuplicates?: boolean
  }

  export type CashDisbursementsJournalCreateWithoutRecorderInput = {
    id?: string
    supplier?: SupplierCreateNestedOneWithoutCashDisbursementsJournalInput
    customer?: CustomerCreateNestedOneWithoutCashDisbursementsJournalInput
    transaction: TransactionCreateNestedOneWithoutCashDisbursementsJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalUncheckedCreateWithoutRecorderInput = {
    id?: string
    supplierId?: string | null
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalCreateOrConnectWithoutRecorderInput = {
    where: CashDisbursementsJournalWhereUniqueInput
    create: XOR<CashDisbursementsJournalCreateWithoutRecorderInput, CashDisbursementsJournalUncheckedCreateWithoutRecorderInput>
  }

  export type CashDisbursementsJournalCreateManyRecorderInputEnvelope = {
    data: Enumerable<CashDisbursementsJournalCreateManyRecorderInput>
    skipDuplicates?: boolean
  }

  export type CashReceiptsJournalCreateWithoutRecorderInput = {
    id?: string
    supplier?: SupplierCreateNestedOneWithoutCashReceiptsJournalInput
    customer?: CustomerCreateNestedOneWithoutCashReceiptsJournalInput
    transaction: TransactionCreateNestedOneWithoutCashReceiptsJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalUncheckedCreateWithoutRecorderInput = {
    id?: string
    supplierId?: string | null
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalCreateOrConnectWithoutRecorderInput = {
    where: CashReceiptsJournalWhereUniqueInput
    create: XOR<CashReceiptsJournalCreateWithoutRecorderInput, CashReceiptsJournalUncheckedCreateWithoutRecorderInput>
  }

  export type CashReceiptsJournalCreateManyRecorderInputEnvelope = {
    data: Enumerable<CashReceiptsJournalCreateManyRecorderInput>
    skipDuplicates?: boolean
  }

  export type ReturnsInwardsJournalCreateWithoutRecorderInput = {
    id?: string
    customer: CustomerCreateNestedOneWithoutReturnsInwardsJournalInput
    transaction: TransactionCreateNestedOneWithoutReturnsInwardsJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalUncheckedCreateWithoutRecorderInput = {
    id?: string
    customerId: string
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalCreateOrConnectWithoutRecorderInput = {
    where: ReturnsInwardsJournalWhereUniqueInput
    create: XOR<ReturnsInwardsJournalCreateWithoutRecorderInput, ReturnsInwardsJournalUncheckedCreateWithoutRecorderInput>
  }

  export type ReturnsInwardsJournalCreateManyRecorderInputEnvelope = {
    data: Enumerable<ReturnsInwardsJournalCreateManyRecorderInput>
    skipDuplicates?: boolean
  }

  export type ReturnsOutwardsJournalCreateWithoutRecorderInput = {
    id?: string
    supplier: SupplierCreateNestedOneWithoutReturnsOutwardsJournalInput
    transaction: TransactionCreateNestedOneWithoutReturnsOutwardsJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalUncheckedCreateWithoutRecorderInput = {
    id?: string
    supplierId: string
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalCreateOrConnectWithoutRecorderInput = {
    where: ReturnsOutwardsJournalWhereUniqueInput
    create: XOR<ReturnsOutwardsJournalCreateWithoutRecorderInput, ReturnsOutwardsJournalUncheckedCreateWithoutRecorderInput>
  }

  export type ReturnsOutwardsJournalCreateManyRecorderInputEnvelope = {
    data: Enumerable<ReturnsOutwardsJournalCreateManyRecorderInput>
    skipDuplicates?: boolean
  }

  export type invoiceUpsertWithWhereUniqueWithoutCashierInput = {
    where: invoiceWhereUniqueInput
    update: XOR<invoiceUpdateWithoutCashierInput, invoiceUncheckedUpdateWithoutCashierInput>
    create: XOR<invoiceCreateWithoutCashierInput, invoiceUncheckedCreateWithoutCashierInput>
  }

  export type invoiceUpdateWithWhereUniqueWithoutCashierInput = {
    where: invoiceWhereUniqueInput
    data: XOR<invoiceUpdateWithoutCashierInput, invoiceUncheckedUpdateWithoutCashierInput>
  }

  export type invoiceUpdateManyWithWhereWithoutCashierInput = {
    where: invoiceScalarWhereInput
    data: XOR<invoiceUpdateManyMutationInput, invoiceUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type invoiceScalarWhereInput = {
    AND?: Enumerable<invoiceScalarWhereInput>
    OR?: Enumerable<invoiceScalarWhereInput>
    NOT?: Enumerable<invoiceScalarWhereInput>
    id?: StringFilter | string
    productId?: StringFilter | string
    discount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    price?: DecimalFilter | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter | number
    transactionId?: IntFilter | number
    cashierId?: IntFilter | number
    customerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    supplierId?: StringNullableFilter | string | null
  }

  export type JournalUpsertWithWhereUniqueWithoutRecorderInput = {
    where: JournalWhereUniqueInput
    update: XOR<JournalUpdateWithoutRecorderInput, JournalUncheckedUpdateWithoutRecorderInput>
    create: XOR<JournalCreateWithoutRecorderInput, JournalUncheckedCreateWithoutRecorderInput>
  }

  export type JournalUpdateWithWhereUniqueWithoutRecorderInput = {
    where: JournalWhereUniqueInput
    data: XOR<JournalUpdateWithoutRecorderInput, JournalUncheckedUpdateWithoutRecorderInput>
  }

  export type JournalUpdateManyWithWhereWithoutRecorderInput = {
    where: JournalScalarWhereInput
    data: XOR<JournalUpdateManyMutationInput, JournalUncheckedUpdateManyWithoutJournalInput>
  }

  export type JournalScalarWhereInput = {
    AND?: Enumerable<JournalScalarWhereInput>
    OR?: Enumerable<JournalScalarWhereInput>
    NOT?: Enumerable<JournalScalarWhereInput>
    id?: StringFilter | string
    recorderId?: IntFilter | number
    supplierId?: StringNullableFilter | string | null
    customerId?: StringNullableFilter | string | null
    transactionId?: IntFilter | number
    narration?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type ActionUpsertWithWhereUniqueWithoutUserInput = {
    where: ActionWhereUniqueInput
    update: XOR<ActionUpdateWithoutUserInput, ActionUncheckedUpdateWithoutUserInput>
    create: XOR<ActionCreateWithoutUserInput, ActionUncheckedCreateWithoutUserInput>
  }

  export type ActionUpdateWithWhereUniqueWithoutUserInput = {
    where: ActionWhereUniqueInput
    data: XOR<ActionUpdateWithoutUserInput, ActionUncheckedUpdateWithoutUserInput>
  }

  export type ActionUpdateManyWithWhereWithoutUserInput = {
    where: ActionScalarWhereInput
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyWithoutActionInput>
  }

  export type ActionScalarWhereInput = {
    AND?: Enumerable<ActionScalarWhereInput>
    OR?: Enumerable<ActionScalarWhereInput>
    NOT?: Enumerable<ActionScalarWhereInput>
    id?: StringFilter | string
    userId?: IntFilter | number
    actionType?: BoolFilter | boolean
    description?: StringFilter | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUsersInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUsersInput, TransactionUncheckedUpdateWithoutUsersInput>
    create: XOR<TransactionCreateWithoutUsersInput, TransactionUncheckedCreateWithoutUsersInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUsersInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUsersInput, TransactionUncheckedUpdateWithoutUsersInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUsersInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: Enumerable<TransactionScalarWhereInput>
    OR?: Enumerable<TransactionScalarWhereInput>
    NOT?: Enumerable<TransactionScalarWhereInput>
    id?: IntFilter | number
    initiatedBy?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    totalPaid?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    totalPayable?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    supplierId?: StringNullableFilter | string | null
    errorDescription?: StringNullableFilter | string | null
    customerId?: StringNullableFilter | string | null
    type?: EnumTransactionTypeFilter | TransactionType
    status?: EnumTransactionStatusCodesFilter | TransactionStatusCodes
  }

  export type SalesJournalUpsertWithWhereUniqueWithoutRecorderInput = {
    where: SalesJournalWhereUniqueInput
    update: XOR<SalesJournalUpdateWithoutRecorderInput, SalesJournalUncheckedUpdateWithoutRecorderInput>
    create: XOR<SalesJournalCreateWithoutRecorderInput, SalesJournalUncheckedCreateWithoutRecorderInput>
  }

  export type SalesJournalUpdateWithWhereUniqueWithoutRecorderInput = {
    where: SalesJournalWhereUniqueInput
    data: XOR<SalesJournalUpdateWithoutRecorderInput, SalesJournalUncheckedUpdateWithoutRecorderInput>
  }

  export type SalesJournalUpdateManyWithWhereWithoutRecorderInput = {
    where: SalesJournalScalarWhereInput
    data: XOR<SalesJournalUpdateManyMutationInput, SalesJournalUncheckedUpdateManyWithoutSalesJournalInput>
  }

  export type SalesJournalScalarWhereInput = {
    AND?: Enumerable<SalesJournalScalarWhereInput>
    OR?: Enumerable<SalesJournalScalarWhereInput>
    NOT?: Enumerable<SalesJournalScalarWhereInput>
    id?: StringFilter | string
    recorderId?: IntFilter | number
    supplierId?: StringFilter | string
    transactionId?: IntFilter | number
    narration?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalUpsertWithWhereUniqueWithoutRecorderInput = {
    where: PurchasesJournalWhereUniqueInput
    update: XOR<PurchasesJournalUpdateWithoutRecorderInput, PurchasesJournalUncheckedUpdateWithoutRecorderInput>
    create: XOR<PurchasesJournalCreateWithoutRecorderInput, PurchasesJournalUncheckedCreateWithoutRecorderInput>
  }

  export type PurchasesJournalUpdateWithWhereUniqueWithoutRecorderInput = {
    where: PurchasesJournalWhereUniqueInput
    data: XOR<PurchasesJournalUpdateWithoutRecorderInput, PurchasesJournalUncheckedUpdateWithoutRecorderInput>
  }

  export type PurchasesJournalUpdateManyWithWhereWithoutRecorderInput = {
    where: PurchasesJournalScalarWhereInput
    data: XOR<PurchasesJournalUpdateManyMutationInput, PurchasesJournalUncheckedUpdateManyWithoutPurchasesJournalInput>
  }

  export type PurchasesJournalScalarWhereInput = {
    AND?: Enumerable<PurchasesJournalScalarWhereInput>
    OR?: Enumerable<PurchasesJournalScalarWhereInput>
    NOT?: Enumerable<PurchasesJournalScalarWhereInput>
    id?: StringFilter | string
    recorderId?: IntFilter | number
    customerId?: StringNullableFilter | string | null
    transactionId?: IntFilter | number
    narration?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalUpsertWithWhereUniqueWithoutRecorderInput = {
    where: CashDisbursementsJournalWhereUniqueInput
    update: XOR<CashDisbursementsJournalUpdateWithoutRecorderInput, CashDisbursementsJournalUncheckedUpdateWithoutRecorderInput>
    create: XOR<CashDisbursementsJournalCreateWithoutRecorderInput, CashDisbursementsJournalUncheckedCreateWithoutRecorderInput>
  }

  export type CashDisbursementsJournalUpdateWithWhereUniqueWithoutRecorderInput = {
    where: CashDisbursementsJournalWhereUniqueInput
    data: XOR<CashDisbursementsJournalUpdateWithoutRecorderInput, CashDisbursementsJournalUncheckedUpdateWithoutRecorderInput>
  }

  export type CashDisbursementsJournalUpdateManyWithWhereWithoutRecorderInput = {
    where: CashDisbursementsJournalScalarWhereInput
    data: XOR<CashDisbursementsJournalUpdateManyMutationInput, CashDisbursementsJournalUncheckedUpdateManyWithoutCashDisbursementsJournalInput>
  }

  export type CashDisbursementsJournalScalarWhereInput = {
    AND?: Enumerable<CashDisbursementsJournalScalarWhereInput>
    OR?: Enumerable<CashDisbursementsJournalScalarWhereInput>
    NOT?: Enumerable<CashDisbursementsJournalScalarWhereInput>
    id?: StringFilter | string
    recorderId?: IntFilter | number
    supplierId?: StringNullableFilter | string | null
    customerId?: StringNullableFilter | string | null
    transactionId?: IntFilter | number
    narration?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalUpsertWithWhereUniqueWithoutRecorderInput = {
    where: CashReceiptsJournalWhereUniqueInput
    update: XOR<CashReceiptsJournalUpdateWithoutRecorderInput, CashReceiptsJournalUncheckedUpdateWithoutRecorderInput>
    create: XOR<CashReceiptsJournalCreateWithoutRecorderInput, CashReceiptsJournalUncheckedCreateWithoutRecorderInput>
  }

  export type CashReceiptsJournalUpdateWithWhereUniqueWithoutRecorderInput = {
    where: CashReceiptsJournalWhereUniqueInput
    data: XOR<CashReceiptsJournalUpdateWithoutRecorderInput, CashReceiptsJournalUncheckedUpdateWithoutRecorderInput>
  }

  export type CashReceiptsJournalUpdateManyWithWhereWithoutRecorderInput = {
    where: CashReceiptsJournalScalarWhereInput
    data: XOR<CashReceiptsJournalUpdateManyMutationInput, CashReceiptsJournalUncheckedUpdateManyWithoutCashReceiptsJournalInput>
  }

  export type CashReceiptsJournalScalarWhereInput = {
    AND?: Enumerable<CashReceiptsJournalScalarWhereInput>
    OR?: Enumerable<CashReceiptsJournalScalarWhereInput>
    NOT?: Enumerable<CashReceiptsJournalScalarWhereInput>
    id?: StringFilter | string
    recorderId?: IntFilter | number
    supplierId?: StringNullableFilter | string | null
    customerId?: StringNullableFilter | string | null
    transactionId?: IntFilter | number
    narration?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalUpsertWithWhereUniqueWithoutRecorderInput = {
    where: ReturnsInwardsJournalWhereUniqueInput
    update: XOR<ReturnsInwardsJournalUpdateWithoutRecorderInput, ReturnsInwardsJournalUncheckedUpdateWithoutRecorderInput>
    create: XOR<ReturnsInwardsJournalCreateWithoutRecorderInput, ReturnsInwardsJournalUncheckedCreateWithoutRecorderInput>
  }

  export type ReturnsInwardsJournalUpdateWithWhereUniqueWithoutRecorderInput = {
    where: ReturnsInwardsJournalWhereUniqueInput
    data: XOR<ReturnsInwardsJournalUpdateWithoutRecorderInput, ReturnsInwardsJournalUncheckedUpdateWithoutRecorderInput>
  }

  export type ReturnsInwardsJournalUpdateManyWithWhereWithoutRecorderInput = {
    where: ReturnsInwardsJournalScalarWhereInput
    data: XOR<ReturnsInwardsJournalUpdateManyMutationInput, ReturnsInwardsJournalUncheckedUpdateManyWithoutReturnsInwardsJournalInput>
  }

  export type ReturnsInwardsJournalScalarWhereInput = {
    AND?: Enumerable<ReturnsInwardsJournalScalarWhereInput>
    OR?: Enumerable<ReturnsInwardsJournalScalarWhereInput>
    NOT?: Enumerable<ReturnsInwardsJournalScalarWhereInput>
    id?: StringFilter | string
    recorderId?: IntFilter | number
    customerId?: StringFilter | string
    transactionId?: IntFilter | number
    narration?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalUpsertWithWhereUniqueWithoutRecorderInput = {
    where: ReturnsOutwardsJournalWhereUniqueInput
    update: XOR<ReturnsOutwardsJournalUpdateWithoutRecorderInput, ReturnsOutwardsJournalUncheckedUpdateWithoutRecorderInput>
    create: XOR<ReturnsOutwardsJournalCreateWithoutRecorderInput, ReturnsOutwardsJournalUncheckedCreateWithoutRecorderInput>
  }

  export type ReturnsOutwardsJournalUpdateWithWhereUniqueWithoutRecorderInput = {
    where: ReturnsOutwardsJournalWhereUniqueInput
    data: XOR<ReturnsOutwardsJournalUpdateWithoutRecorderInput, ReturnsOutwardsJournalUncheckedUpdateWithoutRecorderInput>
  }

  export type ReturnsOutwardsJournalUpdateManyWithWhereWithoutRecorderInput = {
    where: ReturnsOutwardsJournalScalarWhereInput
    data: XOR<ReturnsOutwardsJournalUpdateManyMutationInput, ReturnsOutwardsJournalUncheckedUpdateManyWithoutReturnsOutwardsJournalInput>
  }

  export type ReturnsOutwardsJournalScalarWhereInput = {
    AND?: Enumerable<ReturnsOutwardsJournalScalarWhereInput>
    OR?: Enumerable<ReturnsOutwardsJournalScalarWhereInput>
    NOT?: Enumerable<ReturnsOutwardsJournalScalarWhereInput>
    id?: StringFilter | string
    recorderId?: IntFilter | number
    supplierId?: StringFilter | string
    transactionId?: IntFilter | number
    narration?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type UserCreateWithoutActionInput = {
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    invoice?: invoiceCreateNestedManyWithoutCashierInput
    journal?: JournalCreateNestedManyWithoutRecorderInput
    transaction?: TransactionCreateNestedManyWithoutUsersInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutRecorderInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutRecorderInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutRecorderInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutRecorderInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutRecorderInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutRecorderInput
  }

  export type UserUncheckedCreateWithoutActionInput = {
    id?: number
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    invoice?: invoiceUncheckedCreateNestedManyWithoutCashierInput
    journal?: JournalUncheckedCreateNestedManyWithoutRecorderInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUsersInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutRecorderInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutRecorderInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutRecorderInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutRecorderInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutRecorderInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutRecorderInput
  }

  export type UserCreateOrConnectWithoutActionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActionInput, UserUncheckedCreateWithoutActionInput>
  }

  export type UserUpsertWithoutActionInput = {
    update: XOR<UserUpdateWithoutActionInput, UserUncheckedUpdateWithoutActionInput>
    create: XOR<UserCreateWithoutActionInput, UserUncheckedCreateWithoutActionInput>
  }

  export type UserUpdateWithoutActionInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoiceUpdateManyWithoutCashierNestedInput
    journal?: JournalUpdateManyWithoutRecorderNestedInput
    transaction?: TransactionUpdateManyWithoutUsersNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutRecorderNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutRecorderNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutRecorderNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutRecorderNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutRecorderNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutRecorderNestedInput
  }

  export type UserUncheckedUpdateWithoutActionInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoiceUncheckedUpdateManyWithoutCashierNestedInput
    journal?: JournalUncheckedUpdateManyWithoutRecorderNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUsersNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutRecorderNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutRecorderNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput
  }

  export type UserCreateWithoutTransactionInput = {
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    invoice?: invoiceCreateNestedManyWithoutCashierInput
    journal?: JournalCreateNestedManyWithoutRecorderInput
    action?: ActionCreateNestedManyWithoutUserInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutRecorderInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutRecorderInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutRecorderInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutRecorderInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutRecorderInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutRecorderInput
  }

  export type UserUncheckedCreateWithoutTransactionInput = {
    id?: number
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    invoice?: invoiceUncheckedCreateNestedManyWithoutCashierInput
    journal?: JournalUncheckedCreateNestedManyWithoutRecorderInput
    action?: ActionUncheckedCreateNestedManyWithoutUserInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutRecorderInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutRecorderInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutRecorderInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutRecorderInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutRecorderInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutRecorderInput
  }

  export type UserCreateOrConnectWithoutTransactionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
  }

  export type CustomerCreateWithoutTransactionInput = {
    id?: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    emailAddress?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    address?: AddressCreateNestedManyWithoutCustomersInput
    invoice?: invoiceCreateNestedManyWithoutCustomerInput
    Journal?: JournalCreateNestedManyWithoutCustomerInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutCustomerInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutCustomerInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutCustomerInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutTransactionInput = {
    id?: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    emailAddress?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    address?: AddressUncheckedCreateNestedManyWithoutCustomersInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutCustomerInput
    Journal?: JournalUncheckedCreateNestedManyWithoutCustomerInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutCustomerInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutCustomerInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutCustomerInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutTransactionInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTransactionInput, CustomerUncheckedCreateWithoutTransactionInput>
  }

  export type SupplierCreateWithoutTransactionsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
    address?: AddressCreateNestedManyWithoutSuppliersInput
    product?: ProductCreateNestedManyWithoutSupplierInput
    invoice?: invoiceCreateNestedManyWithoutSupplierInput
    Journal?: JournalCreateNestedManyWithoutSupplierInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutSupplierInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutSupplierInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutSupplierInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutTransactionsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutSuppliersInput
    product?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutSupplierInput
    Journal?: JournalUncheckedCreateNestedManyWithoutSupplierInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutSupplierInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutSupplierInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutSupplierInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutTransactionsInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutTransactionsInput, SupplierUncheckedCreateWithoutTransactionsInput>
  }

  export type PaymentCreateWithoutTransactionInput = {
    id?: string
    paymentType: PaymentTypeCreateNestedOneWithoutPaymentInput
    paid: Decimal | DecimalJsLike | number | string
    currency: currencyCreateNestedOneWithoutPaymentsInput
    exchangeRates: exchangeRatesCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutTransactionInput = {
    id?: string
    paymentTypeId: string
    currencyId: string
    exchangeRateId: string
    paid: Decimal | DecimalJsLike | number | string
  }

  export type PaymentCreateOrConnectWithoutTransactionInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
  }

  export type PaymentCreateManyTransactionInputEnvelope = {
    data: Enumerable<PaymentCreateManyTransactionInput>
    skipDuplicates?: boolean
  }

  export type invoiceCreateWithoutTransactionInput = {
    id?: string
    discount?: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    tax?: TaxCreateNestedManyWithoutInvoiceInput
    createdAt?: Date | string
    updatedAt?: Date | string
    cashier: UserCreateNestedOneWithoutInvoiceInput
    customer?: CustomerCreateNestedOneWithoutInvoiceInput
    product: ProductCreateNestedOneWithoutInvoiceInput
    Supplier?: SupplierCreateNestedOneWithoutInvoiceInput
  }

  export type invoiceUncheckedCreateWithoutTransactionInput = {
    id?: string
    productId: string
    discount?: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    cashierId: number
    tax?: TaxUncheckedCreateNestedManyWithoutInvoiceInput
    customerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierId?: string | null
  }

  export type invoiceCreateOrConnectWithoutTransactionInput = {
    where: invoiceWhereUniqueInput
    create: XOR<invoiceCreateWithoutTransactionInput, invoiceUncheckedCreateWithoutTransactionInput>
  }

  export type invoiceCreateManyTransactionInputEnvelope = {
    data: Enumerable<invoiceCreateManyTransactionInput>
    skipDuplicates?: boolean
  }

  export type JournalCreateWithoutTransactionInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutJournalInput
    supplier?: SupplierCreateNestedOneWithoutJournalInput
    customer?: CustomerCreateNestedOneWithoutJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type JournalUncheckedCreateWithoutTransactionInput = {
    id?: string
    recorderId: number
    supplierId?: string | null
    customerId?: string | null
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type JournalCreateOrConnectWithoutTransactionInput = {
    where: JournalWhereUniqueInput
    create: XOR<JournalCreateWithoutTransactionInput, JournalUncheckedCreateWithoutTransactionInput>
  }

  export type JournalCreateManyTransactionInputEnvelope = {
    data: Enumerable<JournalCreateManyTransactionInput>
    skipDuplicates?: boolean
  }

  export type SalesJournalCreateWithoutTransactionInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutSalesJournalInput
    supplier: SupplierCreateNestedOneWithoutSalesJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalUncheckedCreateWithoutTransactionInput = {
    id?: string
    recorderId: number
    supplierId: string
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalCreateOrConnectWithoutTransactionInput = {
    where: SalesJournalWhereUniqueInput
    create: XOR<SalesJournalCreateWithoutTransactionInput, SalesJournalUncheckedCreateWithoutTransactionInput>
  }

  export type SalesJournalCreateManyTransactionInputEnvelope = {
    data: Enumerable<SalesJournalCreateManyTransactionInput>
    skipDuplicates?: boolean
  }

  export type PurchasesJournalCreateWithoutTransactionInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutPurchasesJournalInput
    customer?: CustomerCreateNestedOneWithoutPurchasesJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalUncheckedCreateWithoutTransactionInput = {
    id?: string
    recorderId: number
    customerId?: string | null
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalCreateOrConnectWithoutTransactionInput = {
    where: PurchasesJournalWhereUniqueInput
    create: XOR<PurchasesJournalCreateWithoutTransactionInput, PurchasesJournalUncheckedCreateWithoutTransactionInput>
  }

  export type PurchasesJournalCreateManyTransactionInputEnvelope = {
    data: Enumerable<PurchasesJournalCreateManyTransactionInput>
    skipDuplicates?: boolean
  }

  export type CashDisbursementsJournalCreateWithoutTransactionInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutCashDisbursementsJournalInput
    supplier?: SupplierCreateNestedOneWithoutCashDisbursementsJournalInput
    customer?: CustomerCreateNestedOneWithoutCashDisbursementsJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalUncheckedCreateWithoutTransactionInput = {
    id?: string
    recorderId: number
    supplierId?: string | null
    customerId?: string | null
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalCreateOrConnectWithoutTransactionInput = {
    where: CashDisbursementsJournalWhereUniqueInput
    create: XOR<CashDisbursementsJournalCreateWithoutTransactionInput, CashDisbursementsJournalUncheckedCreateWithoutTransactionInput>
  }

  export type CashDisbursementsJournalCreateManyTransactionInputEnvelope = {
    data: Enumerable<CashDisbursementsJournalCreateManyTransactionInput>
    skipDuplicates?: boolean
  }

  export type CashReceiptsJournalCreateWithoutTransactionInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutCashReceiptsJournalInput
    supplier?: SupplierCreateNestedOneWithoutCashReceiptsJournalInput
    customer?: CustomerCreateNestedOneWithoutCashReceiptsJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalUncheckedCreateWithoutTransactionInput = {
    id?: string
    recorderId: number
    supplierId?: string | null
    customerId?: string | null
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalCreateOrConnectWithoutTransactionInput = {
    where: CashReceiptsJournalWhereUniqueInput
    create: XOR<CashReceiptsJournalCreateWithoutTransactionInput, CashReceiptsJournalUncheckedCreateWithoutTransactionInput>
  }

  export type CashReceiptsJournalCreateManyTransactionInputEnvelope = {
    data: Enumerable<CashReceiptsJournalCreateManyTransactionInput>
    skipDuplicates?: boolean
  }

  export type ReturnsInwardsJournalCreateWithoutTransactionInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutReturnsInwardsJournalInput
    customer: CustomerCreateNestedOneWithoutReturnsInwardsJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalUncheckedCreateWithoutTransactionInput = {
    id?: string
    recorderId: number
    customerId: string
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalCreateOrConnectWithoutTransactionInput = {
    where: ReturnsInwardsJournalWhereUniqueInput
    create: XOR<ReturnsInwardsJournalCreateWithoutTransactionInput, ReturnsInwardsJournalUncheckedCreateWithoutTransactionInput>
  }

  export type ReturnsInwardsJournalCreateManyTransactionInputEnvelope = {
    data: Enumerable<ReturnsInwardsJournalCreateManyTransactionInput>
    skipDuplicates?: boolean
  }

  export type ReturnsOutwardsJournalCreateWithoutTransactionInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutReturnsOutwardsJournalInput
    supplier: SupplierCreateNestedOneWithoutReturnsOutwardsJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalUncheckedCreateWithoutTransactionInput = {
    id?: string
    recorderId: number
    supplierId: string
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalCreateOrConnectWithoutTransactionInput = {
    where: ReturnsOutwardsJournalWhereUniqueInput
    create: XOR<ReturnsOutwardsJournalCreateWithoutTransactionInput, ReturnsOutwardsJournalUncheckedCreateWithoutTransactionInput>
  }

  export type ReturnsOutwardsJournalCreateManyTransactionInputEnvelope = {
    data: Enumerable<ReturnsOutwardsJournalCreateManyTransactionInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTransactionInput = {
    update: XOR<UserUpdateWithoutTransactionInput, UserUncheckedUpdateWithoutTransactionInput>
    create: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
  }

  export type UserUpdateWithoutTransactionInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoiceUpdateManyWithoutCashierNestedInput
    journal?: JournalUpdateManyWithoutRecorderNestedInput
    action?: ActionUpdateManyWithoutUserNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutRecorderNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutRecorderNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutRecorderNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutRecorderNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutRecorderNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutRecorderNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoiceUncheckedUpdateManyWithoutCashierNestedInput
    journal?: JournalUncheckedUpdateManyWithoutRecorderNestedInput
    action?: ActionUncheckedUpdateManyWithoutUserNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutRecorderNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutRecorderNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput
  }

  export type CustomerUpsertWithoutTransactionInput = {
    update: XOR<CustomerUpdateWithoutTransactionInput, CustomerUncheckedUpdateWithoutTransactionInput>
    create: XOR<CustomerCreateWithoutTransactionInput, CustomerUncheckedCreateWithoutTransactionInput>
  }

  export type CustomerUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateManyWithoutCustomersNestedInput
    invoice?: invoiceUpdateManyWithoutCustomerNestedInput
    Journal?: JournalUpdateManyWithoutCustomerNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutCustomerNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutCustomerNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutCustomerNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUncheckedUpdateManyWithoutCustomersNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutCustomerNestedInput
    Journal?: JournalUncheckedUpdateManyWithoutCustomerNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutCustomerNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutCustomerNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutCustomerNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type SupplierUpsertWithoutTransactionsInput = {
    update: XOR<SupplierUpdateWithoutTransactionsInput, SupplierUncheckedUpdateWithoutTransactionsInput>
    create: XOR<SupplierCreateWithoutTransactionsInput, SupplierUncheckedCreateWithoutTransactionsInput>
  }

  export type SupplierUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutSuppliersNestedInput
    product?: ProductUpdateManyWithoutSupplierNestedInput
    invoice?: invoiceUpdateManyWithoutSupplierNestedInput
    Journal?: JournalUpdateManyWithoutSupplierNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutSupplierNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutSupplierNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutSupplierNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutSuppliersNestedInput
    product?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutSupplierNestedInput
    Journal?: JournalUncheckedUpdateManyWithoutSupplierNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutSupplierNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutSupplierNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutSupplierNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutTransactionInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutTransactionInput, PaymentUncheckedUpdateWithoutTransactionInput>
    create: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutTransactionInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutTransactionInput, PaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type PaymentUpdateManyWithWhereWithoutTransactionInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPaymentsInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: Enumerable<PaymentScalarWhereInput>
    OR?: Enumerable<PaymentScalarWhereInput>
    NOT?: Enumerable<PaymentScalarWhereInput>
    id?: StringFilter | string
    paymentTypeId?: StringFilter | string
    currencyId?: StringFilter | string
    exchangeRateId?: StringFilter | string
    transactionId?: IntFilter | number
    paid?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type invoiceUpsertWithWhereUniqueWithoutTransactionInput = {
    where: invoiceWhereUniqueInput
    update: XOR<invoiceUpdateWithoutTransactionInput, invoiceUncheckedUpdateWithoutTransactionInput>
    create: XOR<invoiceCreateWithoutTransactionInput, invoiceUncheckedCreateWithoutTransactionInput>
  }

  export type invoiceUpdateWithWhereUniqueWithoutTransactionInput = {
    where: invoiceWhereUniqueInput
    data: XOR<invoiceUpdateWithoutTransactionInput, invoiceUncheckedUpdateWithoutTransactionInput>
  }

  export type invoiceUpdateManyWithWhereWithoutTransactionInput = {
    where: invoiceScalarWhereInput
    data: XOR<invoiceUpdateManyMutationInput, invoiceUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type JournalUpsertWithWhereUniqueWithoutTransactionInput = {
    where: JournalWhereUniqueInput
    update: XOR<JournalUpdateWithoutTransactionInput, JournalUncheckedUpdateWithoutTransactionInput>
    create: XOR<JournalCreateWithoutTransactionInput, JournalUncheckedCreateWithoutTransactionInput>
  }

  export type JournalUpdateWithWhereUniqueWithoutTransactionInput = {
    where: JournalWhereUniqueInput
    data: XOR<JournalUpdateWithoutTransactionInput, JournalUncheckedUpdateWithoutTransactionInput>
  }

  export type JournalUpdateManyWithWhereWithoutTransactionInput = {
    where: JournalScalarWhereInput
    data: XOR<JournalUpdateManyMutationInput, JournalUncheckedUpdateManyWithoutJournalInput>
  }

  export type SalesJournalUpsertWithWhereUniqueWithoutTransactionInput = {
    where: SalesJournalWhereUniqueInput
    update: XOR<SalesJournalUpdateWithoutTransactionInput, SalesJournalUncheckedUpdateWithoutTransactionInput>
    create: XOR<SalesJournalCreateWithoutTransactionInput, SalesJournalUncheckedCreateWithoutTransactionInput>
  }

  export type SalesJournalUpdateWithWhereUniqueWithoutTransactionInput = {
    where: SalesJournalWhereUniqueInput
    data: XOR<SalesJournalUpdateWithoutTransactionInput, SalesJournalUncheckedUpdateWithoutTransactionInput>
  }

  export type SalesJournalUpdateManyWithWhereWithoutTransactionInput = {
    where: SalesJournalScalarWhereInput
    data: XOR<SalesJournalUpdateManyMutationInput, SalesJournalUncheckedUpdateManyWithoutSalesJournalInput>
  }

  export type PurchasesJournalUpsertWithWhereUniqueWithoutTransactionInput = {
    where: PurchasesJournalWhereUniqueInput
    update: XOR<PurchasesJournalUpdateWithoutTransactionInput, PurchasesJournalUncheckedUpdateWithoutTransactionInput>
    create: XOR<PurchasesJournalCreateWithoutTransactionInput, PurchasesJournalUncheckedCreateWithoutTransactionInput>
  }

  export type PurchasesJournalUpdateWithWhereUniqueWithoutTransactionInput = {
    where: PurchasesJournalWhereUniqueInput
    data: XOR<PurchasesJournalUpdateWithoutTransactionInput, PurchasesJournalUncheckedUpdateWithoutTransactionInput>
  }

  export type PurchasesJournalUpdateManyWithWhereWithoutTransactionInput = {
    where: PurchasesJournalScalarWhereInput
    data: XOR<PurchasesJournalUpdateManyMutationInput, PurchasesJournalUncheckedUpdateManyWithoutPurchasesJournalInput>
  }

  export type CashDisbursementsJournalUpsertWithWhereUniqueWithoutTransactionInput = {
    where: CashDisbursementsJournalWhereUniqueInput
    update: XOR<CashDisbursementsJournalUpdateWithoutTransactionInput, CashDisbursementsJournalUncheckedUpdateWithoutTransactionInput>
    create: XOR<CashDisbursementsJournalCreateWithoutTransactionInput, CashDisbursementsJournalUncheckedCreateWithoutTransactionInput>
  }

  export type CashDisbursementsJournalUpdateWithWhereUniqueWithoutTransactionInput = {
    where: CashDisbursementsJournalWhereUniqueInput
    data: XOR<CashDisbursementsJournalUpdateWithoutTransactionInput, CashDisbursementsJournalUncheckedUpdateWithoutTransactionInput>
  }

  export type CashDisbursementsJournalUpdateManyWithWhereWithoutTransactionInput = {
    where: CashDisbursementsJournalScalarWhereInput
    data: XOR<CashDisbursementsJournalUpdateManyMutationInput, CashDisbursementsJournalUncheckedUpdateManyWithoutCashDisbursementsJournalInput>
  }

  export type CashReceiptsJournalUpsertWithWhereUniqueWithoutTransactionInput = {
    where: CashReceiptsJournalWhereUniqueInput
    update: XOR<CashReceiptsJournalUpdateWithoutTransactionInput, CashReceiptsJournalUncheckedUpdateWithoutTransactionInput>
    create: XOR<CashReceiptsJournalCreateWithoutTransactionInput, CashReceiptsJournalUncheckedCreateWithoutTransactionInput>
  }

  export type CashReceiptsJournalUpdateWithWhereUniqueWithoutTransactionInput = {
    where: CashReceiptsJournalWhereUniqueInput
    data: XOR<CashReceiptsJournalUpdateWithoutTransactionInput, CashReceiptsJournalUncheckedUpdateWithoutTransactionInput>
  }

  export type CashReceiptsJournalUpdateManyWithWhereWithoutTransactionInput = {
    where: CashReceiptsJournalScalarWhereInput
    data: XOR<CashReceiptsJournalUpdateManyMutationInput, CashReceiptsJournalUncheckedUpdateManyWithoutCashReceiptsJournalInput>
  }

  export type ReturnsInwardsJournalUpsertWithWhereUniqueWithoutTransactionInput = {
    where: ReturnsInwardsJournalWhereUniqueInput
    update: XOR<ReturnsInwardsJournalUpdateWithoutTransactionInput, ReturnsInwardsJournalUncheckedUpdateWithoutTransactionInput>
    create: XOR<ReturnsInwardsJournalCreateWithoutTransactionInput, ReturnsInwardsJournalUncheckedCreateWithoutTransactionInput>
  }

  export type ReturnsInwardsJournalUpdateWithWhereUniqueWithoutTransactionInput = {
    where: ReturnsInwardsJournalWhereUniqueInput
    data: XOR<ReturnsInwardsJournalUpdateWithoutTransactionInput, ReturnsInwardsJournalUncheckedUpdateWithoutTransactionInput>
  }

  export type ReturnsInwardsJournalUpdateManyWithWhereWithoutTransactionInput = {
    where: ReturnsInwardsJournalScalarWhereInput
    data: XOR<ReturnsInwardsJournalUpdateManyMutationInput, ReturnsInwardsJournalUncheckedUpdateManyWithoutReturnsInwardsJournalInput>
  }

  export type ReturnsOutwardsJournalUpsertWithWhereUniqueWithoutTransactionInput = {
    where: ReturnsOutwardsJournalWhereUniqueInput
    update: XOR<ReturnsOutwardsJournalUpdateWithoutTransactionInput, ReturnsOutwardsJournalUncheckedUpdateWithoutTransactionInput>
    create: XOR<ReturnsOutwardsJournalCreateWithoutTransactionInput, ReturnsOutwardsJournalUncheckedCreateWithoutTransactionInput>
  }

  export type ReturnsOutwardsJournalUpdateWithWhereUniqueWithoutTransactionInput = {
    where: ReturnsOutwardsJournalWhereUniqueInput
    data: XOR<ReturnsOutwardsJournalUpdateWithoutTransactionInput, ReturnsOutwardsJournalUncheckedUpdateWithoutTransactionInput>
  }

  export type ReturnsOutwardsJournalUpdateManyWithWhereWithoutTransactionInput = {
    where: ReturnsOutwardsJournalScalarWhereInput
    data: XOR<ReturnsOutwardsJournalUpdateManyMutationInput, ReturnsOutwardsJournalUncheckedUpdateManyWithoutReturnsOutwardsJournalInput>
  }

  export type PaymentTypeCreateWithoutPaymentInput = {
    id?: string
    paymentTypeName: string
    charges: Decimal | DecimalJsLike | number | string
    tax?: TaxCreateNestedManyWithoutPaymentTypeInput
    discount: Decimal | DecimalJsLike | number | string
  }

  export type PaymentTypeUncheckedCreateWithoutPaymentInput = {
    id?: string
    paymentTypeName: string
    charges: Decimal | DecimalJsLike | number | string
    tax?: TaxUncheckedCreateNestedManyWithoutPaymentTypeInput
    discount: Decimal | DecimalJsLike | number | string
  }

  export type PaymentTypeCreateOrConnectWithoutPaymentInput = {
    where: PaymentTypeWhereUniqueInput
    create: XOR<PaymentTypeCreateWithoutPaymentInput, PaymentTypeUncheckedCreateWithoutPaymentInput>
  }

  export type currencyCreateWithoutPaymentsInput = {
    id?: string
    currencyName: string
    updatedAt?: Date | string
    createdAt?: Date | string
    baseCurrency?: baseCurrencyCreateNestedManyWithoutCurrencyInput
    exchangeRates?: exchangeRatesCreateNestedManyWithoutCurrencyInput
    tax?: TaxCreateNestedManyWithoutCurrencyInput
  }

  export type currencyUncheckedCreateWithoutPaymentsInput = {
    id?: string
    currencyName: string
    updatedAt?: Date | string
    createdAt?: Date | string
    baseCurrency?: baseCurrencyUncheckedCreateNestedManyWithoutCurrencyInput
    exchangeRates?: exchangeRatesUncheckedCreateNestedManyWithoutCurrencyInput
    tax?: TaxUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type currencyCreateOrConnectWithoutPaymentsInput = {
    where: currencyWhereUniqueInput
    create: XOR<currencyCreateWithoutPaymentsInput, currencyUncheckedCreateWithoutPaymentsInput>
  }

  export type exchangeRatesCreateWithoutPaymentsInput = {
    id?: string
    exchangeRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    active?: boolean
    baseCurrency: baseCurrencyCreateNestedOneWithoutExchangeRatesInput
    currency: currencyCreateNestedOneWithoutExchangeRatesInput
    prices?: PricesCreateNestedManyWithoutExchangeRatesInput
  }

  export type exchangeRatesUncheckedCreateWithoutPaymentsInput = {
    id?: string
    exchangeRate: Decimal | DecimalJsLike | number | string
    currencyId: string
    createdAt?: Date | string
    baseCurrencyId: string
    active?: boolean
    prices?: PricesUncheckedCreateNestedManyWithoutExchangeRatesInput
  }

  export type exchangeRatesCreateOrConnectWithoutPaymentsInput = {
    where: exchangeRatesWhereUniqueInput
    create: XOR<exchangeRatesCreateWithoutPaymentsInput, exchangeRatesUncheckedCreateWithoutPaymentsInput>
  }

  export type TransactionCreateWithoutPaymentsInput = {
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    errorDescription?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    users: UserCreateNestedOneWithoutTransactionInput
    customer?: CustomerCreateNestedOneWithoutTransactionInput
    supplier?: SupplierCreateNestedOneWithoutTransactionsInput
    invoice?: invoiceCreateNestedManyWithoutTransactionInput
    journal?: JournalCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutPaymentsInput = {
    id?: number
    initiatedBy: number
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    supplierId?: string | null
    errorDescription?: string | null
    customerId?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    invoice?: invoiceUncheckedCreateNestedManyWithoutTransactionInput
    journal?: JournalUncheckedCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutPaymentsInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPaymentsInput, TransactionUncheckedCreateWithoutPaymentsInput>
  }

  export type PaymentTypeUpsertWithoutPaymentInput = {
    update: XOR<PaymentTypeUpdateWithoutPaymentInput, PaymentTypeUncheckedUpdateWithoutPaymentInput>
    create: XOR<PaymentTypeCreateWithoutPaymentInput, PaymentTypeUncheckedCreateWithoutPaymentInput>
  }

  export type PaymentTypeUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentTypeName?: StringFieldUpdateOperationsInput | string
    charges?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: TaxUpdateManyWithoutPaymentTypeNestedInput
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentTypeUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentTypeName?: StringFieldUpdateOperationsInput | string
    charges?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: TaxUncheckedUpdateManyWithoutPaymentTypeNestedInput
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type currencyUpsertWithoutPaymentsInput = {
    update: XOR<currencyUpdateWithoutPaymentsInput, currencyUncheckedUpdateWithoutPaymentsInput>
    create: XOR<currencyCreateWithoutPaymentsInput, currencyUncheckedCreateWithoutPaymentsInput>
  }

  export type currencyUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseCurrency?: baseCurrencyUpdateManyWithoutCurrencyNestedInput
    exchangeRates?: exchangeRatesUpdateManyWithoutCurrencyNestedInput
    tax?: TaxUpdateManyWithoutCurrencyNestedInput
  }

  export type currencyUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseCurrency?: baseCurrencyUncheckedUpdateManyWithoutCurrencyNestedInput
    exchangeRates?: exchangeRatesUncheckedUpdateManyWithoutCurrencyNestedInput
    tax?: TaxUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type exchangeRatesUpsertWithoutPaymentsInput = {
    update: XOR<exchangeRatesUpdateWithoutPaymentsInput, exchangeRatesUncheckedUpdateWithoutPaymentsInput>
    create: XOR<exchangeRatesCreateWithoutPaymentsInput, exchangeRatesUncheckedCreateWithoutPaymentsInput>
  }

  export type exchangeRatesUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    baseCurrency?: baseCurrencyUpdateOneRequiredWithoutExchangeRatesNestedInput
    currency?: currencyUpdateOneRequiredWithoutExchangeRatesNestedInput
    prices?: PricesUpdateManyWithoutExchangeRatesNestedInput
  }

  export type exchangeRatesUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseCurrencyId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    prices?: PricesUncheckedUpdateManyWithoutExchangeRatesNestedInput
  }

  export type TransactionUpsertWithoutPaymentsInput = {
    update: XOR<TransactionUpdateWithoutPaymentsInput, TransactionUncheckedUpdateWithoutPaymentsInput>
    create: XOR<TransactionCreateWithoutPaymentsInput, TransactionUncheckedCreateWithoutPaymentsInput>
  }

  export type TransactionUpdateWithoutPaymentsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    users?: UserUpdateOneRequiredWithoutTransactionNestedInput
    customer?: CustomerUpdateOneWithoutTransactionNestedInput
    supplier?: SupplierUpdateOneWithoutTransactionsNestedInput
    invoice?: invoiceUpdateManyWithoutTransactionNestedInput
    journal?: JournalUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    initiatedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    invoice?: invoiceUncheckedUpdateManyWithoutTransactionNestedInput
    journal?: JournalUncheckedUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type PaymentCreateWithoutPaymentTypeInput = {
    id?: string
    paid: Decimal | DecimalJsLike | number | string
    currency: currencyCreateNestedOneWithoutPaymentsInput
    exchangeRates: exchangeRatesCreateNestedOneWithoutPaymentsInput
    transaction: TransactionCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutPaymentTypeInput = {
    id?: string
    currencyId: string
    exchangeRateId: string
    transactionId: number
    paid: Decimal | DecimalJsLike | number | string
  }

  export type PaymentCreateOrConnectWithoutPaymentTypeInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutPaymentTypeInput, PaymentUncheckedCreateWithoutPaymentTypeInput>
  }

  export type PaymentCreateManyPaymentTypeInputEnvelope = {
    data: Enumerable<PaymentCreateManyPaymentTypeInput>
    skipDuplicates?: boolean
  }

  export type TaxCreateWithoutPaymentTypeInput = {
    id?: string
    taxName: string
    taxRate: string
    startAmount: Decimal | DecimalJsLike | number | string
    endAmount: Decimal | DecimalJsLike | number | string
    active?: boolean
    startDate: Date | string
    endDate: Date | string
    currency?: currencyCreateNestedManyWithoutTaxInput
    product?: ProductCreateNestedManyWithoutTaxInput
    invoice?: invoiceCreateNestedManyWithoutTaxInput
    productGroup?: ProductGroupCreateNestedManyWithoutTaxInput
  }

  export type TaxUncheckedCreateWithoutPaymentTypeInput = {
    id?: string
    taxName: string
    taxRate: string
    startAmount: Decimal | DecimalJsLike | number | string
    endAmount: Decimal | DecimalJsLike | number | string
    active?: boolean
    startDate: Date | string
    endDate: Date | string
    currency?: currencyUncheckedCreateNestedManyWithoutTaxInput
    product?: ProductUncheckedCreateNestedManyWithoutTaxInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutTaxInput
    productGroup?: ProductGroupUncheckedCreateNestedManyWithoutTaxInput
  }

  export type TaxCreateOrConnectWithoutPaymentTypeInput = {
    where: TaxWhereUniqueInput
    create: XOR<TaxCreateWithoutPaymentTypeInput, TaxUncheckedCreateWithoutPaymentTypeInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutPaymentTypeInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutPaymentTypeInput, PaymentUncheckedUpdateWithoutPaymentTypeInput>
    create: XOR<PaymentCreateWithoutPaymentTypeInput, PaymentUncheckedCreateWithoutPaymentTypeInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutPaymentTypeInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutPaymentTypeInput, PaymentUncheckedUpdateWithoutPaymentTypeInput>
  }

  export type PaymentUpdateManyWithWhereWithoutPaymentTypeInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPaymentInput>
  }

  export type TaxUpsertWithWhereUniqueWithoutPaymentTypeInput = {
    where: TaxWhereUniqueInput
    update: XOR<TaxUpdateWithoutPaymentTypeInput, TaxUncheckedUpdateWithoutPaymentTypeInput>
    create: XOR<TaxCreateWithoutPaymentTypeInput, TaxUncheckedCreateWithoutPaymentTypeInput>
  }

  export type TaxUpdateWithWhereUniqueWithoutPaymentTypeInput = {
    where: TaxWhereUniqueInput
    data: XOR<TaxUpdateWithoutPaymentTypeInput, TaxUncheckedUpdateWithoutPaymentTypeInput>
  }

  export type TaxUpdateManyWithWhereWithoutPaymentTypeInput = {
    where: TaxScalarWhereInput
    data: XOR<TaxUpdateManyMutationInput, TaxUncheckedUpdateManyWithoutTaxInput>
  }

  export type TaxScalarWhereInput = {
    AND?: Enumerable<TaxScalarWhereInput>
    OR?: Enumerable<TaxScalarWhereInput>
    NOT?: Enumerable<TaxScalarWhereInput>
    id?: StringFilter | string
    taxName?: StringFilter | string
    taxRate?: StringFilter | string
    startAmount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    endAmount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    active?: BoolFilter | boolean
    startDate?: DateTimeFilter | Date | string
    endDate?: DateTimeFilter | Date | string
  }

  export type PaymentTypeCreateWithoutTaxInput = {
    id?: string
    paymentTypeName: string
    payment?: PaymentCreateNestedManyWithoutPaymentTypeInput
    charges: Decimal | DecimalJsLike | number | string
    discount: Decimal | DecimalJsLike | number | string
  }

  export type PaymentTypeUncheckedCreateWithoutTaxInput = {
    id?: string
    paymentTypeName: string
    payment?: PaymentUncheckedCreateNestedManyWithoutPaymentTypeInput
    charges: Decimal | DecimalJsLike | number | string
    discount: Decimal | DecimalJsLike | number | string
  }

  export type PaymentTypeCreateOrConnectWithoutTaxInput = {
    where: PaymentTypeWhereUniqueInput
    create: XOR<PaymentTypeCreateWithoutTaxInput, PaymentTypeUncheckedCreateWithoutTaxInput>
  }

  export type currencyCreateWithoutTaxInput = {
    id?: string
    currencyName: string
    updatedAt?: Date | string
    createdAt?: Date | string
    baseCurrency?: baseCurrencyCreateNestedManyWithoutCurrencyInput
    exchangeRates?: exchangeRatesCreateNestedManyWithoutCurrencyInput
    payments?: PaymentCreateNestedManyWithoutCurrencyInput
  }

  export type currencyUncheckedCreateWithoutTaxInput = {
    id?: string
    currencyName: string
    updatedAt?: Date | string
    createdAt?: Date | string
    baseCurrency?: baseCurrencyUncheckedCreateNestedManyWithoutCurrencyInput
    exchangeRates?: exchangeRatesUncheckedCreateNestedManyWithoutCurrencyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type currencyCreateOrConnectWithoutTaxInput = {
    where: currencyWhereUniqueInput
    create: XOR<currencyCreateWithoutTaxInput, currencyUncheckedCreateWithoutTaxInput>
  }

  export type ProductCreateWithoutTaxInput = {
    id?: string
    barcode: string
    productName: string
    measurementUnit: MeasurementUnit
    expiryDate: Date | string
    measurementAmount: number
    cost: Decimal | DecimalJsLike | number | string
    quantity: number
    productGroup?: ProductGroupCreateNestedOneWithoutProductInput
    updatedAt?: Date | string
    createdAt?: Date | string
    depleted?: boolean
    disposed?: boolean
    supplier?: SupplierCreateNestedOneWithoutProductInput
    disposals?: disposalsCreateNestedManyWithoutProductsInput
    price?: PricesCreateNestedManyWithoutProductInput
    promotion?: PromotionsCreateNestedManyWithoutProductInput
    invoice?: invoiceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTaxInput = {
    id?: string
    barcode: string
    productName: string
    measurementUnit: MeasurementUnit
    expiryDate: Date | string
    measurementAmount: number
    cost: Decimal | DecimalJsLike | number | string
    quantity: number
    supplierId?: string | null
    productGroupId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    depleted?: boolean
    disposed?: boolean
    disposals?: disposalsUncheckedCreateNestedManyWithoutProductsInput
    price?: PricesUncheckedCreateNestedManyWithoutProductInput
    promotion?: PromotionsUncheckedCreateNestedManyWithoutProductInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTaxInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTaxInput, ProductUncheckedCreateWithoutTaxInput>
  }

  export type invoiceCreateWithoutTaxInput = {
    id?: string
    discount?: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cashier: UserCreateNestedOneWithoutInvoiceInput
    customer?: CustomerCreateNestedOneWithoutInvoiceInput
    product: ProductCreateNestedOneWithoutInvoiceInput
    transaction: TransactionCreateNestedOneWithoutInvoiceInput
    Supplier?: SupplierCreateNestedOneWithoutInvoiceInput
  }

  export type invoiceUncheckedCreateWithoutTaxInput = {
    id?: string
    productId: string
    discount?: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    transactionId: number
    cashierId: number
    customerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierId?: string | null
  }

  export type invoiceCreateOrConnectWithoutTaxInput = {
    where: invoiceWhereUniqueInput
    create: XOR<invoiceCreateWithoutTaxInput, invoiceUncheckedCreateWithoutTaxInput>
  }

  export type ProductGroupCreateWithoutTaxInput = {
    id?: string
    product?: ProductCreateNestedManyWithoutProductGroupInput
    Promotions?: PromotionsCreateNestedManyWithoutProductGroupInput
  }

  export type ProductGroupUncheckedCreateWithoutTaxInput = {
    id?: string
    product?: ProductUncheckedCreateNestedManyWithoutProductGroupInput
    Promotions?: PromotionsUncheckedCreateNestedManyWithoutProductGroupInput
  }

  export type ProductGroupCreateOrConnectWithoutTaxInput = {
    where: ProductGroupWhereUniqueInput
    create: XOR<ProductGroupCreateWithoutTaxInput, ProductGroupUncheckedCreateWithoutTaxInput>
  }

  export type ProductGroupCreateManyTaxInputEnvelope = {
    data: Enumerable<ProductGroupCreateManyTaxInput>
    skipDuplicates?: boolean
  }

  export type PaymentTypeUpsertWithWhereUniqueWithoutTaxInput = {
    where: PaymentTypeWhereUniqueInput
    update: XOR<PaymentTypeUpdateWithoutTaxInput, PaymentTypeUncheckedUpdateWithoutTaxInput>
    create: XOR<PaymentTypeCreateWithoutTaxInput, PaymentTypeUncheckedCreateWithoutTaxInput>
  }

  export type PaymentTypeUpdateWithWhereUniqueWithoutTaxInput = {
    where: PaymentTypeWhereUniqueInput
    data: XOR<PaymentTypeUpdateWithoutTaxInput, PaymentTypeUncheckedUpdateWithoutTaxInput>
  }

  export type PaymentTypeUpdateManyWithWhereWithoutTaxInput = {
    where: PaymentTypeScalarWhereInput
    data: XOR<PaymentTypeUpdateManyMutationInput, PaymentTypeUncheckedUpdateManyWithoutPaymentTypeInput>
  }

  export type PaymentTypeScalarWhereInput = {
    AND?: Enumerable<PaymentTypeScalarWhereInput>
    OR?: Enumerable<PaymentTypeScalarWhereInput>
    NOT?: Enumerable<PaymentTypeScalarWhereInput>
    id?: StringFilter | string
    paymentTypeName?: StringFilter | string
    charges?: DecimalFilter | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type currencyUpsertWithWhereUniqueWithoutTaxInput = {
    where: currencyWhereUniqueInput
    update: XOR<currencyUpdateWithoutTaxInput, currencyUncheckedUpdateWithoutTaxInput>
    create: XOR<currencyCreateWithoutTaxInput, currencyUncheckedCreateWithoutTaxInput>
  }

  export type currencyUpdateWithWhereUniqueWithoutTaxInput = {
    where: currencyWhereUniqueInput
    data: XOR<currencyUpdateWithoutTaxInput, currencyUncheckedUpdateWithoutTaxInput>
  }

  export type currencyUpdateManyWithWhereWithoutTaxInput = {
    where: currencyScalarWhereInput
    data: XOR<currencyUpdateManyMutationInput, currencyUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type currencyScalarWhereInput = {
    AND?: Enumerable<currencyScalarWhereInput>
    OR?: Enumerable<currencyScalarWhereInput>
    NOT?: Enumerable<currencyScalarWhereInput>
    id?: StringFilter | string
    currencyName?: StringFilter | string
    updatedAt?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutTaxInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutTaxInput, ProductUncheckedUpdateWithoutTaxInput>
    create: XOR<ProductCreateWithoutTaxInput, ProductUncheckedCreateWithoutTaxInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutTaxInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutTaxInput, ProductUncheckedUpdateWithoutTaxInput>
  }

  export type ProductUpdateManyWithWhereWithoutTaxInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductScalarWhereInput = {
    AND?: Enumerable<ProductScalarWhereInput>
    OR?: Enumerable<ProductScalarWhereInput>
    NOT?: Enumerable<ProductScalarWhereInput>
    id?: StringFilter | string
    barcode?: StringFilter | string
    productName?: StringFilter | string
    measurementUnit?: EnumMeasurementUnitFilter | MeasurementUnit
    expiryDate?: DateTimeFilter | Date | string
    measurementAmount?: IntFilter | number
    cost?: DecimalFilter | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter | number
    supplierId?: StringNullableFilter | string | null
    productGroupId?: StringNullableFilter | string | null
    updatedAt?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    depleted?: BoolFilter | boolean
    disposed?: BoolFilter | boolean
  }

  export type invoiceUpsertWithWhereUniqueWithoutTaxInput = {
    where: invoiceWhereUniqueInput
    update: XOR<invoiceUpdateWithoutTaxInput, invoiceUncheckedUpdateWithoutTaxInput>
    create: XOR<invoiceCreateWithoutTaxInput, invoiceUncheckedCreateWithoutTaxInput>
  }

  export type invoiceUpdateWithWhereUniqueWithoutTaxInput = {
    where: invoiceWhereUniqueInput
    data: XOR<invoiceUpdateWithoutTaxInput, invoiceUncheckedUpdateWithoutTaxInput>
  }

  export type invoiceUpdateManyWithWhereWithoutTaxInput = {
    where: invoiceScalarWhereInput
    data: XOR<invoiceUpdateManyMutationInput, invoiceUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type ProductGroupUpsertWithWhereUniqueWithoutTaxInput = {
    where: ProductGroupWhereUniqueInput
    update: XOR<ProductGroupUpdateWithoutTaxInput, ProductGroupUncheckedUpdateWithoutTaxInput>
    create: XOR<ProductGroupCreateWithoutTaxInput, ProductGroupUncheckedCreateWithoutTaxInput>
  }

  export type ProductGroupUpdateWithWhereUniqueWithoutTaxInput = {
    where: ProductGroupWhereUniqueInput
    data: XOR<ProductGroupUpdateWithoutTaxInput, ProductGroupUncheckedUpdateWithoutTaxInput>
  }

  export type ProductGroupUpdateManyWithWhereWithoutTaxInput = {
    where: ProductGroupScalarWhereInput
    data: XOR<ProductGroupUpdateManyMutationInput, ProductGroupUncheckedUpdateManyWithoutProductGroupInput>
  }

  export type ProductGroupScalarWhereInput = {
    AND?: Enumerable<ProductGroupScalarWhereInput>
    OR?: Enumerable<ProductGroupScalarWhereInput>
    NOT?: Enumerable<ProductGroupScalarWhereInput>
    id?: StringFilter | string
    taxId?: StringNullableFilter | string | null
  }

  export type ProductCreateWithoutPromotionInput = {
    id?: string
    barcode: string
    productName: string
    measurementUnit: MeasurementUnit
    expiryDate: Date | string
    measurementAmount: number
    cost: Decimal | DecimalJsLike | number | string
    quantity: number
    tax?: TaxCreateNestedManyWithoutProductInput
    productGroup?: ProductGroupCreateNestedOneWithoutProductInput
    updatedAt?: Date | string
    createdAt?: Date | string
    depleted?: boolean
    disposed?: boolean
    supplier?: SupplierCreateNestedOneWithoutProductInput
    disposals?: disposalsCreateNestedManyWithoutProductsInput
    price?: PricesCreateNestedManyWithoutProductInput
    invoice?: invoiceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPromotionInput = {
    id?: string
    barcode: string
    productName: string
    measurementUnit: MeasurementUnit
    expiryDate: Date | string
    measurementAmount: number
    cost: Decimal | DecimalJsLike | number | string
    quantity: number
    supplierId?: string | null
    tax?: TaxUncheckedCreateNestedManyWithoutProductInput
    productGroupId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    depleted?: boolean
    disposed?: boolean
    disposals?: disposalsUncheckedCreateNestedManyWithoutProductsInput
    price?: PricesUncheckedCreateNestedManyWithoutProductInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPromotionInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPromotionInput, ProductUncheckedCreateWithoutPromotionInput>
  }

  export type ProductGroupCreateWithoutPromotionsInput = {
    id?: string
    product?: ProductCreateNestedManyWithoutProductGroupInput
    Tax?: TaxCreateNestedOneWithoutProductGroupInput
  }

  export type ProductGroupUncheckedCreateWithoutPromotionsInput = {
    id?: string
    product?: ProductUncheckedCreateNestedManyWithoutProductGroupInput
    taxId?: string | null
  }

  export type ProductGroupCreateOrConnectWithoutPromotionsInput = {
    where: ProductGroupWhereUniqueInput
    create: XOR<ProductGroupCreateWithoutPromotionsInput, ProductGroupUncheckedCreateWithoutPromotionsInput>
  }

  export type ProductUpsertWithoutPromotionInput = {
    update: XOR<ProductUpdateWithoutPromotionInput, ProductUncheckedUpdateWithoutPromotionInput>
    create: XOR<ProductCreateWithoutPromotionInput, ProductUncheckedCreateWithoutPromotionInput>
  }

  export type ProductUpdateWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    measurementUnit?: EnumMeasurementUnitFieldUpdateOperationsInput | MeasurementUnit
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementAmount?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    tax?: TaxUpdateManyWithoutProductNestedInput
    productGroup?: ProductGroupUpdateOneWithoutProductNestedInput
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depleted?: BoolFieldUpdateOperationsInput | boolean
    disposed?: BoolFieldUpdateOperationsInput | boolean
    supplier?: SupplierUpdateOneWithoutProductNestedInput
    disposals?: disposalsUpdateManyWithoutProductsNestedInput
    price?: PricesUpdateManyWithoutProductNestedInput
    invoice?: invoiceUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    measurementUnit?: EnumMeasurementUnitFieldUpdateOperationsInput | MeasurementUnit
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementAmount?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: TaxUncheckedUpdateManyWithoutProductNestedInput
    productGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depleted?: BoolFieldUpdateOperationsInput | boolean
    disposed?: BoolFieldUpdateOperationsInput | boolean
    disposals?: disposalsUncheckedUpdateManyWithoutProductsNestedInput
    price?: PricesUncheckedUpdateManyWithoutProductNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductGroupUpsertWithoutPromotionsInput = {
    update: XOR<ProductGroupUpdateWithoutPromotionsInput, ProductGroupUncheckedUpdateWithoutPromotionsInput>
    create: XOR<ProductGroupCreateWithoutPromotionsInput, ProductGroupUncheckedCreateWithoutPromotionsInput>
  }

  export type ProductGroupUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateManyWithoutProductGroupNestedInput
    Tax?: TaxUpdateOneWithoutProductGroupNestedInput
  }

  export type ProductGroupUncheckedUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    product?: ProductUncheckedUpdateManyWithoutProductGroupNestedInput
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateWithoutProductGroupInput = {
    id?: string
    barcode: string
    productName: string
    measurementUnit: MeasurementUnit
    expiryDate: Date | string
    measurementAmount: number
    cost: Decimal | DecimalJsLike | number | string
    quantity: number
    tax?: TaxCreateNestedManyWithoutProductInput
    updatedAt?: Date | string
    createdAt?: Date | string
    depleted?: boolean
    disposed?: boolean
    supplier?: SupplierCreateNestedOneWithoutProductInput
    disposals?: disposalsCreateNestedManyWithoutProductsInput
    price?: PricesCreateNestedManyWithoutProductInput
    promotion?: PromotionsCreateNestedManyWithoutProductInput
    invoice?: invoiceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductGroupInput = {
    id?: string
    barcode: string
    productName: string
    measurementUnit: MeasurementUnit
    expiryDate: Date | string
    measurementAmount: number
    cost: Decimal | DecimalJsLike | number | string
    quantity: number
    supplierId?: string | null
    tax?: TaxUncheckedCreateNestedManyWithoutProductInput
    updatedAt?: Date | string
    createdAt?: Date | string
    depleted?: boolean
    disposed?: boolean
    disposals?: disposalsUncheckedCreateNestedManyWithoutProductsInput
    price?: PricesUncheckedCreateNestedManyWithoutProductInput
    promotion?: PromotionsUncheckedCreateNestedManyWithoutProductInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductGroupInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductGroupInput, ProductUncheckedCreateWithoutProductGroupInput>
  }

  export type ProductCreateManyProductGroupInputEnvelope = {
    data: Enumerable<ProductCreateManyProductGroupInput>
    skipDuplicates?: boolean
  }

  export type TaxCreateWithoutProductGroupInput = {
    id?: string
    taxName: string
    taxRate: string
    startAmount: Decimal | DecimalJsLike | number | string
    endAmount: Decimal | DecimalJsLike | number | string
    active?: boolean
    startDate: Date | string
    endDate: Date | string
    PaymentType?: PaymentTypeCreateNestedManyWithoutTaxInput
    currency?: currencyCreateNestedManyWithoutTaxInput
    product?: ProductCreateNestedManyWithoutTaxInput
    invoice?: invoiceCreateNestedManyWithoutTaxInput
  }

  export type TaxUncheckedCreateWithoutProductGroupInput = {
    id?: string
    taxName: string
    taxRate: string
    startAmount: Decimal | DecimalJsLike | number | string
    endAmount: Decimal | DecimalJsLike | number | string
    active?: boolean
    startDate: Date | string
    endDate: Date | string
    PaymentType?: PaymentTypeUncheckedCreateNestedManyWithoutTaxInput
    currency?: currencyUncheckedCreateNestedManyWithoutTaxInput
    product?: ProductUncheckedCreateNestedManyWithoutTaxInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutTaxInput
  }

  export type TaxCreateOrConnectWithoutProductGroupInput = {
    where: TaxWhereUniqueInput
    create: XOR<TaxCreateWithoutProductGroupInput, TaxUncheckedCreateWithoutProductGroupInput>
  }

  export type PromotionsCreateWithoutProductGroupInput = {
    id?: string
    product: ProductCreateNestedOneWithoutPromotionInput
    startDate: Date | string
    endDate: Date | string
    discountRate: Decimal | DecimalJsLike | number | string
  }

  export type PromotionsUncheckedCreateWithoutProductGroupInput = {
    id?: string
    productId: string
    startDate: Date | string
    endDate: Date | string
    discountRate: Decimal | DecimalJsLike | number | string
  }

  export type PromotionsCreateOrConnectWithoutProductGroupInput = {
    where: PromotionsWhereUniqueInput
    create: XOR<PromotionsCreateWithoutProductGroupInput, PromotionsUncheckedCreateWithoutProductGroupInput>
  }

  export type PromotionsCreateManyProductGroupInputEnvelope = {
    data: Enumerable<PromotionsCreateManyProductGroupInput>
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutProductGroupInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProductGroupInput, ProductUncheckedUpdateWithoutProductGroupInput>
    create: XOR<ProductCreateWithoutProductGroupInput, ProductUncheckedCreateWithoutProductGroupInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProductGroupInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProductGroupInput, ProductUncheckedUpdateWithoutProductGroupInput>
  }

  export type ProductUpdateManyWithWhereWithoutProductGroupInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductInput>
  }

  export type TaxUpsertWithoutProductGroupInput = {
    update: XOR<TaxUpdateWithoutProductGroupInput, TaxUncheckedUpdateWithoutProductGroupInput>
    create: XOR<TaxCreateWithoutProductGroupInput, TaxUncheckedCreateWithoutProductGroupInput>
  }

  export type TaxUpdateWithoutProductGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxName?: StringFieldUpdateOperationsInput | string
    taxRate?: StringFieldUpdateOperationsInput | string
    startAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentType?: PaymentTypeUpdateManyWithoutTaxNestedInput
    currency?: currencyUpdateManyWithoutTaxNestedInput
    product?: ProductUpdateManyWithoutTaxNestedInput
    invoice?: invoiceUpdateManyWithoutTaxNestedInput
  }

  export type TaxUncheckedUpdateWithoutProductGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxName?: StringFieldUpdateOperationsInput | string
    taxRate?: StringFieldUpdateOperationsInput | string
    startAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentType?: PaymentTypeUncheckedUpdateManyWithoutTaxNestedInput
    currency?: currencyUncheckedUpdateManyWithoutTaxNestedInput
    product?: ProductUncheckedUpdateManyWithoutTaxNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutTaxNestedInput
  }

  export type PromotionsUpsertWithWhereUniqueWithoutProductGroupInput = {
    where: PromotionsWhereUniqueInput
    update: XOR<PromotionsUpdateWithoutProductGroupInput, PromotionsUncheckedUpdateWithoutProductGroupInput>
    create: XOR<PromotionsCreateWithoutProductGroupInput, PromotionsUncheckedCreateWithoutProductGroupInput>
  }

  export type PromotionsUpdateWithWhereUniqueWithoutProductGroupInput = {
    where: PromotionsWhereUniqueInput
    data: XOR<PromotionsUpdateWithoutProductGroupInput, PromotionsUncheckedUpdateWithoutProductGroupInput>
  }

  export type PromotionsUpdateManyWithWhereWithoutProductGroupInput = {
    where: PromotionsScalarWhereInput
    data: XOR<PromotionsUpdateManyMutationInput, PromotionsUncheckedUpdateManyWithoutPromotionsInput>
  }

  export type PromotionsScalarWhereInput = {
    AND?: Enumerable<PromotionsScalarWhereInput>
    OR?: Enumerable<PromotionsScalarWhereInput>
    NOT?: Enumerable<PromotionsScalarWhereInput>
    id?: StringFilter | string
    productId?: StringFilter | string
    productGroupId?: StringFilter | string
    startDate?: DateTimeFilter | Date | string
    endDate?: DateTimeFilter | Date | string
    discountRate?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type TaxCreateWithoutProductInput = {
    id?: string
    taxName: string
    taxRate: string
    startAmount: Decimal | DecimalJsLike | number | string
    endAmount: Decimal | DecimalJsLike | number | string
    active?: boolean
    startDate: Date | string
    endDate: Date | string
    PaymentType?: PaymentTypeCreateNestedManyWithoutTaxInput
    currency?: currencyCreateNestedManyWithoutTaxInput
    invoice?: invoiceCreateNestedManyWithoutTaxInput
    productGroup?: ProductGroupCreateNestedManyWithoutTaxInput
  }

  export type TaxUncheckedCreateWithoutProductInput = {
    id?: string
    taxName: string
    taxRate: string
    startAmount: Decimal | DecimalJsLike | number | string
    endAmount: Decimal | DecimalJsLike | number | string
    active?: boolean
    startDate: Date | string
    endDate: Date | string
    PaymentType?: PaymentTypeUncheckedCreateNestedManyWithoutTaxInput
    currency?: currencyUncheckedCreateNestedManyWithoutTaxInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutTaxInput
    productGroup?: ProductGroupUncheckedCreateNestedManyWithoutTaxInput
  }

  export type TaxCreateOrConnectWithoutProductInput = {
    where: TaxWhereUniqueInput
    create: XOR<TaxCreateWithoutProductInput, TaxUncheckedCreateWithoutProductInput>
  }

  export type ProductGroupCreateWithoutProductInput = {
    id?: string
    Tax?: TaxCreateNestedOneWithoutProductGroupInput
    Promotions?: PromotionsCreateNestedManyWithoutProductGroupInput
  }

  export type ProductGroupUncheckedCreateWithoutProductInput = {
    id?: string
    taxId?: string | null
    Promotions?: PromotionsUncheckedCreateNestedManyWithoutProductGroupInput
  }

  export type ProductGroupCreateOrConnectWithoutProductInput = {
    where: ProductGroupWhereUniqueInput
    create: XOR<ProductGroupCreateWithoutProductInput, ProductGroupUncheckedCreateWithoutProductInput>
  }

  export type SupplierCreateWithoutProductInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
    address?: AddressCreateNestedManyWithoutSuppliersInput
    invoice?: invoiceCreateNestedManyWithoutSupplierInput
    transactions?: TransactionCreateNestedManyWithoutSupplierInput
    Journal?: JournalCreateNestedManyWithoutSupplierInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutSupplierInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutSupplierInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutSupplierInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutProductInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutSuppliersInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutSupplierInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSupplierInput
    Journal?: JournalUncheckedCreateNestedManyWithoutSupplierInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutSupplierInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutSupplierInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutSupplierInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutProductInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutProductInput, SupplierUncheckedCreateWithoutProductInput>
  }

  export type disposalsCreateWithoutProductsInput = {
    id?: string
    createdAt?: Date | string
    prices: PricesCreateNestedOneWithoutDisposalsInput
  }

  export type disposalsUncheckedCreateWithoutProductsInput = {
    id?: string
    priceId: string
    createdAt?: Date | string
  }

  export type disposalsCreateOrConnectWithoutProductsInput = {
    where: disposalsWhereUniqueInput
    create: XOR<disposalsCreateWithoutProductsInput, disposalsUncheckedCreateWithoutProductsInput>
  }

  export type disposalsCreateManyProductsInputEnvelope = {
    data: Enumerable<disposalsCreateManyProductsInput>
    skipDuplicates?: boolean
  }

  export type PricesCreateWithoutProductInput = {
    id?: string
    barcode: string
    price: Decimal | DecimalJsLike | number | string
    active: boolean
    exchangeRates: exchangeRatesCreateNestedOneWithoutPricesInput
    disposals?: disposalsCreateNestedManyWithoutPricesInput
  }

  export type PricesUncheckedCreateWithoutProductInput = {
    id?: string
    barcode: string
    price: Decimal | DecimalJsLike | number | string
    active: boolean
    exchangeRateId: string
    disposals?: disposalsUncheckedCreateNestedManyWithoutPricesInput
  }

  export type PricesCreateOrConnectWithoutProductInput = {
    where: PricesWhereUniqueInput
    create: XOR<PricesCreateWithoutProductInput, PricesUncheckedCreateWithoutProductInput>
  }

  export type PricesCreateManyProductInputEnvelope = {
    data: Enumerable<PricesCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type PromotionsCreateWithoutProductInput = {
    id?: string
    productGroup: ProductGroupCreateNestedOneWithoutPromotionsInput
    startDate: Date | string
    endDate: Date | string
    discountRate: Decimal | DecimalJsLike | number | string
  }

  export type PromotionsUncheckedCreateWithoutProductInput = {
    id?: string
    productGroupId: string
    startDate: Date | string
    endDate: Date | string
    discountRate: Decimal | DecimalJsLike | number | string
  }

  export type PromotionsCreateOrConnectWithoutProductInput = {
    where: PromotionsWhereUniqueInput
    create: XOR<PromotionsCreateWithoutProductInput, PromotionsUncheckedCreateWithoutProductInput>
  }

  export type PromotionsCreateManyProductInputEnvelope = {
    data: Enumerable<PromotionsCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type invoiceCreateWithoutProductInput = {
    id?: string
    discount?: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    tax?: TaxCreateNestedManyWithoutInvoiceInput
    createdAt?: Date | string
    updatedAt?: Date | string
    cashier: UserCreateNestedOneWithoutInvoiceInput
    customer?: CustomerCreateNestedOneWithoutInvoiceInput
    transaction: TransactionCreateNestedOneWithoutInvoiceInput
    Supplier?: SupplierCreateNestedOneWithoutInvoiceInput
  }

  export type invoiceUncheckedCreateWithoutProductInput = {
    id?: string
    discount?: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    transactionId: number
    cashierId: number
    tax?: TaxUncheckedCreateNestedManyWithoutInvoiceInput
    customerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierId?: string | null
  }

  export type invoiceCreateOrConnectWithoutProductInput = {
    where: invoiceWhereUniqueInput
    create: XOR<invoiceCreateWithoutProductInput, invoiceUncheckedCreateWithoutProductInput>
  }

  export type invoiceCreateManyProductInputEnvelope = {
    data: Enumerable<invoiceCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type TaxUpsertWithWhereUniqueWithoutProductInput = {
    where: TaxWhereUniqueInput
    update: XOR<TaxUpdateWithoutProductInput, TaxUncheckedUpdateWithoutProductInput>
    create: XOR<TaxCreateWithoutProductInput, TaxUncheckedCreateWithoutProductInput>
  }

  export type TaxUpdateWithWhereUniqueWithoutProductInput = {
    where: TaxWhereUniqueInput
    data: XOR<TaxUpdateWithoutProductInput, TaxUncheckedUpdateWithoutProductInput>
  }

  export type TaxUpdateManyWithWhereWithoutProductInput = {
    where: TaxScalarWhereInput
    data: XOR<TaxUpdateManyMutationInput, TaxUncheckedUpdateManyWithoutTaxInput>
  }

  export type ProductGroupUpsertWithoutProductInput = {
    update: XOR<ProductGroupUpdateWithoutProductInput, ProductGroupUncheckedUpdateWithoutProductInput>
    create: XOR<ProductGroupCreateWithoutProductInput, ProductGroupUncheckedCreateWithoutProductInput>
  }

  export type ProductGroupUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    Tax?: TaxUpdateOneWithoutProductGroupNestedInput
    Promotions?: PromotionsUpdateManyWithoutProductGroupNestedInput
  }

  export type ProductGroupUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    Promotions?: PromotionsUncheckedUpdateManyWithoutProductGroupNestedInput
  }

  export type SupplierUpsertWithoutProductInput = {
    update: XOR<SupplierUpdateWithoutProductInput, SupplierUncheckedUpdateWithoutProductInput>
    create: XOR<SupplierCreateWithoutProductInput, SupplierUncheckedCreateWithoutProductInput>
  }

  export type SupplierUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutSuppliersNestedInput
    invoice?: invoiceUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUpdateManyWithoutSupplierNestedInput
    Journal?: JournalUpdateManyWithoutSupplierNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutSupplierNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutSupplierNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutSupplierNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutSuppliersNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSupplierNestedInput
    Journal?: JournalUncheckedUpdateManyWithoutSupplierNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutSupplierNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutSupplierNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutSupplierNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type disposalsUpsertWithWhereUniqueWithoutProductsInput = {
    where: disposalsWhereUniqueInput
    update: XOR<disposalsUpdateWithoutProductsInput, disposalsUncheckedUpdateWithoutProductsInput>
    create: XOR<disposalsCreateWithoutProductsInput, disposalsUncheckedCreateWithoutProductsInput>
  }

  export type disposalsUpdateWithWhereUniqueWithoutProductsInput = {
    where: disposalsWhereUniqueInput
    data: XOR<disposalsUpdateWithoutProductsInput, disposalsUncheckedUpdateWithoutProductsInput>
  }

  export type disposalsUpdateManyWithWhereWithoutProductsInput = {
    where: disposalsScalarWhereInput
    data: XOR<disposalsUpdateManyMutationInput, disposalsUncheckedUpdateManyWithoutDisposalsInput>
  }

  export type disposalsScalarWhereInput = {
    AND?: Enumerable<disposalsScalarWhereInput>
    OR?: Enumerable<disposalsScalarWhereInput>
    NOT?: Enumerable<disposalsScalarWhereInput>
    id?: StringFilter | string
    productId?: StringFilter | string
    priceId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type PricesUpsertWithWhereUniqueWithoutProductInput = {
    where: PricesWhereUniqueInput
    update: XOR<PricesUpdateWithoutProductInput, PricesUncheckedUpdateWithoutProductInput>
    create: XOR<PricesCreateWithoutProductInput, PricesUncheckedCreateWithoutProductInput>
  }

  export type PricesUpdateWithWhereUniqueWithoutProductInput = {
    where: PricesWhereUniqueInput
    data: XOR<PricesUpdateWithoutProductInput, PricesUncheckedUpdateWithoutProductInput>
  }

  export type PricesUpdateManyWithWhereWithoutProductInput = {
    where: PricesScalarWhereInput
    data: XOR<PricesUpdateManyMutationInput, PricesUncheckedUpdateManyWithoutPriceInput>
  }

  export type PricesScalarWhereInput = {
    AND?: Enumerable<PricesScalarWhereInput>
    OR?: Enumerable<PricesScalarWhereInput>
    NOT?: Enumerable<PricesScalarWhereInput>
    id?: StringFilter | string
    barcode?: StringFilter | string
    price?: DecimalFilter | Decimal | DecimalJsLike | number | string
    active?: BoolFilter | boolean
    exchangeRateId?: StringFilter | string
    productId?: StringNullableFilter | string | null
  }

  export type PromotionsUpsertWithWhereUniqueWithoutProductInput = {
    where: PromotionsWhereUniqueInput
    update: XOR<PromotionsUpdateWithoutProductInput, PromotionsUncheckedUpdateWithoutProductInput>
    create: XOR<PromotionsCreateWithoutProductInput, PromotionsUncheckedCreateWithoutProductInput>
  }

  export type PromotionsUpdateWithWhereUniqueWithoutProductInput = {
    where: PromotionsWhereUniqueInput
    data: XOR<PromotionsUpdateWithoutProductInput, PromotionsUncheckedUpdateWithoutProductInput>
  }

  export type PromotionsUpdateManyWithWhereWithoutProductInput = {
    where: PromotionsScalarWhereInput
    data: XOR<PromotionsUpdateManyMutationInput, PromotionsUncheckedUpdateManyWithoutPromotionInput>
  }

  export type invoiceUpsertWithWhereUniqueWithoutProductInput = {
    where: invoiceWhereUniqueInput
    update: XOR<invoiceUpdateWithoutProductInput, invoiceUncheckedUpdateWithoutProductInput>
    create: XOR<invoiceCreateWithoutProductInput, invoiceUncheckedCreateWithoutProductInput>
  }

  export type invoiceUpdateWithWhereUniqueWithoutProductInput = {
    where: invoiceWhereUniqueInput
    data: XOR<invoiceUpdateWithoutProductInput, invoiceUncheckedUpdateWithoutProductInput>
  }

  export type invoiceUpdateManyWithWhereWithoutProductInput = {
    where: invoiceScalarWhereInput
    data: XOR<invoiceUpdateManyMutationInput, invoiceUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type exchangeRatesCreateWithoutPricesInput = {
    id?: string
    exchangeRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    active?: boolean
    baseCurrency: baseCurrencyCreateNestedOneWithoutExchangeRatesInput
    currency: currencyCreateNestedOneWithoutExchangeRatesInput
    payments?: PaymentCreateNestedManyWithoutExchangeRatesInput
  }

  export type exchangeRatesUncheckedCreateWithoutPricesInput = {
    id?: string
    exchangeRate: Decimal | DecimalJsLike | number | string
    currencyId: string
    createdAt?: Date | string
    baseCurrencyId: string
    active?: boolean
    payments?: PaymentUncheckedCreateNestedManyWithoutExchangeRatesInput
  }

  export type exchangeRatesCreateOrConnectWithoutPricesInput = {
    where: exchangeRatesWhereUniqueInput
    create: XOR<exchangeRatesCreateWithoutPricesInput, exchangeRatesUncheckedCreateWithoutPricesInput>
  }

  export type ProductCreateWithoutPriceInput = {
    id?: string
    barcode: string
    productName: string
    measurementUnit: MeasurementUnit
    expiryDate: Date | string
    measurementAmount: number
    cost: Decimal | DecimalJsLike | number | string
    quantity: number
    tax?: TaxCreateNestedManyWithoutProductInput
    productGroup?: ProductGroupCreateNestedOneWithoutProductInput
    updatedAt?: Date | string
    createdAt?: Date | string
    depleted?: boolean
    disposed?: boolean
    supplier?: SupplierCreateNestedOneWithoutProductInput
    disposals?: disposalsCreateNestedManyWithoutProductsInput
    promotion?: PromotionsCreateNestedManyWithoutProductInput
    invoice?: invoiceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPriceInput = {
    id?: string
    barcode: string
    productName: string
    measurementUnit: MeasurementUnit
    expiryDate: Date | string
    measurementAmount: number
    cost: Decimal | DecimalJsLike | number | string
    quantity: number
    supplierId?: string | null
    tax?: TaxUncheckedCreateNestedManyWithoutProductInput
    productGroupId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    depleted?: boolean
    disposed?: boolean
    disposals?: disposalsUncheckedCreateNestedManyWithoutProductsInput
    promotion?: PromotionsUncheckedCreateNestedManyWithoutProductInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPriceInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPriceInput, ProductUncheckedCreateWithoutPriceInput>
  }

  export type disposalsCreateWithoutPricesInput = {
    id?: string
    createdAt?: Date | string
    products: ProductCreateNestedOneWithoutDisposalsInput
  }

  export type disposalsUncheckedCreateWithoutPricesInput = {
    id?: string
    productId: string
    createdAt?: Date | string
  }

  export type disposalsCreateOrConnectWithoutPricesInput = {
    where: disposalsWhereUniqueInput
    create: XOR<disposalsCreateWithoutPricesInput, disposalsUncheckedCreateWithoutPricesInput>
  }

  export type disposalsCreateManyPricesInputEnvelope = {
    data: Enumerable<disposalsCreateManyPricesInput>
    skipDuplicates?: boolean
  }

  export type exchangeRatesUpsertWithoutPricesInput = {
    update: XOR<exchangeRatesUpdateWithoutPricesInput, exchangeRatesUncheckedUpdateWithoutPricesInput>
    create: XOR<exchangeRatesCreateWithoutPricesInput, exchangeRatesUncheckedCreateWithoutPricesInput>
  }

  export type exchangeRatesUpdateWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    baseCurrency?: baseCurrencyUpdateOneRequiredWithoutExchangeRatesNestedInput
    currency?: currencyUpdateOneRequiredWithoutExchangeRatesNestedInput
    payments?: PaymentUpdateManyWithoutExchangeRatesNestedInput
  }

  export type exchangeRatesUncheckedUpdateWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseCurrencyId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentUncheckedUpdateManyWithoutExchangeRatesNestedInput
  }

  export type ProductUpsertWithoutPriceInput = {
    update: XOR<ProductUpdateWithoutPriceInput, ProductUncheckedUpdateWithoutPriceInput>
    create: XOR<ProductCreateWithoutPriceInput, ProductUncheckedCreateWithoutPriceInput>
  }

  export type ProductUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    measurementUnit?: EnumMeasurementUnitFieldUpdateOperationsInput | MeasurementUnit
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementAmount?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    tax?: TaxUpdateManyWithoutProductNestedInput
    productGroup?: ProductGroupUpdateOneWithoutProductNestedInput
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depleted?: BoolFieldUpdateOperationsInput | boolean
    disposed?: BoolFieldUpdateOperationsInput | boolean
    supplier?: SupplierUpdateOneWithoutProductNestedInput
    disposals?: disposalsUpdateManyWithoutProductsNestedInput
    promotion?: PromotionsUpdateManyWithoutProductNestedInput
    invoice?: invoiceUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    measurementUnit?: EnumMeasurementUnitFieldUpdateOperationsInput | MeasurementUnit
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementAmount?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: TaxUncheckedUpdateManyWithoutProductNestedInput
    productGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depleted?: BoolFieldUpdateOperationsInput | boolean
    disposed?: BoolFieldUpdateOperationsInput | boolean
    disposals?: disposalsUncheckedUpdateManyWithoutProductsNestedInput
    promotion?: PromotionsUncheckedUpdateManyWithoutProductNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutProductNestedInput
  }

  export type disposalsUpsertWithWhereUniqueWithoutPricesInput = {
    where: disposalsWhereUniqueInput
    update: XOR<disposalsUpdateWithoutPricesInput, disposalsUncheckedUpdateWithoutPricesInput>
    create: XOR<disposalsCreateWithoutPricesInput, disposalsUncheckedCreateWithoutPricesInput>
  }

  export type disposalsUpdateWithWhereUniqueWithoutPricesInput = {
    where: disposalsWhereUniqueInput
    data: XOR<disposalsUpdateWithoutPricesInput, disposalsUncheckedUpdateWithoutPricesInput>
  }

  export type disposalsUpdateManyWithWhereWithoutPricesInput = {
    where: disposalsScalarWhereInput
    data: XOR<disposalsUpdateManyMutationInput, disposalsUncheckedUpdateManyWithoutDisposalsInput>
  }

  export type TaxCreateWithoutInvoiceInput = {
    id?: string
    taxName: string
    taxRate: string
    startAmount: Decimal | DecimalJsLike | number | string
    endAmount: Decimal | DecimalJsLike | number | string
    active?: boolean
    startDate: Date | string
    endDate: Date | string
    PaymentType?: PaymentTypeCreateNestedManyWithoutTaxInput
    currency?: currencyCreateNestedManyWithoutTaxInput
    product?: ProductCreateNestedManyWithoutTaxInput
    productGroup?: ProductGroupCreateNestedManyWithoutTaxInput
  }

  export type TaxUncheckedCreateWithoutInvoiceInput = {
    id?: string
    taxName: string
    taxRate: string
    startAmount: Decimal | DecimalJsLike | number | string
    endAmount: Decimal | DecimalJsLike | number | string
    active?: boolean
    startDate: Date | string
    endDate: Date | string
    PaymentType?: PaymentTypeUncheckedCreateNestedManyWithoutTaxInput
    currency?: currencyUncheckedCreateNestedManyWithoutTaxInput
    product?: ProductUncheckedCreateNestedManyWithoutTaxInput
    productGroup?: ProductGroupUncheckedCreateNestedManyWithoutTaxInput
  }

  export type TaxCreateOrConnectWithoutInvoiceInput = {
    where: TaxWhereUniqueInput
    create: XOR<TaxCreateWithoutInvoiceInput, TaxUncheckedCreateWithoutInvoiceInput>
  }

  export type UserCreateWithoutInvoiceInput = {
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    journal?: JournalCreateNestedManyWithoutRecorderInput
    action?: ActionCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUsersInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutRecorderInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutRecorderInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutRecorderInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutRecorderInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutRecorderInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutRecorderInput
  }

  export type UserUncheckedCreateWithoutInvoiceInput = {
    id?: number
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    journal?: JournalUncheckedCreateNestedManyWithoutRecorderInput
    action?: ActionUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUsersInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutRecorderInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutRecorderInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutRecorderInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutRecorderInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutRecorderInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutRecorderInput
  }

  export type UserCreateOrConnectWithoutInvoiceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoiceInput, UserUncheckedCreateWithoutInvoiceInput>
  }

  export type CustomerCreateWithoutInvoiceInput = {
    id?: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    emailAddress?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    address?: AddressCreateNestedManyWithoutCustomersInput
    transaction?: TransactionCreateNestedManyWithoutCustomerInput
    Journal?: JournalCreateNestedManyWithoutCustomerInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutCustomerInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutCustomerInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutCustomerInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutInvoiceInput = {
    id?: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    emailAddress?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    address?: AddressUncheckedCreateNestedManyWithoutCustomersInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    Journal?: JournalUncheckedCreateNestedManyWithoutCustomerInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutCustomerInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutCustomerInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutCustomerInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutInvoiceInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutInvoiceInput, CustomerUncheckedCreateWithoutInvoiceInput>
  }

  export type ProductCreateWithoutInvoiceInput = {
    id?: string
    barcode: string
    productName: string
    measurementUnit: MeasurementUnit
    expiryDate: Date | string
    measurementAmount: number
    cost: Decimal | DecimalJsLike | number | string
    quantity: number
    tax?: TaxCreateNestedManyWithoutProductInput
    productGroup?: ProductGroupCreateNestedOneWithoutProductInput
    updatedAt?: Date | string
    createdAt?: Date | string
    depleted?: boolean
    disposed?: boolean
    supplier?: SupplierCreateNestedOneWithoutProductInput
    disposals?: disposalsCreateNestedManyWithoutProductsInput
    price?: PricesCreateNestedManyWithoutProductInput
    promotion?: PromotionsCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInvoiceInput = {
    id?: string
    barcode: string
    productName: string
    measurementUnit: MeasurementUnit
    expiryDate: Date | string
    measurementAmount: number
    cost: Decimal | DecimalJsLike | number | string
    quantity: number
    supplierId?: string | null
    tax?: TaxUncheckedCreateNestedManyWithoutProductInput
    productGroupId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    depleted?: boolean
    disposed?: boolean
    disposals?: disposalsUncheckedCreateNestedManyWithoutProductsInput
    price?: PricesUncheckedCreateNestedManyWithoutProductInput
    promotion?: PromotionsUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInvoiceInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInvoiceInput, ProductUncheckedCreateWithoutInvoiceInput>
  }

  export type TransactionCreateWithoutInvoiceInput = {
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    errorDescription?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    users: UserCreateNestedOneWithoutTransactionInput
    customer?: CustomerCreateNestedOneWithoutTransactionInput
    supplier?: SupplierCreateNestedOneWithoutTransactionsInput
    payments?: PaymentCreateNestedManyWithoutTransactionInput
    journal?: JournalCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutInvoiceInput = {
    id?: number
    initiatedBy: number
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    supplierId?: string | null
    errorDescription?: string | null
    customerId?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    payments?: PaymentUncheckedCreateNestedManyWithoutTransactionInput
    journal?: JournalUncheckedCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutInvoiceInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput>
  }

  export type SupplierCreateWithoutInvoiceInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
    address?: AddressCreateNestedManyWithoutSuppliersInput
    product?: ProductCreateNestedManyWithoutSupplierInput
    transactions?: TransactionCreateNestedManyWithoutSupplierInput
    Journal?: JournalCreateNestedManyWithoutSupplierInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutSupplierInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutSupplierInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutSupplierInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutInvoiceInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutSuppliersInput
    product?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSupplierInput
    Journal?: JournalUncheckedCreateNestedManyWithoutSupplierInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutSupplierInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutSupplierInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutSupplierInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutInvoiceInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutInvoiceInput, SupplierUncheckedCreateWithoutInvoiceInput>
  }

  export type TaxUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: TaxWhereUniqueInput
    update: XOR<TaxUpdateWithoutInvoiceInput, TaxUncheckedUpdateWithoutInvoiceInput>
    create: XOR<TaxCreateWithoutInvoiceInput, TaxUncheckedCreateWithoutInvoiceInput>
  }

  export type TaxUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: TaxWhereUniqueInput
    data: XOR<TaxUpdateWithoutInvoiceInput, TaxUncheckedUpdateWithoutInvoiceInput>
  }

  export type TaxUpdateManyWithWhereWithoutInvoiceInput = {
    where: TaxScalarWhereInput
    data: XOR<TaxUpdateManyMutationInput, TaxUncheckedUpdateManyWithoutTaxInput>
  }

  export type UserUpsertWithoutInvoiceInput = {
    update: XOR<UserUpdateWithoutInvoiceInput, UserUncheckedUpdateWithoutInvoiceInput>
    create: XOR<UserCreateWithoutInvoiceInput, UserUncheckedCreateWithoutInvoiceInput>
  }

  export type UserUpdateWithoutInvoiceInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: JournalUpdateManyWithoutRecorderNestedInput
    action?: ActionUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUsersNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutRecorderNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutRecorderNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutRecorderNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutRecorderNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutRecorderNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutRecorderNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: JournalUncheckedUpdateManyWithoutRecorderNestedInput
    action?: ActionUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUsersNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutRecorderNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutRecorderNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput
  }

  export type CustomerUpsertWithoutInvoiceInput = {
    update: XOR<CustomerUpdateWithoutInvoiceInput, CustomerUncheckedUpdateWithoutInvoiceInput>
    create: XOR<CustomerCreateWithoutInvoiceInput, CustomerUncheckedCreateWithoutInvoiceInput>
  }

  export type CustomerUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateManyWithoutCustomersNestedInput
    transaction?: TransactionUpdateManyWithoutCustomerNestedInput
    Journal?: JournalUpdateManyWithoutCustomerNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutCustomerNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutCustomerNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutCustomerNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUncheckedUpdateManyWithoutCustomersNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    Journal?: JournalUncheckedUpdateManyWithoutCustomerNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutCustomerNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutCustomerNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutCustomerNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ProductUpsertWithoutInvoiceInput = {
    update: XOR<ProductUpdateWithoutInvoiceInput, ProductUncheckedUpdateWithoutInvoiceInput>
    create: XOR<ProductCreateWithoutInvoiceInput, ProductUncheckedCreateWithoutInvoiceInput>
  }

  export type ProductUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    measurementUnit?: EnumMeasurementUnitFieldUpdateOperationsInput | MeasurementUnit
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementAmount?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    tax?: TaxUpdateManyWithoutProductNestedInput
    productGroup?: ProductGroupUpdateOneWithoutProductNestedInput
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depleted?: BoolFieldUpdateOperationsInput | boolean
    disposed?: BoolFieldUpdateOperationsInput | boolean
    supplier?: SupplierUpdateOneWithoutProductNestedInput
    disposals?: disposalsUpdateManyWithoutProductsNestedInput
    price?: PricesUpdateManyWithoutProductNestedInput
    promotion?: PromotionsUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    measurementUnit?: EnumMeasurementUnitFieldUpdateOperationsInput | MeasurementUnit
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementAmount?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: TaxUncheckedUpdateManyWithoutProductNestedInput
    productGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depleted?: BoolFieldUpdateOperationsInput | boolean
    disposed?: BoolFieldUpdateOperationsInput | boolean
    disposals?: disposalsUncheckedUpdateManyWithoutProductsNestedInput
    price?: PricesUncheckedUpdateManyWithoutProductNestedInput
    promotion?: PromotionsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type TransactionUpsertWithoutInvoiceInput = {
    update: XOR<TransactionUpdateWithoutInvoiceInput, TransactionUncheckedUpdateWithoutInvoiceInput>
    create: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput>
  }

  export type TransactionUpdateWithoutInvoiceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    users?: UserUpdateOneRequiredWithoutTransactionNestedInput
    customer?: CustomerUpdateOneWithoutTransactionNestedInput
    supplier?: SupplierUpdateOneWithoutTransactionsNestedInput
    payments?: PaymentUpdateManyWithoutTransactionNestedInput
    journal?: JournalUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    initiatedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    payments?: PaymentUncheckedUpdateManyWithoutTransactionNestedInput
    journal?: JournalUncheckedUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type SupplierUpsertWithoutInvoiceInput = {
    update: XOR<SupplierUpdateWithoutInvoiceInput, SupplierUncheckedUpdateWithoutInvoiceInput>
    create: XOR<SupplierCreateWithoutInvoiceInput, SupplierUncheckedCreateWithoutInvoiceInput>
  }

  export type SupplierUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutSuppliersNestedInput
    product?: ProductUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUpdateManyWithoutSupplierNestedInput
    Journal?: JournalUpdateManyWithoutSupplierNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutSupplierNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutSupplierNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutSupplierNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutSuppliersNestedInput
    product?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSupplierNestedInput
    Journal?: JournalUncheckedUpdateManyWithoutSupplierNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutSupplierNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutSupplierNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutSupplierNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type AddressCreateWithoutSuppliersInput = {
    id?: string
    street: string
    city: string
    country: string
    zip?: string | null
    customers?: CustomerCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutSuppliersInput = {
    id?: string
    customerId?: string | null
    street: string
    city: string
    country: string
    zip?: string | null
  }

  export type AddressCreateOrConnectWithoutSuppliersInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutSuppliersInput, AddressUncheckedCreateWithoutSuppliersInput>
  }

  export type AddressCreateManySuppliersInputEnvelope = {
    data: Enumerable<AddressCreateManySuppliersInput>
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutSupplierInput = {
    id?: string
    barcode: string
    productName: string
    measurementUnit: MeasurementUnit
    expiryDate: Date | string
    measurementAmount: number
    cost: Decimal | DecimalJsLike | number | string
    quantity: number
    tax?: TaxCreateNestedManyWithoutProductInput
    productGroup?: ProductGroupCreateNestedOneWithoutProductInput
    updatedAt?: Date | string
    createdAt?: Date | string
    depleted?: boolean
    disposed?: boolean
    disposals?: disposalsCreateNestedManyWithoutProductsInput
    price?: PricesCreateNestedManyWithoutProductInput
    promotion?: PromotionsCreateNestedManyWithoutProductInput
    invoice?: invoiceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSupplierInput = {
    id?: string
    barcode: string
    productName: string
    measurementUnit: MeasurementUnit
    expiryDate: Date | string
    measurementAmount: number
    cost: Decimal | DecimalJsLike | number | string
    quantity: number
    tax?: TaxUncheckedCreateNestedManyWithoutProductInput
    productGroupId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    depleted?: boolean
    disposed?: boolean
    disposals?: disposalsUncheckedCreateNestedManyWithoutProductsInput
    price?: PricesUncheckedCreateNestedManyWithoutProductInput
    promotion?: PromotionsUncheckedCreateNestedManyWithoutProductInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSupplierInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput>
  }

  export type ProductCreateManySupplierInputEnvelope = {
    data: Enumerable<ProductCreateManySupplierInput>
    skipDuplicates?: boolean
  }

  export type invoiceCreateWithoutSupplierInput = {
    id?: string
    discount?: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    tax?: TaxCreateNestedManyWithoutInvoiceInput
    createdAt?: Date | string
    updatedAt?: Date | string
    cashier: UserCreateNestedOneWithoutInvoiceInput
    customer?: CustomerCreateNestedOneWithoutInvoiceInput
    product: ProductCreateNestedOneWithoutInvoiceInput
    transaction: TransactionCreateNestedOneWithoutInvoiceInput
  }

  export type invoiceUncheckedCreateWithoutSupplierInput = {
    id?: string
    productId: string
    discount?: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    transactionId: number
    cashierId: number
    tax?: TaxUncheckedCreateNestedManyWithoutInvoiceInput
    customerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type invoiceCreateOrConnectWithoutSupplierInput = {
    where: invoiceWhereUniqueInput
    create: XOR<invoiceCreateWithoutSupplierInput, invoiceUncheckedCreateWithoutSupplierInput>
  }

  export type invoiceCreateManySupplierInputEnvelope = {
    data: Enumerable<invoiceCreateManySupplierInput>
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutSupplierInput = {
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    errorDescription?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    users: UserCreateNestedOneWithoutTransactionInput
    customer?: CustomerCreateNestedOneWithoutTransactionInput
    payments?: PaymentCreateNestedManyWithoutTransactionInput
    invoice?: invoiceCreateNestedManyWithoutTransactionInput
    journal?: JournalCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutSupplierInput = {
    id?: number
    initiatedBy: number
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    errorDescription?: string | null
    customerId?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    payments?: PaymentUncheckedCreateNestedManyWithoutTransactionInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutTransactionInput
    journal?: JournalUncheckedCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutSupplierInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutSupplierInput, TransactionUncheckedCreateWithoutSupplierInput>
  }

  export type TransactionCreateManySupplierInputEnvelope = {
    data: Enumerable<TransactionCreateManySupplierInput>
    skipDuplicates?: boolean
  }

  export type JournalCreateWithoutSupplierInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutJournalInput
    customer?: CustomerCreateNestedOneWithoutJournalInput
    transaction: TransactionCreateNestedOneWithoutJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type JournalUncheckedCreateWithoutSupplierInput = {
    id?: string
    recorderId: number
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type JournalCreateOrConnectWithoutSupplierInput = {
    where: JournalWhereUniqueInput
    create: XOR<JournalCreateWithoutSupplierInput, JournalUncheckedCreateWithoutSupplierInput>
  }

  export type JournalCreateManySupplierInputEnvelope = {
    data: Enumerable<JournalCreateManySupplierInput>
    skipDuplicates?: boolean
  }

  export type SalesJournalCreateWithoutSupplierInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutSalesJournalInput
    transaction: TransactionCreateNestedOneWithoutSalesJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalUncheckedCreateWithoutSupplierInput = {
    id?: string
    recorderId: number
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalCreateOrConnectWithoutSupplierInput = {
    where: SalesJournalWhereUniqueInput
    create: XOR<SalesJournalCreateWithoutSupplierInput, SalesJournalUncheckedCreateWithoutSupplierInput>
  }

  export type SalesJournalCreateManySupplierInputEnvelope = {
    data: Enumerable<SalesJournalCreateManySupplierInput>
    skipDuplicates?: boolean
  }

  export type CashDisbursementsJournalCreateWithoutSupplierInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutCashDisbursementsJournalInput
    customer?: CustomerCreateNestedOneWithoutCashDisbursementsJournalInput
    transaction: TransactionCreateNestedOneWithoutCashDisbursementsJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalUncheckedCreateWithoutSupplierInput = {
    id?: string
    recorderId: number
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalCreateOrConnectWithoutSupplierInput = {
    where: CashDisbursementsJournalWhereUniqueInput
    create: XOR<CashDisbursementsJournalCreateWithoutSupplierInput, CashDisbursementsJournalUncheckedCreateWithoutSupplierInput>
  }

  export type CashDisbursementsJournalCreateManySupplierInputEnvelope = {
    data: Enumerable<CashDisbursementsJournalCreateManySupplierInput>
    skipDuplicates?: boolean
  }

  export type CashReceiptsJournalCreateWithoutSupplierInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutCashReceiptsJournalInput
    customer?: CustomerCreateNestedOneWithoutCashReceiptsJournalInput
    transaction: TransactionCreateNestedOneWithoutCashReceiptsJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalUncheckedCreateWithoutSupplierInput = {
    id?: string
    recorderId: number
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalCreateOrConnectWithoutSupplierInput = {
    where: CashReceiptsJournalWhereUniqueInput
    create: XOR<CashReceiptsJournalCreateWithoutSupplierInput, CashReceiptsJournalUncheckedCreateWithoutSupplierInput>
  }

  export type CashReceiptsJournalCreateManySupplierInputEnvelope = {
    data: Enumerable<CashReceiptsJournalCreateManySupplierInput>
    skipDuplicates?: boolean
  }

  export type ReturnsOutwardsJournalCreateWithoutSupplierInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutReturnsOutwardsJournalInput
    transaction: TransactionCreateNestedOneWithoutReturnsOutwardsJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalUncheckedCreateWithoutSupplierInput = {
    id?: string
    recorderId: number
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalCreateOrConnectWithoutSupplierInput = {
    where: ReturnsOutwardsJournalWhereUniqueInput
    create: XOR<ReturnsOutwardsJournalCreateWithoutSupplierInput, ReturnsOutwardsJournalUncheckedCreateWithoutSupplierInput>
  }

  export type ReturnsOutwardsJournalCreateManySupplierInputEnvelope = {
    data: Enumerable<ReturnsOutwardsJournalCreateManySupplierInput>
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithWhereUniqueWithoutSuppliersInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutSuppliersInput, AddressUncheckedUpdateWithoutSuppliersInput>
    create: XOR<AddressCreateWithoutSuppliersInput, AddressUncheckedCreateWithoutSuppliersInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutSuppliersInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutSuppliersInput, AddressUncheckedUpdateWithoutSuppliersInput>
  }

  export type AddressUpdateManyWithWhereWithoutSuppliersInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutAddressInput>
  }

  export type AddressScalarWhereInput = {
    AND?: Enumerable<AddressScalarWhereInput>
    OR?: Enumerable<AddressScalarWhereInput>
    NOT?: Enumerable<AddressScalarWhereInput>
    id?: StringFilter | string
    supplierId?: StringNullableFilter | string | null
    customerId?: StringNullableFilter | string | null
    street?: StringFilter | string
    city?: StringFilter | string
    country?: StringFilter | string
    zip?: StringNullableFilter | string | null
  }

  export type ProductUpsertWithWhereUniqueWithoutSupplierInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutSupplierInput, ProductUncheckedUpdateWithoutSupplierInput>
    create: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutSupplierInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutSupplierInput, ProductUncheckedUpdateWithoutSupplierInput>
  }

  export type ProductUpdateManyWithWhereWithoutSupplierInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductInput>
  }

  export type invoiceUpsertWithWhereUniqueWithoutSupplierInput = {
    where: invoiceWhereUniqueInput
    update: XOR<invoiceUpdateWithoutSupplierInput, invoiceUncheckedUpdateWithoutSupplierInput>
    create: XOR<invoiceCreateWithoutSupplierInput, invoiceUncheckedCreateWithoutSupplierInput>
  }

  export type invoiceUpdateWithWhereUniqueWithoutSupplierInput = {
    where: invoiceWhereUniqueInput
    data: XOR<invoiceUpdateWithoutSupplierInput, invoiceUncheckedUpdateWithoutSupplierInput>
  }

  export type invoiceUpdateManyWithWhereWithoutSupplierInput = {
    where: invoiceScalarWhereInput
    data: XOR<invoiceUpdateManyMutationInput, invoiceUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutSupplierInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutSupplierInput, TransactionUncheckedUpdateWithoutSupplierInput>
    create: XOR<TransactionCreateWithoutSupplierInput, TransactionUncheckedCreateWithoutSupplierInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutSupplierInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutSupplierInput, TransactionUncheckedUpdateWithoutSupplierInput>
  }

  export type TransactionUpdateManyWithWhereWithoutSupplierInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTransactionsInput>
  }

  export type JournalUpsertWithWhereUniqueWithoutSupplierInput = {
    where: JournalWhereUniqueInput
    update: XOR<JournalUpdateWithoutSupplierInput, JournalUncheckedUpdateWithoutSupplierInput>
    create: XOR<JournalCreateWithoutSupplierInput, JournalUncheckedCreateWithoutSupplierInput>
  }

  export type JournalUpdateWithWhereUniqueWithoutSupplierInput = {
    where: JournalWhereUniqueInput
    data: XOR<JournalUpdateWithoutSupplierInput, JournalUncheckedUpdateWithoutSupplierInput>
  }

  export type JournalUpdateManyWithWhereWithoutSupplierInput = {
    where: JournalScalarWhereInput
    data: XOR<JournalUpdateManyMutationInput, JournalUncheckedUpdateManyWithoutJournalInput>
  }

  export type SalesJournalUpsertWithWhereUniqueWithoutSupplierInput = {
    where: SalesJournalWhereUniqueInput
    update: XOR<SalesJournalUpdateWithoutSupplierInput, SalesJournalUncheckedUpdateWithoutSupplierInput>
    create: XOR<SalesJournalCreateWithoutSupplierInput, SalesJournalUncheckedCreateWithoutSupplierInput>
  }

  export type SalesJournalUpdateWithWhereUniqueWithoutSupplierInput = {
    where: SalesJournalWhereUniqueInput
    data: XOR<SalesJournalUpdateWithoutSupplierInput, SalesJournalUncheckedUpdateWithoutSupplierInput>
  }

  export type SalesJournalUpdateManyWithWhereWithoutSupplierInput = {
    where: SalesJournalScalarWhereInput
    data: XOR<SalesJournalUpdateManyMutationInput, SalesJournalUncheckedUpdateManyWithoutSalesJournalInput>
  }

  export type CashDisbursementsJournalUpsertWithWhereUniqueWithoutSupplierInput = {
    where: CashDisbursementsJournalWhereUniqueInput
    update: XOR<CashDisbursementsJournalUpdateWithoutSupplierInput, CashDisbursementsJournalUncheckedUpdateWithoutSupplierInput>
    create: XOR<CashDisbursementsJournalCreateWithoutSupplierInput, CashDisbursementsJournalUncheckedCreateWithoutSupplierInput>
  }

  export type CashDisbursementsJournalUpdateWithWhereUniqueWithoutSupplierInput = {
    where: CashDisbursementsJournalWhereUniqueInput
    data: XOR<CashDisbursementsJournalUpdateWithoutSupplierInput, CashDisbursementsJournalUncheckedUpdateWithoutSupplierInput>
  }

  export type CashDisbursementsJournalUpdateManyWithWhereWithoutSupplierInput = {
    where: CashDisbursementsJournalScalarWhereInput
    data: XOR<CashDisbursementsJournalUpdateManyMutationInput, CashDisbursementsJournalUncheckedUpdateManyWithoutCashDisbursementsJournalInput>
  }

  export type CashReceiptsJournalUpsertWithWhereUniqueWithoutSupplierInput = {
    where: CashReceiptsJournalWhereUniqueInput
    update: XOR<CashReceiptsJournalUpdateWithoutSupplierInput, CashReceiptsJournalUncheckedUpdateWithoutSupplierInput>
    create: XOR<CashReceiptsJournalCreateWithoutSupplierInput, CashReceiptsJournalUncheckedCreateWithoutSupplierInput>
  }

  export type CashReceiptsJournalUpdateWithWhereUniqueWithoutSupplierInput = {
    where: CashReceiptsJournalWhereUniqueInput
    data: XOR<CashReceiptsJournalUpdateWithoutSupplierInput, CashReceiptsJournalUncheckedUpdateWithoutSupplierInput>
  }

  export type CashReceiptsJournalUpdateManyWithWhereWithoutSupplierInput = {
    where: CashReceiptsJournalScalarWhereInput
    data: XOR<CashReceiptsJournalUpdateManyMutationInput, CashReceiptsJournalUncheckedUpdateManyWithoutCashReceiptsJournalInput>
  }

  export type ReturnsOutwardsJournalUpsertWithWhereUniqueWithoutSupplierInput = {
    where: ReturnsOutwardsJournalWhereUniqueInput
    update: XOR<ReturnsOutwardsJournalUpdateWithoutSupplierInput, ReturnsOutwardsJournalUncheckedUpdateWithoutSupplierInput>
    create: XOR<ReturnsOutwardsJournalCreateWithoutSupplierInput, ReturnsOutwardsJournalUncheckedCreateWithoutSupplierInput>
  }

  export type ReturnsOutwardsJournalUpdateWithWhereUniqueWithoutSupplierInput = {
    where: ReturnsOutwardsJournalWhereUniqueInput
    data: XOR<ReturnsOutwardsJournalUpdateWithoutSupplierInput, ReturnsOutwardsJournalUncheckedUpdateWithoutSupplierInput>
  }

  export type ReturnsOutwardsJournalUpdateManyWithWhereWithoutSupplierInput = {
    where: ReturnsOutwardsJournalScalarWhereInput
    data: XOR<ReturnsOutwardsJournalUpdateManyMutationInput, ReturnsOutwardsJournalUncheckedUpdateManyWithoutReturnsOutwardsJournalInput>
  }

  export type AddressCreateWithoutCustomersInput = {
    id?: string
    street: string
    city: string
    country: string
    zip?: string | null
    suppliers?: SupplierCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutCustomersInput = {
    id?: string
    supplierId?: string | null
    street: string
    city: string
    country: string
    zip?: string | null
  }

  export type AddressCreateOrConnectWithoutCustomersInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutCustomersInput, AddressUncheckedCreateWithoutCustomersInput>
  }

  export type AddressCreateManyCustomersInputEnvelope = {
    data: Enumerable<AddressCreateManyCustomersInput>
    skipDuplicates?: boolean
  }

  export type invoiceCreateWithoutCustomerInput = {
    id?: string
    discount?: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    tax?: TaxCreateNestedManyWithoutInvoiceInput
    createdAt?: Date | string
    updatedAt?: Date | string
    cashier: UserCreateNestedOneWithoutInvoiceInput
    product: ProductCreateNestedOneWithoutInvoiceInput
    transaction: TransactionCreateNestedOneWithoutInvoiceInput
    Supplier?: SupplierCreateNestedOneWithoutInvoiceInput
  }

  export type invoiceUncheckedCreateWithoutCustomerInput = {
    id?: string
    productId: string
    discount?: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    transactionId: number
    cashierId: number
    tax?: TaxUncheckedCreateNestedManyWithoutInvoiceInput
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierId?: string | null
  }

  export type invoiceCreateOrConnectWithoutCustomerInput = {
    where: invoiceWhereUniqueInput
    create: XOR<invoiceCreateWithoutCustomerInput, invoiceUncheckedCreateWithoutCustomerInput>
  }

  export type invoiceCreateManyCustomerInputEnvelope = {
    data: Enumerable<invoiceCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutCustomerInput = {
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    errorDescription?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    users: UserCreateNestedOneWithoutTransactionInput
    supplier?: SupplierCreateNestedOneWithoutTransactionsInput
    payments?: PaymentCreateNestedManyWithoutTransactionInput
    invoice?: invoiceCreateNestedManyWithoutTransactionInput
    journal?: JournalCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutCustomerInput = {
    id?: number
    initiatedBy: number
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    supplierId?: string | null
    errorDescription?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    payments?: PaymentUncheckedCreateNestedManyWithoutTransactionInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutTransactionInput
    journal?: JournalUncheckedCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput>
  }

  export type TransactionCreateManyCustomerInputEnvelope = {
    data: Enumerable<TransactionCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type JournalCreateWithoutCustomerInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutJournalInput
    supplier?: SupplierCreateNestedOneWithoutJournalInput
    transaction: TransactionCreateNestedOneWithoutJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type JournalUncheckedCreateWithoutCustomerInput = {
    id?: string
    recorderId: number
    supplierId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type JournalCreateOrConnectWithoutCustomerInput = {
    where: JournalWhereUniqueInput
    create: XOR<JournalCreateWithoutCustomerInput, JournalUncheckedCreateWithoutCustomerInput>
  }

  export type JournalCreateManyCustomerInputEnvelope = {
    data: Enumerable<JournalCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type PurchasesJournalCreateWithoutCustomerInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutPurchasesJournalInput
    transaction: TransactionCreateNestedOneWithoutPurchasesJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalUncheckedCreateWithoutCustomerInput = {
    id?: string
    recorderId: number
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalCreateOrConnectWithoutCustomerInput = {
    where: PurchasesJournalWhereUniqueInput
    create: XOR<PurchasesJournalCreateWithoutCustomerInput, PurchasesJournalUncheckedCreateWithoutCustomerInput>
  }

  export type PurchasesJournalCreateManyCustomerInputEnvelope = {
    data: Enumerable<PurchasesJournalCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type CashDisbursementsJournalCreateWithoutCustomerInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutCashDisbursementsJournalInput
    supplier?: SupplierCreateNestedOneWithoutCashDisbursementsJournalInput
    transaction: TransactionCreateNestedOneWithoutCashDisbursementsJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalUncheckedCreateWithoutCustomerInput = {
    id?: string
    recorderId: number
    supplierId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalCreateOrConnectWithoutCustomerInput = {
    where: CashDisbursementsJournalWhereUniqueInput
    create: XOR<CashDisbursementsJournalCreateWithoutCustomerInput, CashDisbursementsJournalUncheckedCreateWithoutCustomerInput>
  }

  export type CashDisbursementsJournalCreateManyCustomerInputEnvelope = {
    data: Enumerable<CashDisbursementsJournalCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type CashReceiptsJournalCreateWithoutCustomerInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutCashReceiptsJournalInput
    supplier?: SupplierCreateNestedOneWithoutCashReceiptsJournalInput
    transaction: TransactionCreateNestedOneWithoutCashReceiptsJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalUncheckedCreateWithoutCustomerInput = {
    id?: string
    recorderId: number
    supplierId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalCreateOrConnectWithoutCustomerInput = {
    where: CashReceiptsJournalWhereUniqueInput
    create: XOR<CashReceiptsJournalCreateWithoutCustomerInput, CashReceiptsJournalUncheckedCreateWithoutCustomerInput>
  }

  export type CashReceiptsJournalCreateManyCustomerInputEnvelope = {
    data: Enumerable<CashReceiptsJournalCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type ReturnsInwardsJournalCreateWithoutCustomerInput = {
    id?: string
    recorder: UserCreateNestedOneWithoutReturnsInwardsJournalInput
    transaction: TransactionCreateNestedOneWithoutReturnsInwardsJournalInput
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalUncheckedCreateWithoutCustomerInput = {
    id?: string
    recorderId: number
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalCreateOrConnectWithoutCustomerInput = {
    where: ReturnsInwardsJournalWhereUniqueInput
    create: XOR<ReturnsInwardsJournalCreateWithoutCustomerInput, ReturnsInwardsJournalUncheckedCreateWithoutCustomerInput>
  }

  export type ReturnsInwardsJournalCreateManyCustomerInputEnvelope = {
    data: Enumerable<ReturnsInwardsJournalCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithWhereUniqueWithoutCustomersInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutCustomersInput, AddressUncheckedUpdateWithoutCustomersInput>
    create: XOR<AddressCreateWithoutCustomersInput, AddressUncheckedCreateWithoutCustomersInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutCustomersInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutCustomersInput, AddressUncheckedUpdateWithoutCustomersInput>
  }

  export type AddressUpdateManyWithWhereWithoutCustomersInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutAddressInput>
  }

  export type invoiceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: invoiceWhereUniqueInput
    update: XOR<invoiceUpdateWithoutCustomerInput, invoiceUncheckedUpdateWithoutCustomerInput>
    create: XOR<invoiceCreateWithoutCustomerInput, invoiceUncheckedCreateWithoutCustomerInput>
  }

  export type invoiceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: invoiceWhereUniqueInput
    data: XOR<invoiceUpdateWithoutCustomerInput, invoiceUncheckedUpdateWithoutCustomerInput>
  }

  export type invoiceUpdateManyWithWhereWithoutCustomerInput = {
    where: invoiceScalarWhereInput
    data: XOR<invoiceUpdateManyMutationInput, invoiceUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCustomerInput, TransactionUncheckedUpdateWithoutCustomerInput>
    create: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCustomerInput, TransactionUncheckedUpdateWithoutCustomerInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCustomerInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTransactionInput>
  }

  export type JournalUpsertWithWhereUniqueWithoutCustomerInput = {
    where: JournalWhereUniqueInput
    update: XOR<JournalUpdateWithoutCustomerInput, JournalUncheckedUpdateWithoutCustomerInput>
    create: XOR<JournalCreateWithoutCustomerInput, JournalUncheckedCreateWithoutCustomerInput>
  }

  export type JournalUpdateWithWhereUniqueWithoutCustomerInput = {
    where: JournalWhereUniqueInput
    data: XOR<JournalUpdateWithoutCustomerInput, JournalUncheckedUpdateWithoutCustomerInput>
  }

  export type JournalUpdateManyWithWhereWithoutCustomerInput = {
    where: JournalScalarWhereInput
    data: XOR<JournalUpdateManyMutationInput, JournalUncheckedUpdateManyWithoutJournalInput>
  }

  export type PurchasesJournalUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PurchasesJournalWhereUniqueInput
    update: XOR<PurchasesJournalUpdateWithoutCustomerInput, PurchasesJournalUncheckedUpdateWithoutCustomerInput>
    create: XOR<PurchasesJournalCreateWithoutCustomerInput, PurchasesJournalUncheckedCreateWithoutCustomerInput>
  }

  export type PurchasesJournalUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PurchasesJournalWhereUniqueInput
    data: XOR<PurchasesJournalUpdateWithoutCustomerInput, PurchasesJournalUncheckedUpdateWithoutCustomerInput>
  }

  export type PurchasesJournalUpdateManyWithWhereWithoutCustomerInput = {
    where: PurchasesJournalScalarWhereInput
    data: XOR<PurchasesJournalUpdateManyMutationInput, PurchasesJournalUncheckedUpdateManyWithoutPurchasesJournalInput>
  }

  export type CashDisbursementsJournalUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CashDisbursementsJournalWhereUniqueInput
    update: XOR<CashDisbursementsJournalUpdateWithoutCustomerInput, CashDisbursementsJournalUncheckedUpdateWithoutCustomerInput>
    create: XOR<CashDisbursementsJournalCreateWithoutCustomerInput, CashDisbursementsJournalUncheckedCreateWithoutCustomerInput>
  }

  export type CashDisbursementsJournalUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CashDisbursementsJournalWhereUniqueInput
    data: XOR<CashDisbursementsJournalUpdateWithoutCustomerInput, CashDisbursementsJournalUncheckedUpdateWithoutCustomerInput>
  }

  export type CashDisbursementsJournalUpdateManyWithWhereWithoutCustomerInput = {
    where: CashDisbursementsJournalScalarWhereInput
    data: XOR<CashDisbursementsJournalUpdateManyMutationInput, CashDisbursementsJournalUncheckedUpdateManyWithoutCashDisbursementsJournalInput>
  }

  export type CashReceiptsJournalUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CashReceiptsJournalWhereUniqueInput
    update: XOR<CashReceiptsJournalUpdateWithoutCustomerInput, CashReceiptsJournalUncheckedUpdateWithoutCustomerInput>
    create: XOR<CashReceiptsJournalCreateWithoutCustomerInput, CashReceiptsJournalUncheckedCreateWithoutCustomerInput>
  }

  export type CashReceiptsJournalUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CashReceiptsJournalWhereUniqueInput
    data: XOR<CashReceiptsJournalUpdateWithoutCustomerInput, CashReceiptsJournalUncheckedUpdateWithoutCustomerInput>
  }

  export type CashReceiptsJournalUpdateManyWithWhereWithoutCustomerInput = {
    where: CashReceiptsJournalScalarWhereInput
    data: XOR<CashReceiptsJournalUpdateManyMutationInput, CashReceiptsJournalUncheckedUpdateManyWithoutCashReceiptsJournalInput>
  }

  export type ReturnsInwardsJournalUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ReturnsInwardsJournalWhereUniqueInput
    update: XOR<ReturnsInwardsJournalUpdateWithoutCustomerInput, ReturnsInwardsJournalUncheckedUpdateWithoutCustomerInput>
    create: XOR<ReturnsInwardsJournalCreateWithoutCustomerInput, ReturnsInwardsJournalUncheckedCreateWithoutCustomerInput>
  }

  export type ReturnsInwardsJournalUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ReturnsInwardsJournalWhereUniqueInput
    data: XOR<ReturnsInwardsJournalUpdateWithoutCustomerInput, ReturnsInwardsJournalUncheckedUpdateWithoutCustomerInput>
  }

  export type ReturnsInwardsJournalUpdateManyWithWhereWithoutCustomerInput = {
    where: ReturnsInwardsJournalScalarWhereInput
    data: XOR<ReturnsInwardsJournalUpdateManyMutationInput, ReturnsInwardsJournalUncheckedUpdateManyWithoutReturnsInwardsJournalInput>
  }

  export type CustomerCreateWithoutAddressInput = {
    id?: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    emailAddress?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    invoice?: invoiceCreateNestedManyWithoutCustomerInput
    transaction?: TransactionCreateNestedManyWithoutCustomerInput
    Journal?: JournalCreateNestedManyWithoutCustomerInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutCustomerInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutCustomerInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutCustomerInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutAddressInput = {
    id?: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    emailAddress?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    invoice?: invoiceUncheckedCreateNestedManyWithoutCustomerInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    Journal?: JournalUncheckedCreateNestedManyWithoutCustomerInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutCustomerInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutCustomerInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutCustomerInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutAddressInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutAddressInput, CustomerUncheckedCreateWithoutAddressInput>
  }

  export type SupplierCreateWithoutAddressInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
    product?: ProductCreateNestedManyWithoutSupplierInput
    invoice?: invoiceCreateNestedManyWithoutSupplierInput
    transactions?: TransactionCreateNestedManyWithoutSupplierInput
    Journal?: JournalCreateNestedManyWithoutSupplierInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutSupplierInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutSupplierInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutSupplierInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutAddressInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
    product?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutSupplierInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSupplierInput
    Journal?: JournalUncheckedCreateNestedManyWithoutSupplierInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutSupplierInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutSupplierInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutSupplierInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutAddressInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutAddressInput, SupplierUncheckedCreateWithoutAddressInput>
  }

  export type CustomerUpsertWithoutAddressInput = {
    update: XOR<CustomerUpdateWithoutAddressInput, CustomerUncheckedUpdateWithoutAddressInput>
    create: XOR<CustomerCreateWithoutAddressInput, CustomerUncheckedCreateWithoutAddressInput>
  }

  export type CustomerUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: invoiceUpdateManyWithoutCustomerNestedInput
    transaction?: TransactionUpdateManyWithoutCustomerNestedInput
    Journal?: JournalUpdateManyWithoutCustomerNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutCustomerNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutCustomerNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutCustomerNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: invoiceUncheckedUpdateManyWithoutCustomerNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    Journal?: JournalUncheckedUpdateManyWithoutCustomerNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutCustomerNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutCustomerNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutCustomerNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type SupplierUpsertWithoutAddressInput = {
    update: XOR<SupplierUpdateWithoutAddressInput, SupplierUncheckedUpdateWithoutAddressInput>
    create: XOR<SupplierCreateWithoutAddressInput, SupplierUncheckedCreateWithoutAddressInput>
  }

  export type SupplierUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateManyWithoutSupplierNestedInput
    invoice?: invoiceUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUpdateManyWithoutSupplierNestedInput
    Journal?: JournalUpdateManyWithoutSupplierNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutSupplierNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutSupplierNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutSupplierNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSupplierNestedInput
    Journal?: JournalUncheckedUpdateManyWithoutSupplierNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutSupplierNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutSupplierNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutSupplierNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type currencyCreateWithoutBaseCurrencyInput = {
    id?: string
    currencyName: string
    updatedAt?: Date | string
    createdAt?: Date | string
    exchangeRates?: exchangeRatesCreateNestedManyWithoutCurrencyInput
    payments?: PaymentCreateNestedManyWithoutCurrencyInput
    tax?: TaxCreateNestedManyWithoutCurrencyInput
  }

  export type currencyUncheckedCreateWithoutBaseCurrencyInput = {
    id?: string
    currencyName: string
    updatedAt?: Date | string
    createdAt?: Date | string
    exchangeRates?: exchangeRatesUncheckedCreateNestedManyWithoutCurrencyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCurrencyInput
    tax?: TaxUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type currencyCreateOrConnectWithoutBaseCurrencyInput = {
    where: currencyWhereUniqueInput
    create: XOR<currencyCreateWithoutBaseCurrencyInput, currencyUncheckedCreateWithoutBaseCurrencyInput>
  }

  export type exchangeRatesCreateWithoutBaseCurrencyInput = {
    id?: string
    exchangeRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    active?: boolean
    currency: currencyCreateNestedOneWithoutExchangeRatesInput
    payments?: PaymentCreateNestedManyWithoutExchangeRatesInput
    prices?: PricesCreateNestedManyWithoutExchangeRatesInput
  }

  export type exchangeRatesUncheckedCreateWithoutBaseCurrencyInput = {
    id?: string
    exchangeRate: Decimal | DecimalJsLike | number | string
    currencyId: string
    createdAt?: Date | string
    active?: boolean
    payments?: PaymentUncheckedCreateNestedManyWithoutExchangeRatesInput
    prices?: PricesUncheckedCreateNestedManyWithoutExchangeRatesInput
  }

  export type exchangeRatesCreateOrConnectWithoutBaseCurrencyInput = {
    where: exchangeRatesWhereUniqueInput
    create: XOR<exchangeRatesCreateWithoutBaseCurrencyInput, exchangeRatesUncheckedCreateWithoutBaseCurrencyInput>
  }

  export type exchangeRatesCreateManyBaseCurrencyInputEnvelope = {
    data: Enumerable<exchangeRatesCreateManyBaseCurrencyInput>
    skipDuplicates?: boolean
  }

  export type currencyUpsertWithoutBaseCurrencyInput = {
    update: XOR<currencyUpdateWithoutBaseCurrencyInput, currencyUncheckedUpdateWithoutBaseCurrencyInput>
    create: XOR<currencyCreateWithoutBaseCurrencyInput, currencyUncheckedCreateWithoutBaseCurrencyInput>
  }

  export type currencyUpdateWithoutBaseCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeRates?: exchangeRatesUpdateManyWithoutCurrencyNestedInput
    payments?: PaymentUpdateManyWithoutCurrencyNestedInput
    tax?: TaxUpdateManyWithoutCurrencyNestedInput
  }

  export type currencyUncheckedUpdateWithoutBaseCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeRates?: exchangeRatesUncheckedUpdateManyWithoutCurrencyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCurrencyNestedInput
    tax?: TaxUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type exchangeRatesUpsertWithWhereUniqueWithoutBaseCurrencyInput = {
    where: exchangeRatesWhereUniqueInput
    update: XOR<exchangeRatesUpdateWithoutBaseCurrencyInput, exchangeRatesUncheckedUpdateWithoutBaseCurrencyInput>
    create: XOR<exchangeRatesCreateWithoutBaseCurrencyInput, exchangeRatesUncheckedCreateWithoutBaseCurrencyInput>
  }

  export type exchangeRatesUpdateWithWhereUniqueWithoutBaseCurrencyInput = {
    where: exchangeRatesWhereUniqueInput
    data: XOR<exchangeRatesUpdateWithoutBaseCurrencyInput, exchangeRatesUncheckedUpdateWithoutBaseCurrencyInput>
  }

  export type exchangeRatesUpdateManyWithWhereWithoutBaseCurrencyInput = {
    where: exchangeRatesScalarWhereInput
    data: XOR<exchangeRatesUpdateManyMutationInput, exchangeRatesUncheckedUpdateManyWithoutExchangeRatesInput>
  }

  export type exchangeRatesScalarWhereInput = {
    AND?: Enumerable<exchangeRatesScalarWhereInput>
    OR?: Enumerable<exchangeRatesScalarWhereInput>
    NOT?: Enumerable<exchangeRatesScalarWhereInput>
    id?: StringFilter | string
    exchangeRate?: DecimalFilter | Decimal | DecimalJsLike | number | string
    currencyId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    baseCurrencyId?: StringFilter | string
    active?: BoolFilter | boolean
  }

  export type baseCurrencyCreateWithoutCurrencyInput = {
    id?: string
    createdAt?: Date | string
    active?: boolean
    exchangeRates?: exchangeRatesCreateNestedManyWithoutBaseCurrencyInput
  }

  export type baseCurrencyUncheckedCreateWithoutCurrencyInput = {
    id?: string
    createdAt?: Date | string
    active?: boolean
    exchangeRates?: exchangeRatesUncheckedCreateNestedManyWithoutBaseCurrencyInput
  }

  export type baseCurrencyCreateOrConnectWithoutCurrencyInput = {
    where: baseCurrencyWhereUniqueInput
    create: XOR<baseCurrencyCreateWithoutCurrencyInput, baseCurrencyUncheckedCreateWithoutCurrencyInput>
  }

  export type baseCurrencyCreateManyCurrencyInputEnvelope = {
    data: Enumerable<baseCurrencyCreateManyCurrencyInput>
    skipDuplicates?: boolean
  }

  export type exchangeRatesCreateWithoutCurrencyInput = {
    id?: string
    exchangeRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    active?: boolean
    baseCurrency: baseCurrencyCreateNestedOneWithoutExchangeRatesInput
    payments?: PaymentCreateNestedManyWithoutExchangeRatesInput
    prices?: PricesCreateNestedManyWithoutExchangeRatesInput
  }

  export type exchangeRatesUncheckedCreateWithoutCurrencyInput = {
    id?: string
    exchangeRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    baseCurrencyId: string
    active?: boolean
    payments?: PaymentUncheckedCreateNestedManyWithoutExchangeRatesInput
    prices?: PricesUncheckedCreateNestedManyWithoutExchangeRatesInput
  }

  export type exchangeRatesCreateOrConnectWithoutCurrencyInput = {
    where: exchangeRatesWhereUniqueInput
    create: XOR<exchangeRatesCreateWithoutCurrencyInput, exchangeRatesUncheckedCreateWithoutCurrencyInput>
  }

  export type exchangeRatesCreateManyCurrencyInputEnvelope = {
    data: Enumerable<exchangeRatesCreateManyCurrencyInput>
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutCurrencyInput = {
    id?: string
    paymentType: PaymentTypeCreateNestedOneWithoutPaymentInput
    paid: Decimal | DecimalJsLike | number | string
    exchangeRates: exchangeRatesCreateNestedOneWithoutPaymentsInput
    transaction: TransactionCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutCurrencyInput = {
    id?: string
    paymentTypeId: string
    exchangeRateId: string
    transactionId: number
    paid: Decimal | DecimalJsLike | number | string
  }

  export type PaymentCreateOrConnectWithoutCurrencyInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCurrencyInput, PaymentUncheckedCreateWithoutCurrencyInput>
  }

  export type PaymentCreateManyCurrencyInputEnvelope = {
    data: Enumerable<PaymentCreateManyCurrencyInput>
    skipDuplicates?: boolean
  }

  export type TaxCreateWithoutCurrencyInput = {
    id?: string
    taxName: string
    taxRate: string
    startAmount: Decimal | DecimalJsLike | number | string
    endAmount: Decimal | DecimalJsLike | number | string
    active?: boolean
    startDate: Date | string
    endDate: Date | string
    PaymentType?: PaymentTypeCreateNestedManyWithoutTaxInput
    product?: ProductCreateNestedManyWithoutTaxInput
    invoice?: invoiceCreateNestedManyWithoutTaxInput
    productGroup?: ProductGroupCreateNestedManyWithoutTaxInput
  }

  export type TaxUncheckedCreateWithoutCurrencyInput = {
    id?: string
    taxName: string
    taxRate: string
    startAmount: Decimal | DecimalJsLike | number | string
    endAmount: Decimal | DecimalJsLike | number | string
    active?: boolean
    startDate: Date | string
    endDate: Date | string
    PaymentType?: PaymentTypeUncheckedCreateNestedManyWithoutTaxInput
    product?: ProductUncheckedCreateNestedManyWithoutTaxInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutTaxInput
    productGroup?: ProductGroupUncheckedCreateNestedManyWithoutTaxInput
  }

  export type TaxCreateOrConnectWithoutCurrencyInput = {
    where: TaxWhereUniqueInput
    create: XOR<TaxCreateWithoutCurrencyInput, TaxUncheckedCreateWithoutCurrencyInput>
  }

  export type baseCurrencyUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: baseCurrencyWhereUniqueInput
    update: XOR<baseCurrencyUpdateWithoutCurrencyInput, baseCurrencyUncheckedUpdateWithoutCurrencyInput>
    create: XOR<baseCurrencyCreateWithoutCurrencyInput, baseCurrencyUncheckedCreateWithoutCurrencyInput>
  }

  export type baseCurrencyUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: baseCurrencyWhereUniqueInput
    data: XOR<baseCurrencyUpdateWithoutCurrencyInput, baseCurrencyUncheckedUpdateWithoutCurrencyInput>
  }

  export type baseCurrencyUpdateManyWithWhereWithoutCurrencyInput = {
    where: baseCurrencyScalarWhereInput
    data: XOR<baseCurrencyUpdateManyMutationInput, baseCurrencyUncheckedUpdateManyWithoutBaseCurrencyInput>
  }

  export type baseCurrencyScalarWhereInput = {
    AND?: Enumerable<baseCurrencyScalarWhereInput>
    OR?: Enumerable<baseCurrencyScalarWhereInput>
    NOT?: Enumerable<baseCurrencyScalarWhereInput>
    id?: StringFilter | string
    currencyId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    active?: BoolFilter | boolean
  }

  export type exchangeRatesUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: exchangeRatesWhereUniqueInput
    update: XOR<exchangeRatesUpdateWithoutCurrencyInput, exchangeRatesUncheckedUpdateWithoutCurrencyInput>
    create: XOR<exchangeRatesCreateWithoutCurrencyInput, exchangeRatesUncheckedCreateWithoutCurrencyInput>
  }

  export type exchangeRatesUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: exchangeRatesWhereUniqueInput
    data: XOR<exchangeRatesUpdateWithoutCurrencyInput, exchangeRatesUncheckedUpdateWithoutCurrencyInput>
  }

  export type exchangeRatesUpdateManyWithWhereWithoutCurrencyInput = {
    where: exchangeRatesScalarWhereInput
    data: XOR<exchangeRatesUpdateManyMutationInput, exchangeRatesUncheckedUpdateManyWithoutExchangeRatesInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCurrencyInput, PaymentUncheckedUpdateWithoutCurrencyInput>
    create: XOR<PaymentCreateWithoutCurrencyInput, PaymentUncheckedCreateWithoutCurrencyInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCurrencyInput, PaymentUncheckedUpdateWithoutCurrencyInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCurrencyInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPaymentsInput>
  }

  export type TaxUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: TaxWhereUniqueInput
    update: XOR<TaxUpdateWithoutCurrencyInput, TaxUncheckedUpdateWithoutCurrencyInput>
    create: XOR<TaxCreateWithoutCurrencyInput, TaxUncheckedCreateWithoutCurrencyInput>
  }

  export type TaxUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: TaxWhereUniqueInput
    data: XOR<TaxUpdateWithoutCurrencyInput, TaxUncheckedUpdateWithoutCurrencyInput>
  }

  export type TaxUpdateManyWithWhereWithoutCurrencyInput = {
    where: TaxScalarWhereInput
    data: XOR<TaxUpdateManyMutationInput, TaxUncheckedUpdateManyWithoutTaxInput>
  }

  export type PricesCreateWithoutDisposalsInput = {
    id?: string
    barcode: string
    price: Decimal | DecimalJsLike | number | string
    active: boolean
    exchangeRates: exchangeRatesCreateNestedOneWithoutPricesInput
    Product?: ProductCreateNestedOneWithoutPriceInput
  }

  export type PricesUncheckedCreateWithoutDisposalsInput = {
    id?: string
    barcode: string
    price: Decimal | DecimalJsLike | number | string
    active: boolean
    exchangeRateId: string
    productId?: string | null
  }

  export type PricesCreateOrConnectWithoutDisposalsInput = {
    where: PricesWhereUniqueInput
    create: XOR<PricesCreateWithoutDisposalsInput, PricesUncheckedCreateWithoutDisposalsInput>
  }

  export type ProductCreateWithoutDisposalsInput = {
    id?: string
    barcode: string
    productName: string
    measurementUnit: MeasurementUnit
    expiryDate: Date | string
    measurementAmount: number
    cost: Decimal | DecimalJsLike | number | string
    quantity: number
    tax?: TaxCreateNestedManyWithoutProductInput
    productGroup?: ProductGroupCreateNestedOneWithoutProductInput
    updatedAt?: Date | string
    createdAt?: Date | string
    depleted?: boolean
    disposed?: boolean
    supplier?: SupplierCreateNestedOneWithoutProductInput
    price?: PricesCreateNestedManyWithoutProductInput
    promotion?: PromotionsCreateNestedManyWithoutProductInput
    invoice?: invoiceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutDisposalsInput = {
    id?: string
    barcode: string
    productName: string
    measurementUnit: MeasurementUnit
    expiryDate: Date | string
    measurementAmount: number
    cost: Decimal | DecimalJsLike | number | string
    quantity: number
    supplierId?: string | null
    tax?: TaxUncheckedCreateNestedManyWithoutProductInput
    productGroupId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    depleted?: boolean
    disposed?: boolean
    price?: PricesUncheckedCreateNestedManyWithoutProductInput
    promotion?: PromotionsUncheckedCreateNestedManyWithoutProductInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutDisposalsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutDisposalsInput, ProductUncheckedCreateWithoutDisposalsInput>
  }

  export type PricesUpsertWithoutDisposalsInput = {
    update: XOR<PricesUpdateWithoutDisposalsInput, PricesUncheckedUpdateWithoutDisposalsInput>
    create: XOR<PricesCreateWithoutDisposalsInput, PricesUncheckedCreateWithoutDisposalsInput>
  }

  export type PricesUpdateWithoutDisposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    exchangeRates?: exchangeRatesUpdateOneRequiredWithoutPricesNestedInput
    Product?: ProductUpdateOneWithoutPriceNestedInput
  }

  export type PricesUncheckedUpdateWithoutDisposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    exchangeRateId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpsertWithoutDisposalsInput = {
    update: XOR<ProductUpdateWithoutDisposalsInput, ProductUncheckedUpdateWithoutDisposalsInput>
    create: XOR<ProductCreateWithoutDisposalsInput, ProductUncheckedCreateWithoutDisposalsInput>
  }

  export type ProductUpdateWithoutDisposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    measurementUnit?: EnumMeasurementUnitFieldUpdateOperationsInput | MeasurementUnit
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementAmount?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    tax?: TaxUpdateManyWithoutProductNestedInput
    productGroup?: ProductGroupUpdateOneWithoutProductNestedInput
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depleted?: BoolFieldUpdateOperationsInput | boolean
    disposed?: BoolFieldUpdateOperationsInput | boolean
    supplier?: SupplierUpdateOneWithoutProductNestedInput
    price?: PricesUpdateManyWithoutProductNestedInput
    promotion?: PromotionsUpdateManyWithoutProductNestedInput
    invoice?: invoiceUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutDisposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    measurementUnit?: EnumMeasurementUnitFieldUpdateOperationsInput | MeasurementUnit
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementAmount?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: TaxUncheckedUpdateManyWithoutProductNestedInput
    productGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depleted?: BoolFieldUpdateOperationsInput | boolean
    disposed?: BoolFieldUpdateOperationsInput | boolean
    price?: PricesUncheckedUpdateManyWithoutProductNestedInput
    promotion?: PromotionsUncheckedUpdateManyWithoutProductNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutProductNestedInput
  }

  export type baseCurrencyCreateWithoutExchangeRatesInput = {
    id?: string
    createdAt?: Date | string
    active?: boolean
    currency: currencyCreateNestedOneWithoutBaseCurrencyInput
  }

  export type baseCurrencyUncheckedCreateWithoutExchangeRatesInput = {
    id?: string
    currencyId: string
    createdAt?: Date | string
    active?: boolean
  }

  export type baseCurrencyCreateOrConnectWithoutExchangeRatesInput = {
    where: baseCurrencyWhereUniqueInput
    create: XOR<baseCurrencyCreateWithoutExchangeRatesInput, baseCurrencyUncheckedCreateWithoutExchangeRatesInput>
  }

  export type currencyCreateWithoutExchangeRatesInput = {
    id?: string
    currencyName: string
    updatedAt?: Date | string
    createdAt?: Date | string
    baseCurrency?: baseCurrencyCreateNestedManyWithoutCurrencyInput
    payments?: PaymentCreateNestedManyWithoutCurrencyInput
    tax?: TaxCreateNestedManyWithoutCurrencyInput
  }

  export type currencyUncheckedCreateWithoutExchangeRatesInput = {
    id?: string
    currencyName: string
    updatedAt?: Date | string
    createdAt?: Date | string
    baseCurrency?: baseCurrencyUncheckedCreateNestedManyWithoutCurrencyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCurrencyInput
    tax?: TaxUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type currencyCreateOrConnectWithoutExchangeRatesInput = {
    where: currencyWhereUniqueInput
    create: XOR<currencyCreateWithoutExchangeRatesInput, currencyUncheckedCreateWithoutExchangeRatesInput>
  }

  export type PaymentCreateWithoutExchangeRatesInput = {
    id?: string
    paymentType: PaymentTypeCreateNestedOneWithoutPaymentInput
    paid: Decimal | DecimalJsLike | number | string
    currency: currencyCreateNestedOneWithoutPaymentsInput
    transaction: TransactionCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutExchangeRatesInput = {
    id?: string
    paymentTypeId: string
    currencyId: string
    transactionId: number
    paid: Decimal | DecimalJsLike | number | string
  }

  export type PaymentCreateOrConnectWithoutExchangeRatesInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutExchangeRatesInput, PaymentUncheckedCreateWithoutExchangeRatesInput>
  }

  export type PaymentCreateManyExchangeRatesInputEnvelope = {
    data: Enumerable<PaymentCreateManyExchangeRatesInput>
    skipDuplicates?: boolean
  }

  export type PricesCreateWithoutExchangeRatesInput = {
    id?: string
    barcode: string
    price: Decimal | DecimalJsLike | number | string
    active: boolean
    Product?: ProductCreateNestedOneWithoutPriceInput
    disposals?: disposalsCreateNestedManyWithoutPricesInput
  }

  export type PricesUncheckedCreateWithoutExchangeRatesInput = {
    id?: string
    barcode: string
    price: Decimal | DecimalJsLike | number | string
    active: boolean
    productId?: string | null
    disposals?: disposalsUncheckedCreateNestedManyWithoutPricesInput
  }

  export type PricesCreateOrConnectWithoutExchangeRatesInput = {
    where: PricesWhereUniqueInput
    create: XOR<PricesCreateWithoutExchangeRatesInput, PricesUncheckedCreateWithoutExchangeRatesInput>
  }

  export type PricesCreateManyExchangeRatesInputEnvelope = {
    data: Enumerable<PricesCreateManyExchangeRatesInput>
    skipDuplicates?: boolean
  }

  export type baseCurrencyUpsertWithoutExchangeRatesInput = {
    update: XOR<baseCurrencyUpdateWithoutExchangeRatesInput, baseCurrencyUncheckedUpdateWithoutExchangeRatesInput>
    create: XOR<baseCurrencyCreateWithoutExchangeRatesInput, baseCurrencyUncheckedCreateWithoutExchangeRatesInput>
  }

  export type baseCurrencyUpdateWithoutExchangeRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    currency?: currencyUpdateOneRequiredWithoutBaseCurrencyNestedInput
  }

  export type baseCurrencyUncheckedUpdateWithoutExchangeRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type currencyUpsertWithoutExchangeRatesInput = {
    update: XOR<currencyUpdateWithoutExchangeRatesInput, currencyUncheckedUpdateWithoutExchangeRatesInput>
    create: XOR<currencyCreateWithoutExchangeRatesInput, currencyUncheckedCreateWithoutExchangeRatesInput>
  }

  export type currencyUpdateWithoutExchangeRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseCurrency?: baseCurrencyUpdateManyWithoutCurrencyNestedInput
    payments?: PaymentUpdateManyWithoutCurrencyNestedInput
    tax?: TaxUpdateManyWithoutCurrencyNestedInput
  }

  export type currencyUncheckedUpdateWithoutExchangeRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseCurrency?: baseCurrencyUncheckedUpdateManyWithoutCurrencyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCurrencyNestedInput
    tax?: TaxUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutExchangeRatesInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutExchangeRatesInput, PaymentUncheckedUpdateWithoutExchangeRatesInput>
    create: XOR<PaymentCreateWithoutExchangeRatesInput, PaymentUncheckedCreateWithoutExchangeRatesInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutExchangeRatesInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutExchangeRatesInput, PaymentUncheckedUpdateWithoutExchangeRatesInput>
  }

  export type PaymentUpdateManyWithWhereWithoutExchangeRatesInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPaymentsInput>
  }

  export type PricesUpsertWithWhereUniqueWithoutExchangeRatesInput = {
    where: PricesWhereUniqueInput
    update: XOR<PricesUpdateWithoutExchangeRatesInput, PricesUncheckedUpdateWithoutExchangeRatesInput>
    create: XOR<PricesCreateWithoutExchangeRatesInput, PricesUncheckedCreateWithoutExchangeRatesInput>
  }

  export type PricesUpdateWithWhereUniqueWithoutExchangeRatesInput = {
    where: PricesWhereUniqueInput
    data: XOR<PricesUpdateWithoutExchangeRatesInput, PricesUncheckedUpdateWithoutExchangeRatesInput>
  }

  export type PricesUpdateManyWithWhereWithoutExchangeRatesInput = {
    where: PricesScalarWhereInput
    data: XOR<PricesUpdateManyMutationInput, PricesUncheckedUpdateManyWithoutPricesInput>
  }

  export type UserCreateWithoutJournalInput = {
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    invoice?: invoiceCreateNestedManyWithoutCashierInput
    action?: ActionCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUsersInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutRecorderInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutRecorderInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutRecorderInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutRecorderInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutRecorderInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutRecorderInput
  }

  export type UserUncheckedCreateWithoutJournalInput = {
    id?: number
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    invoice?: invoiceUncheckedCreateNestedManyWithoutCashierInput
    action?: ActionUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUsersInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutRecorderInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutRecorderInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutRecorderInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutRecorderInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutRecorderInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutRecorderInput
  }

  export type UserCreateOrConnectWithoutJournalInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJournalInput, UserUncheckedCreateWithoutJournalInput>
  }

  export type SupplierCreateWithoutJournalInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
    address?: AddressCreateNestedManyWithoutSuppliersInput
    product?: ProductCreateNestedManyWithoutSupplierInput
    invoice?: invoiceCreateNestedManyWithoutSupplierInput
    transactions?: TransactionCreateNestedManyWithoutSupplierInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutSupplierInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutSupplierInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutSupplierInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutJournalInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutSuppliersInput
    product?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutSupplierInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSupplierInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutSupplierInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutSupplierInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutSupplierInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutJournalInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutJournalInput, SupplierUncheckedCreateWithoutJournalInput>
  }

  export type CustomerCreateWithoutJournalInput = {
    id?: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    emailAddress?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    address?: AddressCreateNestedManyWithoutCustomersInput
    invoice?: invoiceCreateNestedManyWithoutCustomerInput
    transaction?: TransactionCreateNestedManyWithoutCustomerInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutCustomerInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutCustomerInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutCustomerInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutJournalInput = {
    id?: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    emailAddress?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    address?: AddressUncheckedCreateNestedManyWithoutCustomersInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutCustomerInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutCustomerInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutCustomerInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutCustomerInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutJournalInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutJournalInput, CustomerUncheckedCreateWithoutJournalInput>
  }

  export type TransactionCreateWithoutJournalInput = {
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    errorDescription?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    users: UserCreateNestedOneWithoutTransactionInput
    customer?: CustomerCreateNestedOneWithoutTransactionInput
    supplier?: SupplierCreateNestedOneWithoutTransactionsInput
    payments?: PaymentCreateNestedManyWithoutTransactionInput
    invoice?: invoiceCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutJournalInput = {
    id?: number
    initiatedBy: number
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    supplierId?: string | null
    errorDescription?: string | null
    customerId?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    payments?: PaymentUncheckedCreateNestedManyWithoutTransactionInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutJournalInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutJournalInput, TransactionUncheckedCreateWithoutJournalInput>
  }

  export type UserUpsertWithoutJournalInput = {
    update: XOR<UserUpdateWithoutJournalInput, UserUncheckedUpdateWithoutJournalInput>
    create: XOR<UserCreateWithoutJournalInput, UserUncheckedCreateWithoutJournalInput>
  }

  export type UserUpdateWithoutJournalInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoiceUpdateManyWithoutCashierNestedInput
    action?: ActionUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUsersNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutRecorderNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutRecorderNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutRecorderNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutRecorderNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutRecorderNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutRecorderNestedInput
  }

  export type UserUncheckedUpdateWithoutJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoiceUncheckedUpdateManyWithoutCashierNestedInput
    action?: ActionUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUsersNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutRecorderNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutRecorderNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput
  }

  export type SupplierUpsertWithoutJournalInput = {
    update: XOR<SupplierUpdateWithoutJournalInput, SupplierUncheckedUpdateWithoutJournalInput>
    create: XOR<SupplierCreateWithoutJournalInput, SupplierUncheckedCreateWithoutJournalInput>
  }

  export type SupplierUpdateWithoutJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutSuppliersNestedInput
    product?: ProductUpdateManyWithoutSupplierNestedInput
    invoice?: invoiceUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUpdateManyWithoutSupplierNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutSupplierNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutSupplierNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutSupplierNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutSuppliersNestedInput
    product?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSupplierNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutSupplierNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutSupplierNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutSupplierNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type CustomerUpsertWithoutJournalInput = {
    update: XOR<CustomerUpdateWithoutJournalInput, CustomerUncheckedUpdateWithoutJournalInput>
    create: XOR<CustomerCreateWithoutJournalInput, CustomerUncheckedCreateWithoutJournalInput>
  }

  export type CustomerUpdateWithoutJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateManyWithoutCustomersNestedInput
    invoice?: invoiceUpdateManyWithoutCustomerNestedInput
    transaction?: TransactionUpdateManyWithoutCustomerNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutCustomerNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutCustomerNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutCustomerNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUncheckedUpdateManyWithoutCustomersNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutCustomerNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutCustomerNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutCustomerNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutCustomerNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type TransactionUpsertWithoutJournalInput = {
    update: XOR<TransactionUpdateWithoutJournalInput, TransactionUncheckedUpdateWithoutJournalInput>
    create: XOR<TransactionCreateWithoutJournalInput, TransactionUncheckedCreateWithoutJournalInput>
  }

  export type TransactionUpdateWithoutJournalInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    users?: UserUpdateOneRequiredWithoutTransactionNestedInput
    customer?: CustomerUpdateOneWithoutTransactionNestedInput
    supplier?: SupplierUpdateOneWithoutTransactionsNestedInput
    payments?: PaymentUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    initiatedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    payments?: PaymentUncheckedUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type UserCreateWithoutSalesJournalInput = {
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    invoice?: invoiceCreateNestedManyWithoutCashierInput
    journal?: JournalCreateNestedManyWithoutRecorderInput
    action?: ActionCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUsersInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutRecorderInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutRecorderInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutRecorderInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutRecorderInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutRecorderInput
  }

  export type UserUncheckedCreateWithoutSalesJournalInput = {
    id?: number
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    invoice?: invoiceUncheckedCreateNestedManyWithoutCashierInput
    journal?: JournalUncheckedCreateNestedManyWithoutRecorderInput
    action?: ActionUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUsersInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutRecorderInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutRecorderInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutRecorderInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutRecorderInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutRecorderInput
  }

  export type UserCreateOrConnectWithoutSalesJournalInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalesJournalInput, UserUncheckedCreateWithoutSalesJournalInput>
  }

  export type SupplierCreateWithoutSalesJournalInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
    address?: AddressCreateNestedManyWithoutSuppliersInput
    product?: ProductCreateNestedManyWithoutSupplierInput
    invoice?: invoiceCreateNestedManyWithoutSupplierInput
    transactions?: TransactionCreateNestedManyWithoutSupplierInput
    Journal?: JournalCreateNestedManyWithoutSupplierInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutSupplierInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutSupplierInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutSalesJournalInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutSuppliersInput
    product?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutSupplierInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSupplierInput
    Journal?: JournalUncheckedCreateNestedManyWithoutSupplierInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutSupplierInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutSupplierInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutSalesJournalInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutSalesJournalInput, SupplierUncheckedCreateWithoutSalesJournalInput>
  }

  export type TransactionCreateWithoutSalesJournalInput = {
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    errorDescription?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    users: UserCreateNestedOneWithoutTransactionInput
    customer?: CustomerCreateNestedOneWithoutTransactionInput
    supplier?: SupplierCreateNestedOneWithoutTransactionsInput
    payments?: PaymentCreateNestedManyWithoutTransactionInput
    invoice?: invoiceCreateNestedManyWithoutTransactionInput
    journal?: JournalCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutSalesJournalInput = {
    id?: number
    initiatedBy: number
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    supplierId?: string | null
    errorDescription?: string | null
    customerId?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    payments?: PaymentUncheckedCreateNestedManyWithoutTransactionInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutTransactionInput
    journal?: JournalUncheckedCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutSalesJournalInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutSalesJournalInput, TransactionUncheckedCreateWithoutSalesJournalInput>
  }

  export type UserUpsertWithoutSalesJournalInput = {
    update: XOR<UserUpdateWithoutSalesJournalInput, UserUncheckedUpdateWithoutSalesJournalInput>
    create: XOR<UserCreateWithoutSalesJournalInput, UserUncheckedCreateWithoutSalesJournalInput>
  }

  export type UserUpdateWithoutSalesJournalInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoiceUpdateManyWithoutCashierNestedInput
    journal?: JournalUpdateManyWithoutRecorderNestedInput
    action?: ActionUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUsersNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutRecorderNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutRecorderNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutRecorderNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutRecorderNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutRecorderNestedInput
  }

  export type UserUncheckedUpdateWithoutSalesJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoiceUncheckedUpdateManyWithoutCashierNestedInput
    journal?: JournalUncheckedUpdateManyWithoutRecorderNestedInput
    action?: ActionUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUsersNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutRecorderNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput
  }

  export type SupplierUpsertWithoutSalesJournalInput = {
    update: XOR<SupplierUpdateWithoutSalesJournalInput, SupplierUncheckedUpdateWithoutSalesJournalInput>
    create: XOR<SupplierCreateWithoutSalesJournalInput, SupplierUncheckedCreateWithoutSalesJournalInput>
  }

  export type SupplierUpdateWithoutSalesJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutSuppliersNestedInput
    product?: ProductUpdateManyWithoutSupplierNestedInput
    invoice?: invoiceUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUpdateManyWithoutSupplierNestedInput
    Journal?: JournalUpdateManyWithoutSupplierNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutSupplierNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutSupplierNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutSalesJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutSuppliersNestedInput
    product?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSupplierNestedInput
    Journal?: JournalUncheckedUpdateManyWithoutSupplierNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutSupplierNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutSupplierNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type TransactionUpsertWithoutSalesJournalInput = {
    update: XOR<TransactionUpdateWithoutSalesJournalInput, TransactionUncheckedUpdateWithoutSalesJournalInput>
    create: XOR<TransactionCreateWithoutSalesJournalInput, TransactionUncheckedCreateWithoutSalesJournalInput>
  }

  export type TransactionUpdateWithoutSalesJournalInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    users?: UserUpdateOneRequiredWithoutTransactionNestedInput
    customer?: CustomerUpdateOneWithoutTransactionNestedInput
    supplier?: SupplierUpdateOneWithoutTransactionsNestedInput
    payments?: PaymentUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUpdateManyWithoutTransactionNestedInput
    journal?: JournalUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutSalesJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    initiatedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    payments?: PaymentUncheckedUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutTransactionNestedInput
    journal?: JournalUncheckedUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type UserCreateWithoutPurchasesJournalInput = {
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    invoice?: invoiceCreateNestedManyWithoutCashierInput
    journal?: JournalCreateNestedManyWithoutRecorderInput
    action?: ActionCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUsersInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutRecorderInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutRecorderInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutRecorderInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutRecorderInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutRecorderInput
  }

  export type UserUncheckedCreateWithoutPurchasesJournalInput = {
    id?: number
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    invoice?: invoiceUncheckedCreateNestedManyWithoutCashierInput
    journal?: JournalUncheckedCreateNestedManyWithoutRecorderInput
    action?: ActionUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUsersInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutRecorderInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutRecorderInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutRecorderInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutRecorderInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutRecorderInput
  }

  export type UserCreateOrConnectWithoutPurchasesJournalInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchasesJournalInput, UserUncheckedCreateWithoutPurchasesJournalInput>
  }

  export type CustomerCreateWithoutPurchasesJournalInput = {
    id?: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    emailAddress?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    address?: AddressCreateNestedManyWithoutCustomersInput
    invoice?: invoiceCreateNestedManyWithoutCustomerInput
    transaction?: TransactionCreateNestedManyWithoutCustomerInput
    Journal?: JournalCreateNestedManyWithoutCustomerInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutCustomerInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutCustomerInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPurchasesJournalInput = {
    id?: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    emailAddress?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    address?: AddressUncheckedCreateNestedManyWithoutCustomersInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutCustomerInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    Journal?: JournalUncheckedCreateNestedManyWithoutCustomerInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutCustomerInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutCustomerInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPurchasesJournalInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPurchasesJournalInput, CustomerUncheckedCreateWithoutPurchasesJournalInput>
  }

  export type TransactionCreateWithoutPurchasesJournalInput = {
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    errorDescription?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    users: UserCreateNestedOneWithoutTransactionInput
    customer?: CustomerCreateNestedOneWithoutTransactionInput
    supplier?: SupplierCreateNestedOneWithoutTransactionsInput
    payments?: PaymentCreateNestedManyWithoutTransactionInput
    invoice?: invoiceCreateNestedManyWithoutTransactionInput
    journal?: JournalCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutPurchasesJournalInput = {
    id?: number
    initiatedBy: number
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    supplierId?: string | null
    errorDescription?: string | null
    customerId?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    payments?: PaymentUncheckedCreateNestedManyWithoutTransactionInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutTransactionInput
    journal?: JournalUncheckedCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutPurchasesJournalInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPurchasesJournalInput, TransactionUncheckedCreateWithoutPurchasesJournalInput>
  }

  export type UserUpsertWithoutPurchasesJournalInput = {
    update: XOR<UserUpdateWithoutPurchasesJournalInput, UserUncheckedUpdateWithoutPurchasesJournalInput>
    create: XOR<UserCreateWithoutPurchasesJournalInput, UserUncheckedCreateWithoutPurchasesJournalInput>
  }

  export type UserUpdateWithoutPurchasesJournalInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoiceUpdateManyWithoutCashierNestedInput
    journal?: JournalUpdateManyWithoutRecorderNestedInput
    action?: ActionUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUsersNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutRecorderNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutRecorderNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutRecorderNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutRecorderNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutRecorderNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchasesJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoiceUncheckedUpdateManyWithoutCashierNestedInput
    journal?: JournalUncheckedUpdateManyWithoutRecorderNestedInput
    action?: ActionUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUsersNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutRecorderNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput
  }

  export type CustomerUpsertWithoutPurchasesJournalInput = {
    update: XOR<CustomerUpdateWithoutPurchasesJournalInput, CustomerUncheckedUpdateWithoutPurchasesJournalInput>
    create: XOR<CustomerCreateWithoutPurchasesJournalInput, CustomerUncheckedCreateWithoutPurchasesJournalInput>
  }

  export type CustomerUpdateWithoutPurchasesJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateManyWithoutCustomersNestedInput
    invoice?: invoiceUpdateManyWithoutCustomerNestedInput
    transaction?: TransactionUpdateManyWithoutCustomerNestedInput
    Journal?: JournalUpdateManyWithoutCustomerNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutCustomerNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutCustomerNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPurchasesJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUncheckedUpdateManyWithoutCustomersNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutCustomerNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    Journal?: JournalUncheckedUpdateManyWithoutCustomerNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutCustomerNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutCustomerNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type TransactionUpsertWithoutPurchasesJournalInput = {
    update: XOR<TransactionUpdateWithoutPurchasesJournalInput, TransactionUncheckedUpdateWithoutPurchasesJournalInput>
    create: XOR<TransactionCreateWithoutPurchasesJournalInput, TransactionUncheckedCreateWithoutPurchasesJournalInput>
  }

  export type TransactionUpdateWithoutPurchasesJournalInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    users?: UserUpdateOneRequiredWithoutTransactionNestedInput
    customer?: CustomerUpdateOneWithoutTransactionNestedInput
    supplier?: SupplierUpdateOneWithoutTransactionsNestedInput
    payments?: PaymentUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUpdateManyWithoutTransactionNestedInput
    journal?: JournalUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutPurchasesJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    initiatedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    payments?: PaymentUncheckedUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutTransactionNestedInput
    journal?: JournalUncheckedUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type UserCreateWithoutCashDisbursementsJournalInput = {
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    invoice?: invoiceCreateNestedManyWithoutCashierInput
    journal?: JournalCreateNestedManyWithoutRecorderInput
    action?: ActionCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUsersInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutRecorderInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutRecorderInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutRecorderInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutRecorderInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutRecorderInput
  }

  export type UserUncheckedCreateWithoutCashDisbursementsJournalInput = {
    id?: number
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    invoice?: invoiceUncheckedCreateNestedManyWithoutCashierInput
    journal?: JournalUncheckedCreateNestedManyWithoutRecorderInput
    action?: ActionUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUsersInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutRecorderInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutRecorderInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutRecorderInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutRecorderInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutRecorderInput
  }

  export type UserCreateOrConnectWithoutCashDisbursementsJournalInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCashDisbursementsJournalInput, UserUncheckedCreateWithoutCashDisbursementsJournalInput>
  }

  export type SupplierCreateWithoutCashDisbursementsJournalInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
    address?: AddressCreateNestedManyWithoutSuppliersInput
    product?: ProductCreateNestedManyWithoutSupplierInput
    invoice?: invoiceCreateNestedManyWithoutSupplierInput
    transactions?: TransactionCreateNestedManyWithoutSupplierInput
    Journal?: JournalCreateNestedManyWithoutSupplierInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutSupplierInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutSupplierInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutCashDisbursementsJournalInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutSuppliersInput
    product?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutSupplierInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSupplierInput
    Journal?: JournalUncheckedCreateNestedManyWithoutSupplierInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutSupplierInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutSupplierInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutCashDisbursementsJournalInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutCashDisbursementsJournalInput, SupplierUncheckedCreateWithoutCashDisbursementsJournalInput>
  }

  export type CustomerCreateWithoutCashDisbursementsJournalInput = {
    id?: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    emailAddress?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    address?: AddressCreateNestedManyWithoutCustomersInput
    invoice?: invoiceCreateNestedManyWithoutCustomerInput
    transaction?: TransactionCreateNestedManyWithoutCustomerInput
    Journal?: JournalCreateNestedManyWithoutCustomerInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutCustomerInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutCustomerInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCashDisbursementsJournalInput = {
    id?: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    emailAddress?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    address?: AddressUncheckedCreateNestedManyWithoutCustomersInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutCustomerInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    Journal?: JournalUncheckedCreateNestedManyWithoutCustomerInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutCustomerInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutCustomerInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCashDisbursementsJournalInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCashDisbursementsJournalInput, CustomerUncheckedCreateWithoutCashDisbursementsJournalInput>
  }

  export type TransactionCreateWithoutCashDisbursementsJournalInput = {
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    errorDescription?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    users: UserCreateNestedOneWithoutTransactionInput
    customer?: CustomerCreateNestedOneWithoutTransactionInput
    supplier?: SupplierCreateNestedOneWithoutTransactionsInput
    payments?: PaymentCreateNestedManyWithoutTransactionInput
    invoice?: invoiceCreateNestedManyWithoutTransactionInput
    journal?: JournalCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutCashDisbursementsJournalInput = {
    id?: number
    initiatedBy: number
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    supplierId?: string | null
    errorDescription?: string | null
    customerId?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    payments?: PaymentUncheckedCreateNestedManyWithoutTransactionInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutTransactionInput
    journal?: JournalUncheckedCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutCashDisbursementsJournalInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCashDisbursementsJournalInput, TransactionUncheckedCreateWithoutCashDisbursementsJournalInput>
  }

  export type UserUpsertWithoutCashDisbursementsJournalInput = {
    update: XOR<UserUpdateWithoutCashDisbursementsJournalInput, UserUncheckedUpdateWithoutCashDisbursementsJournalInput>
    create: XOR<UserCreateWithoutCashDisbursementsJournalInput, UserUncheckedCreateWithoutCashDisbursementsJournalInput>
  }

  export type UserUpdateWithoutCashDisbursementsJournalInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoiceUpdateManyWithoutCashierNestedInput
    journal?: JournalUpdateManyWithoutRecorderNestedInput
    action?: ActionUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUsersNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutRecorderNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutRecorderNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutRecorderNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutRecorderNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutRecorderNestedInput
  }

  export type UserUncheckedUpdateWithoutCashDisbursementsJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoiceUncheckedUpdateManyWithoutCashierNestedInput
    journal?: JournalUncheckedUpdateManyWithoutRecorderNestedInput
    action?: ActionUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUsersNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutRecorderNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutRecorderNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput
  }

  export type SupplierUpsertWithoutCashDisbursementsJournalInput = {
    update: XOR<SupplierUpdateWithoutCashDisbursementsJournalInput, SupplierUncheckedUpdateWithoutCashDisbursementsJournalInput>
    create: XOR<SupplierCreateWithoutCashDisbursementsJournalInput, SupplierUncheckedCreateWithoutCashDisbursementsJournalInput>
  }

  export type SupplierUpdateWithoutCashDisbursementsJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutSuppliersNestedInput
    product?: ProductUpdateManyWithoutSupplierNestedInput
    invoice?: invoiceUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUpdateManyWithoutSupplierNestedInput
    Journal?: JournalUpdateManyWithoutSupplierNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutSupplierNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutSupplierNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutCashDisbursementsJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutSuppliersNestedInput
    product?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSupplierNestedInput
    Journal?: JournalUncheckedUpdateManyWithoutSupplierNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutSupplierNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutSupplierNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type CustomerUpsertWithoutCashDisbursementsJournalInput = {
    update: XOR<CustomerUpdateWithoutCashDisbursementsJournalInput, CustomerUncheckedUpdateWithoutCashDisbursementsJournalInput>
    create: XOR<CustomerCreateWithoutCashDisbursementsJournalInput, CustomerUncheckedCreateWithoutCashDisbursementsJournalInput>
  }

  export type CustomerUpdateWithoutCashDisbursementsJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateManyWithoutCustomersNestedInput
    invoice?: invoiceUpdateManyWithoutCustomerNestedInput
    transaction?: TransactionUpdateManyWithoutCustomerNestedInput
    Journal?: JournalUpdateManyWithoutCustomerNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutCustomerNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutCustomerNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCashDisbursementsJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUncheckedUpdateManyWithoutCustomersNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutCustomerNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    Journal?: JournalUncheckedUpdateManyWithoutCustomerNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutCustomerNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutCustomerNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type TransactionUpsertWithoutCashDisbursementsJournalInput = {
    update: XOR<TransactionUpdateWithoutCashDisbursementsJournalInput, TransactionUncheckedUpdateWithoutCashDisbursementsJournalInput>
    create: XOR<TransactionCreateWithoutCashDisbursementsJournalInput, TransactionUncheckedCreateWithoutCashDisbursementsJournalInput>
  }

  export type TransactionUpdateWithoutCashDisbursementsJournalInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    users?: UserUpdateOneRequiredWithoutTransactionNestedInput
    customer?: CustomerUpdateOneWithoutTransactionNestedInput
    supplier?: SupplierUpdateOneWithoutTransactionsNestedInput
    payments?: PaymentUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUpdateManyWithoutTransactionNestedInput
    journal?: JournalUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCashDisbursementsJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    initiatedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    payments?: PaymentUncheckedUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutTransactionNestedInput
    journal?: JournalUncheckedUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type UserCreateWithoutCashReceiptsJournalInput = {
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    invoice?: invoiceCreateNestedManyWithoutCashierInput
    journal?: JournalCreateNestedManyWithoutRecorderInput
    action?: ActionCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUsersInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutRecorderInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutRecorderInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutRecorderInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutRecorderInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutRecorderInput
  }

  export type UserUncheckedCreateWithoutCashReceiptsJournalInput = {
    id?: number
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    invoice?: invoiceUncheckedCreateNestedManyWithoutCashierInput
    journal?: JournalUncheckedCreateNestedManyWithoutRecorderInput
    action?: ActionUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUsersInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutRecorderInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutRecorderInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutRecorderInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutRecorderInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutRecorderInput
  }

  export type UserCreateOrConnectWithoutCashReceiptsJournalInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCashReceiptsJournalInput, UserUncheckedCreateWithoutCashReceiptsJournalInput>
  }

  export type SupplierCreateWithoutCashReceiptsJournalInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
    address?: AddressCreateNestedManyWithoutSuppliersInput
    product?: ProductCreateNestedManyWithoutSupplierInput
    invoice?: invoiceCreateNestedManyWithoutSupplierInput
    transactions?: TransactionCreateNestedManyWithoutSupplierInput
    Journal?: JournalCreateNestedManyWithoutSupplierInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutSupplierInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutSupplierInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutCashReceiptsJournalInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutSuppliersInput
    product?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutSupplierInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSupplierInput
    Journal?: JournalUncheckedCreateNestedManyWithoutSupplierInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutSupplierInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutSupplierInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutCashReceiptsJournalInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutCashReceiptsJournalInput, SupplierUncheckedCreateWithoutCashReceiptsJournalInput>
  }

  export type CustomerCreateWithoutCashReceiptsJournalInput = {
    id?: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    emailAddress?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    address?: AddressCreateNestedManyWithoutCustomersInput
    invoice?: invoiceCreateNestedManyWithoutCustomerInput
    transaction?: TransactionCreateNestedManyWithoutCustomerInput
    Journal?: JournalCreateNestedManyWithoutCustomerInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutCustomerInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutCustomerInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCashReceiptsJournalInput = {
    id?: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    emailAddress?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    address?: AddressUncheckedCreateNestedManyWithoutCustomersInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutCustomerInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    Journal?: JournalUncheckedCreateNestedManyWithoutCustomerInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutCustomerInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutCustomerInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCashReceiptsJournalInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCashReceiptsJournalInput, CustomerUncheckedCreateWithoutCashReceiptsJournalInput>
  }

  export type TransactionCreateWithoutCashReceiptsJournalInput = {
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    errorDescription?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    users: UserCreateNestedOneWithoutTransactionInput
    customer?: CustomerCreateNestedOneWithoutTransactionInput
    supplier?: SupplierCreateNestedOneWithoutTransactionsInput
    payments?: PaymentCreateNestedManyWithoutTransactionInput
    invoice?: invoiceCreateNestedManyWithoutTransactionInput
    journal?: JournalCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutCashReceiptsJournalInput = {
    id?: number
    initiatedBy: number
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    supplierId?: string | null
    errorDescription?: string | null
    customerId?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    payments?: PaymentUncheckedCreateNestedManyWithoutTransactionInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutTransactionInput
    journal?: JournalUncheckedCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutCashReceiptsJournalInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCashReceiptsJournalInput, TransactionUncheckedCreateWithoutCashReceiptsJournalInput>
  }

  export type UserUpsertWithoutCashReceiptsJournalInput = {
    update: XOR<UserUpdateWithoutCashReceiptsJournalInput, UserUncheckedUpdateWithoutCashReceiptsJournalInput>
    create: XOR<UserCreateWithoutCashReceiptsJournalInput, UserUncheckedCreateWithoutCashReceiptsJournalInput>
  }

  export type UserUpdateWithoutCashReceiptsJournalInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoiceUpdateManyWithoutCashierNestedInput
    journal?: JournalUpdateManyWithoutRecorderNestedInput
    action?: ActionUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUsersNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutRecorderNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutRecorderNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutRecorderNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutRecorderNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutRecorderNestedInput
  }

  export type UserUncheckedUpdateWithoutCashReceiptsJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoiceUncheckedUpdateManyWithoutCashierNestedInput
    journal?: JournalUncheckedUpdateManyWithoutRecorderNestedInput
    action?: ActionUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUsersNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutRecorderNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutRecorderNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput
  }

  export type SupplierUpsertWithoutCashReceiptsJournalInput = {
    update: XOR<SupplierUpdateWithoutCashReceiptsJournalInput, SupplierUncheckedUpdateWithoutCashReceiptsJournalInput>
    create: XOR<SupplierCreateWithoutCashReceiptsJournalInput, SupplierUncheckedCreateWithoutCashReceiptsJournalInput>
  }

  export type SupplierUpdateWithoutCashReceiptsJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutSuppliersNestedInput
    product?: ProductUpdateManyWithoutSupplierNestedInput
    invoice?: invoiceUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUpdateManyWithoutSupplierNestedInput
    Journal?: JournalUpdateManyWithoutSupplierNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutSupplierNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutSupplierNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutCashReceiptsJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutSuppliersNestedInput
    product?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSupplierNestedInput
    Journal?: JournalUncheckedUpdateManyWithoutSupplierNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutSupplierNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutSupplierNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type CustomerUpsertWithoutCashReceiptsJournalInput = {
    update: XOR<CustomerUpdateWithoutCashReceiptsJournalInput, CustomerUncheckedUpdateWithoutCashReceiptsJournalInput>
    create: XOR<CustomerCreateWithoutCashReceiptsJournalInput, CustomerUncheckedCreateWithoutCashReceiptsJournalInput>
  }

  export type CustomerUpdateWithoutCashReceiptsJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateManyWithoutCustomersNestedInput
    invoice?: invoiceUpdateManyWithoutCustomerNestedInput
    transaction?: TransactionUpdateManyWithoutCustomerNestedInput
    Journal?: JournalUpdateManyWithoutCustomerNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutCustomerNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutCustomerNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCashReceiptsJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUncheckedUpdateManyWithoutCustomersNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutCustomerNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    Journal?: JournalUncheckedUpdateManyWithoutCustomerNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutCustomerNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutCustomerNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type TransactionUpsertWithoutCashReceiptsJournalInput = {
    update: XOR<TransactionUpdateWithoutCashReceiptsJournalInput, TransactionUncheckedUpdateWithoutCashReceiptsJournalInput>
    create: XOR<TransactionCreateWithoutCashReceiptsJournalInput, TransactionUncheckedCreateWithoutCashReceiptsJournalInput>
  }

  export type TransactionUpdateWithoutCashReceiptsJournalInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    users?: UserUpdateOneRequiredWithoutTransactionNestedInput
    customer?: CustomerUpdateOneWithoutTransactionNestedInput
    supplier?: SupplierUpdateOneWithoutTransactionsNestedInput
    payments?: PaymentUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUpdateManyWithoutTransactionNestedInput
    journal?: JournalUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCashReceiptsJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    initiatedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    payments?: PaymentUncheckedUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutTransactionNestedInput
    journal?: JournalUncheckedUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type UserCreateWithoutReturnsInwardsJournalInput = {
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    invoice?: invoiceCreateNestedManyWithoutCashierInput
    journal?: JournalCreateNestedManyWithoutRecorderInput
    action?: ActionCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUsersInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutRecorderInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutRecorderInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutRecorderInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutRecorderInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutRecorderInput
  }

  export type UserUncheckedCreateWithoutReturnsInwardsJournalInput = {
    id?: number
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    invoice?: invoiceUncheckedCreateNestedManyWithoutCashierInput
    journal?: JournalUncheckedCreateNestedManyWithoutRecorderInput
    action?: ActionUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUsersInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutRecorderInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutRecorderInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutRecorderInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutRecorderInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutRecorderInput
  }

  export type UserCreateOrConnectWithoutReturnsInwardsJournalInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReturnsInwardsJournalInput, UserUncheckedCreateWithoutReturnsInwardsJournalInput>
  }

  export type CustomerCreateWithoutReturnsInwardsJournalInput = {
    id?: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    emailAddress?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    address?: AddressCreateNestedManyWithoutCustomersInput
    invoice?: invoiceCreateNestedManyWithoutCustomerInput
    transaction?: TransactionCreateNestedManyWithoutCustomerInput
    Journal?: JournalCreateNestedManyWithoutCustomerInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutCustomerInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutCustomerInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutReturnsInwardsJournalInput = {
    id?: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    emailAddress?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    address?: AddressUncheckedCreateNestedManyWithoutCustomersInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutCustomerInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    Journal?: JournalUncheckedCreateNestedManyWithoutCustomerInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutCustomerInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutCustomerInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutReturnsInwardsJournalInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutReturnsInwardsJournalInput, CustomerUncheckedCreateWithoutReturnsInwardsJournalInput>
  }

  export type TransactionCreateWithoutReturnsInwardsJournalInput = {
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    errorDescription?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    users: UserCreateNestedOneWithoutTransactionInput
    customer?: CustomerCreateNestedOneWithoutTransactionInput
    supplier?: SupplierCreateNestedOneWithoutTransactionsInput
    payments?: PaymentCreateNestedManyWithoutTransactionInput
    invoice?: invoiceCreateNestedManyWithoutTransactionInput
    journal?: JournalCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutReturnsInwardsJournalInput = {
    id?: number
    initiatedBy: number
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    supplierId?: string | null
    errorDescription?: string | null
    customerId?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    payments?: PaymentUncheckedCreateNestedManyWithoutTransactionInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutTransactionInput
    journal?: JournalUncheckedCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutReturnsInwardsJournalInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutReturnsInwardsJournalInput, TransactionUncheckedCreateWithoutReturnsInwardsJournalInput>
  }

  export type UserUpsertWithoutReturnsInwardsJournalInput = {
    update: XOR<UserUpdateWithoutReturnsInwardsJournalInput, UserUncheckedUpdateWithoutReturnsInwardsJournalInput>
    create: XOR<UserCreateWithoutReturnsInwardsJournalInput, UserUncheckedCreateWithoutReturnsInwardsJournalInput>
  }

  export type UserUpdateWithoutReturnsInwardsJournalInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoiceUpdateManyWithoutCashierNestedInput
    journal?: JournalUpdateManyWithoutRecorderNestedInput
    action?: ActionUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUsersNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutRecorderNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutRecorderNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutRecorderNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutRecorderNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutRecorderNestedInput
  }

  export type UserUncheckedUpdateWithoutReturnsInwardsJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoiceUncheckedUpdateManyWithoutCashierNestedInput
    journal?: JournalUncheckedUpdateManyWithoutRecorderNestedInput
    action?: ActionUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUsersNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutRecorderNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutRecorderNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput
  }

  export type CustomerUpsertWithoutReturnsInwardsJournalInput = {
    update: XOR<CustomerUpdateWithoutReturnsInwardsJournalInput, CustomerUncheckedUpdateWithoutReturnsInwardsJournalInput>
    create: XOR<CustomerCreateWithoutReturnsInwardsJournalInput, CustomerUncheckedCreateWithoutReturnsInwardsJournalInput>
  }

  export type CustomerUpdateWithoutReturnsInwardsJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateManyWithoutCustomersNestedInput
    invoice?: invoiceUpdateManyWithoutCustomerNestedInput
    transaction?: TransactionUpdateManyWithoutCustomerNestedInput
    Journal?: JournalUpdateManyWithoutCustomerNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutCustomerNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutCustomerNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutReturnsInwardsJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUncheckedUpdateManyWithoutCustomersNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutCustomerNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    Journal?: JournalUncheckedUpdateManyWithoutCustomerNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutCustomerNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutCustomerNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type TransactionUpsertWithoutReturnsInwardsJournalInput = {
    update: XOR<TransactionUpdateWithoutReturnsInwardsJournalInput, TransactionUncheckedUpdateWithoutReturnsInwardsJournalInput>
    create: XOR<TransactionCreateWithoutReturnsInwardsJournalInput, TransactionUncheckedCreateWithoutReturnsInwardsJournalInput>
  }

  export type TransactionUpdateWithoutReturnsInwardsJournalInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    users?: UserUpdateOneRequiredWithoutTransactionNestedInput
    customer?: CustomerUpdateOneWithoutTransactionNestedInput
    supplier?: SupplierUpdateOneWithoutTransactionsNestedInput
    payments?: PaymentUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUpdateManyWithoutTransactionNestedInput
    journal?: JournalUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutReturnsInwardsJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    initiatedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    payments?: PaymentUncheckedUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutTransactionNestedInput
    journal?: JournalUncheckedUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type UserCreateWithoutReturnsOutwardsJournalInput = {
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    invoice?: invoiceCreateNestedManyWithoutCashierInput
    journal?: JournalCreateNestedManyWithoutRecorderInput
    action?: ActionCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUsersInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutRecorderInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutRecorderInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutRecorderInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutRecorderInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutRecorderInput
  }

  export type UserUncheckedCreateWithoutReturnsOutwardsJournalInput = {
    id?: number
    firstName: string
    lastName: string
    username: string
    password: string
    phoneNumber: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    emailAddress?: string | null
    invoice?: invoiceUncheckedCreateNestedManyWithoutCashierInput
    journal?: JournalUncheckedCreateNestedManyWithoutRecorderInput
    action?: ActionUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUsersInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutRecorderInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutRecorderInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutRecorderInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutRecorderInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutRecorderInput
  }

  export type UserCreateOrConnectWithoutReturnsOutwardsJournalInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReturnsOutwardsJournalInput, UserUncheckedCreateWithoutReturnsOutwardsJournalInput>
  }

  export type SupplierCreateWithoutReturnsOutwardsJournalInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
    address?: AddressCreateNestedManyWithoutSuppliersInput
    product?: ProductCreateNestedManyWithoutSupplierInput
    invoice?: invoiceCreateNestedManyWithoutSupplierInput
    transactions?: TransactionCreateNestedManyWithoutSupplierInput
    Journal?: JournalCreateNestedManyWithoutSupplierInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutSupplierInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutSupplierInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutReturnsOutwardsJournalInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    corporateName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    emailAddress?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutSuppliersInput
    product?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutSupplierInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSupplierInput
    Journal?: JournalUncheckedCreateNestedManyWithoutSupplierInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutSupplierInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutSupplierInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutReturnsOutwardsJournalInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutReturnsOutwardsJournalInput, SupplierUncheckedCreateWithoutReturnsOutwardsJournalInput>
  }

  export type TransactionCreateWithoutReturnsOutwardsJournalInput = {
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    errorDescription?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    users: UserCreateNestedOneWithoutTransactionInput
    customer?: CustomerCreateNestedOneWithoutTransactionInput
    supplier?: SupplierCreateNestedOneWithoutTransactionsInput
    payments?: PaymentCreateNestedManyWithoutTransactionInput
    invoice?: invoiceCreateNestedManyWithoutTransactionInput
    journal?: JournalCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutReturnsOutwardsJournalInput = {
    id?: number
    initiatedBy: number
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    supplierId?: string | null
    errorDescription?: string | null
    customerId?: string | null
    type: TransactionType
    status: TransactionStatusCodes
    payments?: PaymentUncheckedCreateNestedManyWithoutTransactionInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutTransactionInput
    journal?: JournalUncheckedCreateNestedManyWithoutTransactionInput
    SalesJournal?: SalesJournalUncheckedCreateNestedManyWithoutTransactionInput
    PurchasesJournal?: PurchasesJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedCreateNestedManyWithoutTransactionInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedCreateNestedManyWithoutTransactionInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutReturnsOutwardsJournalInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutReturnsOutwardsJournalInput, TransactionUncheckedCreateWithoutReturnsOutwardsJournalInput>
  }

  export type UserUpsertWithoutReturnsOutwardsJournalInput = {
    update: XOR<UserUpdateWithoutReturnsOutwardsJournalInput, UserUncheckedUpdateWithoutReturnsOutwardsJournalInput>
    create: XOR<UserCreateWithoutReturnsOutwardsJournalInput, UserUncheckedCreateWithoutReturnsOutwardsJournalInput>
  }

  export type UserUpdateWithoutReturnsOutwardsJournalInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoiceUpdateManyWithoutCashierNestedInput
    journal?: JournalUpdateManyWithoutRecorderNestedInput
    action?: ActionUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUsersNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutRecorderNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutRecorderNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutRecorderNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutRecorderNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutRecorderNestedInput
  }

  export type UserUncheckedUpdateWithoutReturnsOutwardsJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoiceUncheckedUpdateManyWithoutCashierNestedInput
    journal?: JournalUncheckedUpdateManyWithoutRecorderNestedInput
    action?: ActionUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUsersNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutRecorderNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutRecorderNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutRecorderNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutRecorderNestedInput
  }

  export type SupplierUpsertWithoutReturnsOutwardsJournalInput = {
    update: XOR<SupplierUpdateWithoutReturnsOutwardsJournalInput, SupplierUncheckedUpdateWithoutReturnsOutwardsJournalInput>
    create: XOR<SupplierCreateWithoutReturnsOutwardsJournalInput, SupplierUncheckedCreateWithoutReturnsOutwardsJournalInput>
  }

  export type SupplierUpdateWithoutReturnsOutwardsJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutSuppliersNestedInput
    product?: ProductUpdateManyWithoutSupplierNestedInput
    invoice?: invoiceUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUpdateManyWithoutSupplierNestedInput
    Journal?: JournalUpdateManyWithoutSupplierNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutSupplierNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutSupplierNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutReturnsOutwardsJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    corporateName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutSuppliersNestedInput
    product?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSupplierNestedInput
    Journal?: JournalUncheckedUpdateManyWithoutSupplierNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutSupplierNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutSupplierNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type TransactionUpsertWithoutReturnsOutwardsJournalInput = {
    update: XOR<TransactionUpdateWithoutReturnsOutwardsJournalInput, TransactionUncheckedUpdateWithoutReturnsOutwardsJournalInput>
    create: XOR<TransactionCreateWithoutReturnsOutwardsJournalInput, TransactionUncheckedCreateWithoutReturnsOutwardsJournalInput>
  }

  export type TransactionUpdateWithoutReturnsOutwardsJournalInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    users?: UserUpdateOneRequiredWithoutTransactionNestedInput
    customer?: CustomerUpdateOneWithoutTransactionNestedInput
    supplier?: SupplierUpdateOneWithoutTransactionsNestedInput
    payments?: PaymentUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUpdateManyWithoutTransactionNestedInput
    journal?: JournalUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutReturnsOutwardsJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    initiatedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    payments?: PaymentUncheckedUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutTransactionNestedInput
    journal?: JournalUncheckedUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type invoiceCreateManyCashierInput = {
    id?: string
    productId: string
    discount?: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    transactionId: number
    customerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierId?: string | null
  }

  export type JournalCreateManyRecorderInput = {
    id?: string
    supplierId?: string | null
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ActionCreateManyUserInput = {
    id?: string
    actionType: boolean
    description: string
  }

  export type TransactionCreateManyUsersInput = {
    id?: number
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    supplierId?: string | null
    errorDescription?: string | null
    customerId?: string | null
    type: TransactionType
    status: TransactionStatusCodes
  }

  export type SalesJournalCreateManyRecorderInput = {
    id?: string
    supplierId: string
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalCreateManyRecorderInput = {
    id?: string
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalCreateManyRecorderInput = {
    id?: string
    supplierId?: string | null
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalCreateManyRecorderInput = {
    id?: string
    supplierId?: string | null
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalCreateManyRecorderInput = {
    id?: string
    customerId: string
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalCreateManyRecorderInput = {
    id?: string
    supplierId: string
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type invoiceUpdateWithoutCashierInput = {
    id?: StringFieldUpdateOperationsInput | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    tax?: TaxUpdateManyWithoutInvoiceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutInvoiceNestedInput
    product?: ProductUpdateOneRequiredWithoutInvoiceNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutInvoiceNestedInput
    Supplier?: SupplierUpdateOneWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateWithoutCashierInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    tax?: TaxUncheckedUpdateManyWithoutInvoiceNestedInput
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invoiceUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalUpdateWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: SupplierUpdateOneWithoutJournalNestedInput
    customer?: CustomerUpdateOneWithoutJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type JournalUncheckedUpdateWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type JournalUncheckedUpdateManyWithoutJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ActionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ActionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ActionUncheckedUpdateManyWithoutActionInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionUpdateWithoutUsersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    customer?: CustomerUpdateOneWithoutTransactionNestedInput
    supplier?: SupplierUpdateOneWithoutTransactionsNestedInput
    payments?: PaymentUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUpdateManyWithoutTransactionNestedInput
    journal?: JournalUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    payments?: PaymentUncheckedUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutTransactionNestedInput
    journal?: JournalUncheckedUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
  }

  export type SalesJournalUpdateWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: SupplierUpdateOneRequiredWithoutSalesJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutSalesJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalUncheckedUpdateWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalUncheckedUpdateManyWithoutSalesJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalUpdateWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer?: CustomerUpdateOneWithoutPurchasesJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutPurchasesJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalUncheckedUpdateWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalUncheckedUpdateManyWithoutPurchasesJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalUpdateWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: SupplierUpdateOneWithoutCashDisbursementsJournalNestedInput
    customer?: CustomerUpdateOneWithoutCashDisbursementsJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutCashDisbursementsJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalUncheckedUpdateWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalUncheckedUpdateManyWithoutCashDisbursementsJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalUpdateWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: SupplierUpdateOneWithoutCashReceiptsJournalNestedInput
    customer?: CustomerUpdateOneWithoutCashReceiptsJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutCashReceiptsJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalUncheckedUpdateWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalUncheckedUpdateManyWithoutCashReceiptsJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalUpdateWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer?: CustomerUpdateOneRequiredWithoutReturnsInwardsJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutReturnsInwardsJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalUncheckedUpdateWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalUncheckedUpdateManyWithoutReturnsInwardsJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalUpdateWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: SupplierUpdateOneRequiredWithoutReturnsOutwardsJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutReturnsOutwardsJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalUncheckedUpdateWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalUncheckedUpdateManyWithoutReturnsOutwardsJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentCreateManyTransactionInput = {
    id?: string
    paymentTypeId: string
    currencyId: string
    exchangeRateId: string
    paid: Decimal | DecimalJsLike | number | string
  }

  export type invoiceCreateManyTransactionInput = {
    id?: string
    productId: string
    discount?: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    cashierId: number
    customerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierId?: string | null
  }

  export type JournalCreateManyTransactionInput = {
    id?: string
    recorderId: number
    supplierId?: string | null
    customerId?: string | null
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalCreateManyTransactionInput = {
    id?: string
    recorderId: number
    supplierId: string
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalCreateManyTransactionInput = {
    id?: string
    recorderId: number
    customerId?: string | null
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalCreateManyTransactionInput = {
    id?: string
    recorderId: number
    supplierId?: string | null
    customerId?: string | null
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalCreateManyTransactionInput = {
    id?: string
    recorderId: number
    supplierId?: string | null
    customerId?: string | null
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalCreateManyTransactionInput = {
    id?: string
    recorderId: number
    customerId: string
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalCreateManyTransactionInput = {
    id?: string
    recorderId: number
    supplierId: string
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type PaymentUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentType?: PaymentTypeUpdateOneRequiredWithoutPaymentNestedInput
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: currencyUpdateOneRequiredWithoutPaymentsNestedInput
    exchangeRates?: exchangeRatesUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentTypeId?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    exchangeRateId?: StringFieldUpdateOperationsInput | string
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentUncheckedUpdateManyWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentTypeId?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    exchangeRateId?: StringFieldUpdateOperationsInput | string
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type invoiceUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    tax?: TaxUpdateManyWithoutInvoiceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashier?: UserUpdateOneRequiredWithoutInvoiceNestedInput
    customer?: CustomerUpdateOneWithoutInvoiceNestedInput
    product?: ProductUpdateOneRequiredWithoutInvoiceNestedInput
    Supplier?: SupplierUpdateOneWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    cashierId?: IntFieldUpdateOperationsInput | number
    tax?: TaxUncheckedUpdateManyWithoutInvoiceNestedInput
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutJournalNestedInput
    supplier?: SupplierUpdateOneWithoutJournalNestedInput
    customer?: CustomerUpdateOneWithoutJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type JournalUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutSalesJournalNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutSalesJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    supplierId?: StringFieldUpdateOperationsInput | string
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutPurchasesJournalNestedInput
    customer?: CustomerUpdateOneWithoutPurchasesJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutCashDisbursementsJournalNestedInput
    supplier?: SupplierUpdateOneWithoutCashDisbursementsJournalNestedInput
    customer?: CustomerUpdateOneWithoutCashDisbursementsJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutCashReceiptsJournalNestedInput
    supplier?: SupplierUpdateOneWithoutCashReceiptsJournalNestedInput
    customer?: CustomerUpdateOneWithoutCashReceiptsJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutReturnsInwardsJournalNestedInput
    customer?: CustomerUpdateOneRequiredWithoutReturnsInwardsJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutReturnsOutwardsJournalNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutReturnsOutwardsJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    supplierId?: StringFieldUpdateOperationsInput | string
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentCreateManyPaymentTypeInput = {
    id?: string
    currencyId: string
    exchangeRateId: string
    transactionId: number
    paid: Decimal | DecimalJsLike | number | string
  }

  export type PaymentUpdateWithoutPaymentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: currencyUpdateOneRequiredWithoutPaymentsNestedInput
    exchangeRates?: exchangeRatesUpdateOneRequiredWithoutPaymentsNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutPaymentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    exchangeRateId?: StringFieldUpdateOperationsInput | string
    transactionId?: IntFieldUpdateOperationsInput | number
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    exchangeRateId?: StringFieldUpdateOperationsInput | string
    transactionId?: IntFieldUpdateOperationsInput | number
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type TaxUpdateWithoutPaymentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxName?: StringFieldUpdateOperationsInput | string
    taxRate?: StringFieldUpdateOperationsInput | string
    startAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: currencyUpdateManyWithoutTaxNestedInput
    product?: ProductUpdateManyWithoutTaxNestedInput
    invoice?: invoiceUpdateManyWithoutTaxNestedInput
    productGroup?: ProductGroupUpdateManyWithoutTaxNestedInput
  }

  export type TaxUncheckedUpdateWithoutPaymentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxName?: StringFieldUpdateOperationsInput | string
    taxRate?: StringFieldUpdateOperationsInput | string
    startAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: currencyUncheckedUpdateManyWithoutTaxNestedInput
    product?: ProductUncheckedUpdateManyWithoutTaxNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutTaxNestedInput
    productGroup?: ProductGroupUncheckedUpdateManyWithoutTaxNestedInput
  }

  export type TaxUncheckedUpdateManyWithoutTaxInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxName?: StringFieldUpdateOperationsInput | string
    taxRate?: StringFieldUpdateOperationsInput | string
    startAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductGroupCreateManyTaxInput = {
    id?: string
  }

  export type PaymentTypeUpdateWithoutTaxInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentTypeName?: StringFieldUpdateOperationsInput | string
    payment?: PaymentUpdateManyWithoutPaymentTypeNestedInput
    charges?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentTypeUncheckedUpdateWithoutTaxInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentTypeName?: StringFieldUpdateOperationsInput | string
    payment?: PaymentUncheckedUpdateManyWithoutPaymentTypeNestedInput
    charges?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentTypeUncheckedUpdateManyWithoutPaymentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentTypeName?: StringFieldUpdateOperationsInput | string
    charges?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type currencyUpdateWithoutTaxInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseCurrency?: baseCurrencyUpdateManyWithoutCurrencyNestedInput
    exchangeRates?: exchangeRatesUpdateManyWithoutCurrencyNestedInput
    payments?: PaymentUpdateManyWithoutCurrencyNestedInput
  }

  export type currencyUncheckedUpdateWithoutTaxInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseCurrency?: baseCurrencyUncheckedUpdateManyWithoutCurrencyNestedInput
    exchangeRates?: exchangeRatesUncheckedUpdateManyWithoutCurrencyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type currencyUncheckedUpdateManyWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutTaxInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    measurementUnit?: EnumMeasurementUnitFieldUpdateOperationsInput | MeasurementUnit
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementAmount?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    productGroup?: ProductGroupUpdateOneWithoutProductNestedInput
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depleted?: BoolFieldUpdateOperationsInput | boolean
    disposed?: BoolFieldUpdateOperationsInput | boolean
    supplier?: SupplierUpdateOneWithoutProductNestedInput
    disposals?: disposalsUpdateManyWithoutProductsNestedInput
    price?: PricesUpdateManyWithoutProductNestedInput
    promotion?: PromotionsUpdateManyWithoutProductNestedInput
    invoice?: invoiceUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTaxInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    measurementUnit?: EnumMeasurementUnitFieldUpdateOperationsInput | MeasurementUnit
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementAmount?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    productGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depleted?: BoolFieldUpdateOperationsInput | boolean
    disposed?: BoolFieldUpdateOperationsInput | boolean
    disposals?: disposalsUncheckedUpdateManyWithoutProductsNestedInput
    price?: PricesUncheckedUpdateManyWithoutProductNestedInput
    promotion?: PromotionsUncheckedUpdateManyWithoutProductNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    measurementUnit?: EnumMeasurementUnitFieldUpdateOperationsInput | MeasurementUnit
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementAmount?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    productGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depleted?: BoolFieldUpdateOperationsInput | boolean
    disposed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type invoiceUpdateWithoutTaxInput = {
    id?: StringFieldUpdateOperationsInput | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashier?: UserUpdateOneRequiredWithoutInvoiceNestedInput
    customer?: CustomerUpdateOneWithoutInvoiceNestedInput
    product?: ProductUpdateOneRequiredWithoutInvoiceNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutInvoiceNestedInput
    Supplier?: SupplierUpdateOneWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateWithoutTaxInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    cashierId?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductGroupUpdateWithoutTaxInput = {
    id?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateManyWithoutProductGroupNestedInput
    Promotions?: PromotionsUpdateManyWithoutProductGroupNestedInput
  }

  export type ProductGroupUncheckedUpdateWithoutTaxInput = {
    id?: StringFieldUpdateOperationsInput | string
    product?: ProductUncheckedUpdateManyWithoutProductGroupNestedInput
    Promotions?: PromotionsUncheckedUpdateManyWithoutProductGroupNestedInput
  }

  export type ProductGroupUncheckedUpdateManyWithoutProductGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateManyProductGroupInput = {
    id?: string
    barcode: string
    productName: string
    measurementUnit: MeasurementUnit
    expiryDate: Date | string
    measurementAmount: number
    cost: Decimal | DecimalJsLike | number | string
    quantity: number
    supplierId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    depleted?: boolean
    disposed?: boolean
  }

  export type PromotionsCreateManyProductGroupInput = {
    id?: string
    productId: string
    startDate: Date | string
    endDate: Date | string
    discountRate: Decimal | DecimalJsLike | number | string
  }

  export type ProductUpdateWithoutProductGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    measurementUnit?: EnumMeasurementUnitFieldUpdateOperationsInput | MeasurementUnit
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementAmount?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    tax?: TaxUpdateManyWithoutProductNestedInput
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depleted?: BoolFieldUpdateOperationsInput | boolean
    disposed?: BoolFieldUpdateOperationsInput | boolean
    supplier?: SupplierUpdateOneWithoutProductNestedInput
    disposals?: disposalsUpdateManyWithoutProductsNestedInput
    price?: PricesUpdateManyWithoutProductNestedInput
    promotion?: PromotionsUpdateManyWithoutProductNestedInput
    invoice?: invoiceUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    measurementUnit?: EnumMeasurementUnitFieldUpdateOperationsInput | MeasurementUnit
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementAmount?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: TaxUncheckedUpdateManyWithoutProductNestedInput
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depleted?: BoolFieldUpdateOperationsInput | boolean
    disposed?: BoolFieldUpdateOperationsInput | boolean
    disposals?: disposalsUncheckedUpdateManyWithoutProductsNestedInput
    price?: PricesUncheckedUpdateManyWithoutProductNestedInput
    promotion?: PromotionsUncheckedUpdateManyWithoutProductNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutProductNestedInput
  }

  export type PromotionsUpdateWithoutProductGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutPromotionNestedInput
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PromotionsUncheckedUpdateWithoutProductGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PromotionsUncheckedUpdateManyWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type disposalsCreateManyProductsInput = {
    id?: string
    priceId: string
    createdAt?: Date | string
  }

  export type PricesCreateManyProductInput = {
    id?: string
    barcode: string
    price: Decimal | DecimalJsLike | number | string
    active: boolean
    exchangeRateId: string
  }

  export type PromotionsCreateManyProductInput = {
    id?: string
    productGroupId: string
    startDate: Date | string
    endDate: Date | string
    discountRate: Decimal | DecimalJsLike | number | string
  }

  export type invoiceCreateManyProductInput = {
    id?: string
    discount?: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    transactionId: number
    cashierId: number
    customerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierId?: string | null
  }

  export type TaxUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxName?: StringFieldUpdateOperationsInput | string
    taxRate?: StringFieldUpdateOperationsInput | string
    startAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentType?: PaymentTypeUpdateManyWithoutTaxNestedInput
    currency?: currencyUpdateManyWithoutTaxNestedInput
    invoice?: invoiceUpdateManyWithoutTaxNestedInput
    productGroup?: ProductGroupUpdateManyWithoutTaxNestedInput
  }

  export type TaxUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxName?: StringFieldUpdateOperationsInput | string
    taxRate?: StringFieldUpdateOperationsInput | string
    startAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentType?: PaymentTypeUncheckedUpdateManyWithoutTaxNestedInput
    currency?: currencyUncheckedUpdateManyWithoutTaxNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutTaxNestedInput
    productGroup?: ProductGroupUncheckedUpdateManyWithoutTaxNestedInput
  }

  export type disposalsUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: PricesUpdateOneRequiredWithoutDisposalsNestedInput
  }

  export type disposalsUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    priceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type disposalsUncheckedUpdateManyWithoutDisposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    priceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricesUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    exchangeRates?: exchangeRatesUpdateOneRequiredWithoutPricesNestedInput
    disposals?: disposalsUpdateManyWithoutPricesNestedInput
  }

  export type PricesUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    exchangeRateId?: StringFieldUpdateOperationsInput | string
    disposals?: disposalsUncheckedUpdateManyWithoutPricesNestedInput
  }

  export type PricesUncheckedUpdateManyWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    exchangeRateId?: StringFieldUpdateOperationsInput | string
  }

  export type PromotionsUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    productGroup?: ProductGroupUpdateOneRequiredWithoutPromotionsNestedInput
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PromotionsUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    productGroupId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PromotionsUncheckedUpdateManyWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    productGroupId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type invoiceUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    tax?: TaxUpdateManyWithoutInvoiceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashier?: UserUpdateOneRequiredWithoutInvoiceNestedInput
    customer?: CustomerUpdateOneWithoutInvoiceNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutInvoiceNestedInput
    Supplier?: SupplierUpdateOneWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    cashierId?: IntFieldUpdateOperationsInput | number
    tax?: TaxUncheckedUpdateManyWithoutInvoiceNestedInput
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type disposalsCreateManyPricesInput = {
    id?: string
    productId: string
    createdAt?: Date | string
  }

  export type disposalsUpdateWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateOneRequiredWithoutDisposalsNestedInput
  }

  export type disposalsUncheckedUpdateWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxName?: StringFieldUpdateOperationsInput | string
    taxRate?: StringFieldUpdateOperationsInput | string
    startAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentType?: PaymentTypeUpdateManyWithoutTaxNestedInput
    currency?: currencyUpdateManyWithoutTaxNestedInput
    product?: ProductUpdateManyWithoutTaxNestedInput
    productGroup?: ProductGroupUpdateManyWithoutTaxNestedInput
  }

  export type TaxUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxName?: StringFieldUpdateOperationsInput | string
    taxRate?: StringFieldUpdateOperationsInput | string
    startAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentType?: PaymentTypeUncheckedUpdateManyWithoutTaxNestedInput
    currency?: currencyUncheckedUpdateManyWithoutTaxNestedInput
    product?: ProductUncheckedUpdateManyWithoutTaxNestedInput
    productGroup?: ProductGroupUncheckedUpdateManyWithoutTaxNestedInput
  }

  export type AddressCreateManySuppliersInput = {
    id?: string
    customerId?: string | null
    street: string
    city: string
    country: string
    zip?: string | null
  }

  export type ProductCreateManySupplierInput = {
    id?: string
    barcode: string
    productName: string
    measurementUnit: MeasurementUnit
    expiryDate: Date | string
    measurementAmount: number
    cost: Decimal | DecimalJsLike | number | string
    quantity: number
    productGroupId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    depleted?: boolean
    disposed?: boolean
  }

  export type invoiceCreateManySupplierInput = {
    id?: string
    productId: string
    discount?: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    transactionId: number
    cashierId: number
    customerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManySupplierInput = {
    id?: number
    initiatedBy: number
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    errorDescription?: string | null
    customerId?: string | null
    type: TransactionType
    status: TransactionStatusCodes
  }

  export type JournalCreateManySupplierInput = {
    id?: string
    recorderId: number
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalCreateManySupplierInput = {
    id?: string
    recorderId: number
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalCreateManySupplierInput = {
    id?: string
    recorderId: number
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalCreateManySupplierInput = {
    id?: string
    recorderId: number
    customerId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalCreateManySupplierInput = {
    id?: string
    recorderId: number
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type AddressUpdateWithoutSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    customers?: CustomerUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zip?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddressUncheckedUpdateManyWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zip?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    measurementUnit?: EnumMeasurementUnitFieldUpdateOperationsInput | MeasurementUnit
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementAmount?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    tax?: TaxUpdateManyWithoutProductNestedInput
    productGroup?: ProductGroupUpdateOneWithoutProductNestedInput
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depleted?: BoolFieldUpdateOperationsInput | boolean
    disposed?: BoolFieldUpdateOperationsInput | boolean
    disposals?: disposalsUpdateManyWithoutProductsNestedInput
    price?: PricesUpdateManyWithoutProductNestedInput
    promotion?: PromotionsUpdateManyWithoutProductNestedInput
    invoice?: invoiceUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    measurementUnit?: EnumMeasurementUnitFieldUpdateOperationsInput | MeasurementUnit
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementAmount?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    tax?: TaxUncheckedUpdateManyWithoutProductNestedInput
    productGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depleted?: BoolFieldUpdateOperationsInput | boolean
    disposed?: BoolFieldUpdateOperationsInput | boolean
    disposals?: disposalsUncheckedUpdateManyWithoutProductsNestedInput
    price?: PricesUncheckedUpdateManyWithoutProductNestedInput
    promotion?: PromotionsUncheckedUpdateManyWithoutProductNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutProductNestedInput
  }

  export type invoiceUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    tax?: TaxUpdateManyWithoutInvoiceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashier?: UserUpdateOneRequiredWithoutInvoiceNestedInput
    customer?: CustomerUpdateOneWithoutInvoiceNestedInput
    product?: ProductUpdateOneRequiredWithoutInvoiceNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    cashierId?: IntFieldUpdateOperationsInput | number
    tax?: TaxUncheckedUpdateManyWithoutInvoiceNestedInput
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutSupplierInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    users?: UserUpdateOneRequiredWithoutTransactionNestedInput
    customer?: CustomerUpdateOneWithoutTransactionNestedInput
    payments?: PaymentUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUpdateManyWithoutTransactionNestedInput
    journal?: JournalUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    initiatedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    payments?: PaymentUncheckedUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutTransactionNestedInput
    journal?: JournalUncheckedUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    initiatedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
  }

  export type JournalUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutJournalNestedInput
    customer?: CustomerUpdateOneWithoutJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type JournalUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutSalesJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutSalesJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesJournalUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutCashDisbursementsJournalNestedInput
    customer?: CustomerUpdateOneWithoutCashDisbursementsJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutCashDisbursementsJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutCashReceiptsJournalNestedInput
    customer?: CustomerUpdateOneWithoutCashReceiptsJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutCashReceiptsJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutReturnsOutwardsJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutReturnsOutwardsJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsOutwardsJournalUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AddressCreateManyCustomersInput = {
    id?: string
    supplierId?: string | null
    street: string
    city: string
    country: string
    zip?: string | null
  }

  export type invoiceCreateManyCustomerInput = {
    id?: string
    productId: string
    discount?: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    quantity: number
    transactionId: number
    cashierId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierId?: string | null
  }

  export type TransactionCreateManyCustomerInput = {
    id?: number
    initiatedBy: number
    createdAt?: Date | string
    totalPaid?: Decimal | DecimalJsLike | number | string | null
    totalPayable?: Decimal | DecimalJsLike | number | string | null
    supplierId?: string | null
    errorDescription?: string | null
    type: TransactionType
    status: TransactionStatusCodes
  }

  export type JournalCreateManyCustomerInput = {
    id?: string
    recorderId: number
    supplierId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalCreateManyCustomerInput = {
    id?: string
    recorderId: number
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalCreateManyCustomerInput = {
    id?: string
    recorderId: number
    supplierId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalCreateManyCustomerInput = {
    id?: string
    recorderId: number
    supplierId?: string | null
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalCreateManyCustomerInput = {
    id?: string
    recorderId: number
    transactionId: number
    narration: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type AddressUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    suppliers?: SupplierUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zip?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invoiceUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    tax?: TaxUpdateManyWithoutInvoiceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashier?: UserUpdateOneRequiredWithoutInvoiceNestedInput
    product?: ProductUpdateOneRequiredWithoutInvoiceNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutInvoiceNestedInput
    Supplier?: SupplierUpdateOneWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    cashierId?: IntFieldUpdateOperationsInput | number
    tax?: TaxUncheckedUpdateManyWithoutInvoiceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionUpdateWithoutCustomerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    users?: UserUpdateOneRequiredWithoutTransactionNestedInput
    supplier?: SupplierUpdateOneWithoutTransactionsNestedInput
    payments?: PaymentUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUpdateManyWithoutTransactionNestedInput
    journal?: JournalUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    initiatedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPayable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    status?: EnumTransactionStatusCodesFieldUpdateOperationsInput | TransactionStatusCodes
    payments?: PaymentUncheckedUpdateManyWithoutTransactionNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutTransactionNestedInput
    journal?: JournalUncheckedUpdateManyWithoutTransactionNestedInput
    SalesJournal?: SalesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    PurchasesJournal?: PurchasesJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashDisbursementsJournal?: CashDisbursementsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    CashReceiptsJournal?: CashReceiptsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsInwardsJournal?: ReturnsInwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
    ReturnsOutwardsJournal?: ReturnsOutwardsJournalUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type JournalUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutJournalNestedInput
    supplier?: SupplierUpdateOneWithoutJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type JournalUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutPurchasesJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutPurchasesJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchasesJournalUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutCashDisbursementsJournalNestedInput
    supplier?: SupplierUpdateOneWithoutCashDisbursementsJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutCashDisbursementsJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashDisbursementsJournalUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutCashReceiptsJournalNestedInput
    supplier?: SupplierUpdateOneWithoutCashReceiptsJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutCashReceiptsJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashReceiptsJournalUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorder?: UserUpdateOneRequiredWithoutReturnsInwardsJournalNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutReturnsInwardsJournalNestedInput
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ReturnsInwardsJournalUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    recorderId?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    narration?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type exchangeRatesCreateManyBaseCurrencyInput = {
    id?: string
    exchangeRate: Decimal | DecimalJsLike | number | string
    currencyId: string
    createdAt?: Date | string
    active?: boolean
  }

  export type exchangeRatesUpdateWithoutBaseCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    currency?: currencyUpdateOneRequiredWithoutExchangeRatesNestedInput
    payments?: PaymentUpdateManyWithoutExchangeRatesNestedInput
    prices?: PricesUpdateManyWithoutExchangeRatesNestedInput
  }

  export type exchangeRatesUncheckedUpdateWithoutBaseCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentUncheckedUpdateManyWithoutExchangeRatesNestedInput
    prices?: PricesUncheckedUpdateManyWithoutExchangeRatesNestedInput
  }

  export type exchangeRatesUncheckedUpdateManyWithoutExchangeRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type baseCurrencyCreateManyCurrencyInput = {
    id?: string
    createdAt?: Date | string
    active?: boolean
  }

  export type exchangeRatesCreateManyCurrencyInput = {
    id?: string
    exchangeRate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    baseCurrencyId: string
    active?: boolean
  }

  export type PaymentCreateManyCurrencyInput = {
    id?: string
    paymentTypeId: string
    exchangeRateId: string
    transactionId: number
    paid: Decimal | DecimalJsLike | number | string
  }

  export type baseCurrencyUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    exchangeRates?: exchangeRatesUpdateManyWithoutBaseCurrencyNestedInput
  }

  export type baseCurrencyUncheckedUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    exchangeRates?: exchangeRatesUncheckedUpdateManyWithoutBaseCurrencyNestedInput
  }

  export type baseCurrencyUncheckedUpdateManyWithoutBaseCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type exchangeRatesUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    baseCurrency?: baseCurrencyUpdateOneRequiredWithoutExchangeRatesNestedInput
    payments?: PaymentUpdateManyWithoutExchangeRatesNestedInput
    prices?: PricesUpdateManyWithoutExchangeRatesNestedInput
  }

  export type exchangeRatesUncheckedUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseCurrencyId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentUncheckedUpdateManyWithoutExchangeRatesNestedInput
    prices?: PricesUncheckedUpdateManyWithoutExchangeRatesNestedInput
  }

  export type PaymentUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentType?: PaymentTypeUpdateOneRequiredWithoutPaymentNestedInput
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    exchangeRates?: exchangeRatesUpdateOneRequiredWithoutPaymentsNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentTypeId?: StringFieldUpdateOperationsInput | string
    exchangeRateId?: StringFieldUpdateOperationsInput | string
    transactionId?: IntFieldUpdateOperationsInput | number
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type TaxUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxName?: StringFieldUpdateOperationsInput | string
    taxRate?: StringFieldUpdateOperationsInput | string
    startAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentType?: PaymentTypeUpdateManyWithoutTaxNestedInput
    product?: ProductUpdateManyWithoutTaxNestedInput
    invoice?: invoiceUpdateManyWithoutTaxNestedInput
    productGroup?: ProductGroupUpdateManyWithoutTaxNestedInput
  }

  export type TaxUncheckedUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxName?: StringFieldUpdateOperationsInput | string
    taxRate?: StringFieldUpdateOperationsInput | string
    startAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentType?: PaymentTypeUncheckedUpdateManyWithoutTaxNestedInput
    product?: ProductUncheckedUpdateManyWithoutTaxNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutTaxNestedInput
    productGroup?: ProductGroupUncheckedUpdateManyWithoutTaxNestedInput
  }

  export type PaymentCreateManyExchangeRatesInput = {
    id?: string
    paymentTypeId: string
    currencyId: string
    transactionId: number
    paid: Decimal | DecimalJsLike | number | string
  }

  export type PricesCreateManyExchangeRatesInput = {
    id?: string
    barcode: string
    price: Decimal | DecimalJsLike | number | string
    active: boolean
    productId?: string | null
  }

  export type PaymentUpdateWithoutExchangeRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentType?: PaymentTypeUpdateOneRequiredWithoutPaymentNestedInput
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: currencyUpdateOneRequiredWithoutPaymentsNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutExchangeRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentTypeId?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    transactionId?: IntFieldUpdateOperationsInput | number
    paid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PricesUpdateWithoutExchangeRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    Product?: ProductUpdateOneWithoutPriceNestedInput
    disposals?: disposalsUpdateManyWithoutPricesNestedInput
  }

  export type PricesUncheckedUpdateWithoutExchangeRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    disposals?: disposalsUncheckedUpdateManyWithoutPricesNestedInput
  }

  export type PricesUncheckedUpdateManyWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}